<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>boost io_context에 대한 고찰</title>
    <url>/2021/12/28/boost-io-context/</url>
    <content><![CDATA[<p><em><strong>뭐하는 놈인지는 알고 쓰자</strong></em> 시리즈의 첫번째 주제는 <code>boost io_context</code>입니다.</p>
<span id="more"></span>

<p>이번 기회에 boost 라이브러리를 사용하다보면 한번쯤은 마주치게되는 io_context에 대해 생각해보는 시간을 갖겠습니다.</p>
<br>

<!-- toc -->

<br>

<hr>
<h1 id="Boost-Asio"><a href="#Boost-Asio" class="headerlink" title="Boost Asio"></a>Boost Asio</h1><p>우선 io_context에 대해 이야기하기 전에 Boost Asio를 간략하게 소개하고 넘어가도록 하겠습니다. boost 공식 홈페이지의 내용을 참고하여 작성하였으니 원문 내용은 <a href="https://www.boost.org/doc/libs/1_78_0/doc/html/boost_asio/overview.html">여기</a>를 참조해주시기 바랍니다.</p>
<br>

<p>Boost.Asio는 쓰레드와 명시적 Locking을 기반으로한 동시성 모델의 사용을 프로그램에게 요구하지 않으면서 느린 I/O operation을 관리하는 도구를 제공합니다. (이는 Boost.Asio 내부적으로 동시성 처리를 할거니깐 사용자들은 걱정말고 사용하라는 의미로도 볼 수 있죠.)</p>
<blockquote>
<p>Boost.Asio provides the tools to manage these long running operations, without requiring programs to use concurrency models based on threads and explicit locking.</p>
</blockquote>
<p>소켓을 예로 들어 Boost.Asio에서 사용하는 용어들에 대해 조금 더 알아보도록 하겠습니다.</p>
<br>

<h2 id="동기-연결"><a href="#동기-연결" class="headerlink" title="동기 연결"></a>동기 연결</h2><p>여러분의 프로그램은 적어도 한 개 이상의 (boost::asio::io_context나 boost::asio::thread_pool 또는 boost::asio::system_context 객체와 같은)I/O execution context를 가지고 있을 것입니다. I/O execution context는 OS의 I/O 서비스에 대한 프로그램의 링크를 나타냅니다.</p>
<blockquote>
<p><strong>Your program</strong> will have at least one <strong>I/O execution context</strong>, such as an boost::asio::io_context object, boost::asio::thread_pool object, or boost::asio::system_context. This <strong>I/O execution context</strong> represents <strong>your program</strong>‘s link to the <strong>operating system</strong>‘s I/O services.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">boost::asio::io_context io_context;</span><br></pre></td></tr></table></figure>


<br>

<div class="figure " style="width:;"><img class="fig-img" src="/assets/images/boost-asio-sync-socket.png" alt=""></div>

<br>

<ol>
<li>I/O object(여기서는 socket)에서 connect 호출<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">boost::asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">socket.<span class="built_in">connect</span>(server_endpoint);</span><br></pre></td></tr></table></figure></li>
<li>I/O object는 I/O execution context에게 요청 전달</li>
<li>I/O execution context는 connect 동작을 수행하기 위해 OS 호출</li>
<li>OS는 I/O execution context에게 수행 결과를 리턴</li>
<li>I/O execution context는 boost::system::error_code에 수행 결과 발생한 에러를 해석하고 이를 I/O object에게 다시 전달</li>
<li>I/O object는 수행에 실패했을 경우 예외를 던짐</li>
</ol>
<br>

<h2 id="비동기-연결"><a href="#비동기-연결" class="headerlink" title="비동기 연결"></a>비동기 연결</h2><div class="figure " style="width:;"><img class="fig-img" src="/assets/images/boost-asio-async-socket.png" alt=""></div>

<br>

<ol>
<li><p>I/O object에서 async_connect 호출(your_completion_handler는 함수 또는 함수 객체임)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">your_completion_handler</span><span class="params">(<span class="keyword">const</span> boost::system::error_code&amp; ec)</span></span>;</span><br><span class="line">socket.<span class="built_in">async_connect</span>(server_endpoint, your_completion_handler);</span><br></pre></td></tr></table></figure></li>
<li><p>I/O object는 I/O execution context에게 요청 전달</p>
</li>
<li><p>I/O execution context는 async_connect 동작을 수행하기 위해 OS 호출(동기 연결과 다르게 async_connect의 수행 결과를 기다리지는 않음)</p>
</li>
</ol>
<div class="figure " style="width:;"><img class="fig-img" src="/assets/images/boost-asio-async-socket-2.png" alt=""></div>

<ol start="4">
<li>OS는 큐에 처리 결과를 추가함으로써 async_connect 수행이 완료됐다는 것을 알림</li>
<li>I/O execution context로 io_context를 사용하는 경우에는 io_context::run()함수를 반드시 호출해야함. io_context::run()함수는 완료되지 않은 비동기 수행이 있는 경우에는 block 상태이므로 대게 최초 비동기 수행을 시작하자마자 해당 함수를 호출함</li>
<li>io_context::run()함수 내에서 I/O execution context는 큐에 추가된 수행 결과들을 뽑아내어 error_code에 해석 결과를 저장하고 handler 함수에게 전달함</li>
</ol>
<p>동기 및 비동기 소켓 연결에 대한 내용을 바탕으로 io_context의 개념을 정리해보면 다음과 같습니다.  </p>
<blockquote>
<p>유저 공간에서 커널에 접근하기 위한 시스템 콜을 날리려고 할때 실제 커널과의 통신을 중계하는 주체이다. 즉, 실제 시스템 콜 함수가 실행되는 공간이라고 생각하면 된다.</p>
</blockquote>
<br> 

<hr>
<h1 id="Execution-Context"><a href="#Execution-Context" class="headerlink" title="Execution Context"></a>Execution Context</h1><p>io_context는 I/O 작업을 위한 매개체이자 일종의 작업 공간이라는건 어느정도 느낌이 온 것같습니다. 이제는 io_context를 포함하는 개념인 execution context에 대해 조금 더 알아보도록 하겠습니다. (해당 내용은 <a href="https://think-async.com/executors/Executors_and_Asynchronous_Operations_Slides.pdf">Executors and Asynchronous Operations</a>를 참조하여 작성하였습니다.)</p>
<p>execution context는 <U>함수 객체가 실행되는 공간</U>입니다.</p>
<blockquote>
<ul>
<li>An execution context is <U>a place where function objects are executed.</U></li>
<li>Examples<ul>
<li>A fixed-size thread pool</li>
<li>A loop scheduler</li>
<li>An asio::io_context</li>
<li>The set of all threads in the process</li>
</ul>
</li>
</ul>
</blockquote>
<p>말그대로 함수 객체(우리가 흔히 핸들러라고 부르는)가 실제로 실행되는 공간이라는 겁니다. 대표적인 execution context인 io_context와 thread pool 사용 예제를 한번 살펴봅시다.</p>
<br>

<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  boost::asio::io_context context;</span><br><span class="line">  boost::asio::post(context, [](){ <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello boost::asio::post in context"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; });</span><br><span class="line">  context.run();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>위 코드는 boost::asio::post 함수를 사용하여 람다 식으로 정의된 함수 객체를 위에서 정의한 io_context에서 실행시키겠다는 내용입니다. (람다 식은 closure라는 이름없는 함수 객체를 생성해줍니다. <a href="https://en.cppreference.com/w/cpp/language/lambda">람다 식의 정의</a>는 여기를 참고하세요.)  </p>
<p>아 그리고 post 함수 아래 io_context의 run 함수는 함수 객체를 실행시킬 공간(여기서는 io_context)을 활성화시켜주는 역할을 한다고 생각하시면 될 것같습니다. (run 함수를 실행하지 않고서는 람다 식이 실행되지 않습니다!)</p>
<br>

<p>아래 코드는 마찬가지로 boost::asio::post 함수를 사용하여 이번에는 직접 정의한 함수 test_function을 io_context가 아닌 thread_pool(또 다른 execution context들 중 하나죠)에서 실행시키겠다는 내용입니다.</p>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello boost::asio::post in thread pool"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  boost::asio::thread_pool tp;</span><br><span class="line">  boost::asio::post(tp, test_function);</span><br><span class="line">  tp.join();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<br>

<hr>
<h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>지금까지 io_context를 시작으로 execution context라는 개념을 조금이나마 구체화하는 시간을 가져봤습니다. 한줄로 정리하며 마치겠습니다.</p>
<blockquote>
<p>Execution Context는 함수 또는 함수 객체가 실행되는 공간이다.</p>
</blockquote>
<br>
<br>

<span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎

<p><strong>Reference</strong></p>
<ul>
<li><a href="https://www.boost.org/doc/libs/1_78_0/doc/html/boost_asio/overview.html">https://www.boost.org/doc/libs/1_78_0/doc/html/boost_asio/overview.html</a></li>
<li><a href="https://www.boost.org/doc/libs/1_78_0/doc/html/boost_asio/overview/rationale.html">https://www.boost.org/doc/libs/1_78_0/doc/html/boost_asio/overview/rationale.html</a></li>
<li><a href="https://www.boost.org/doc/libs/1_78_0/doc/html/boost_asio/overview/core/basics.html">https://www.boost.org/doc/libs/1_78_0/doc/html/boost_asio/overview/core/basics.html</a></li>
<li><a href="https://think-async.com/executors/Executors_and_Asynchronous_Operations_Slides.pdf">https://think-async.com/executors/Executors_and_Asynchronous_Operations_Slides.pdf</a></li>
<li><a href="https://en.cppreference.com/w/cpp/language/lambda">https://en.cppreference.com/w/cpp/language/lambda</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>boost asio</tag>
        <tag>io_context</tag>
        <tag>io_service</tag>
        <tag>execution context</tag>
      </tags>
  </entry>
  <entry>
    <title>boost::asio::post 함수의 인자로 클래스의 인스턴스를 전달할 때 주의 사항</title>
    <url>/2023/01/26/caution-when-passing-instance-to-post/</url>
    <content><![CDATA[<p><escape><span id="more"></span></escape></p>
<p>boost::asio::post 함수의 인자로 클래스의 인스턴스를 전달하는 경우에는 반드시 해당 클래스에 <code>함수 호출 연산자</code>가 <strong>오버로딩</strong> 되어있어야 합니다.</p>
<br>

<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">handler</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    handler(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : a_(a), b_(b) {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 해당 함수 주석 처리하면 compile error!!</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a_ * b_ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a_;</span><br><span class="line">    <span class="keyword">int</span> b_;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">handler <span class="title">h</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    boost::asio::post(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>boost::asio::post</tag>
        <tag>passing instance to post function</tag>
        <tag>function call operator</tag>
        <tag>operator overloading</tag>
      </tags>
  </entry>
  <entry>
    <title>Ethernet 스위칭 과정에 대해 알아보자</title>
    <url>/2021/12/06/ethernet-switching-flow/</url>
    <content><![CDATA[<p>이번 포스팅에서는 L3 스위치에서의 Ethernet 스위칭 과정에 대해 알아보겠습니다.</p>
<span id="more"></span>
<p><a href="https://www.netmanias.com/ko/">넷매니아즈</a>라는 사이트에 총 4편의 시리즈로 연재된 L3 스위치의 패킷 전달에 대한 아주 양질의 게시물을 참고하여 정리해보았습니다. 실제 연재글에서는 상세한 그림과 함께 L3 스위치 내부 구조를 좀 더 세분화하여 설명하고 있으니 관심이 있으신분들은 <a href="https://www.netmanias.com/ko/?m=view&id=blog&no=5526">여기</a>를 참조해주시기 바랍니다.</p>
<br>

<!-- toc -->


<p>서버1과 서버3은 현재 동일한 VLAN(VLAN ID: 10)내에 있으며, 서버1의 ARP 테이블에는 서버3의 엔트리가 이미 존재한다고 가정(존재하지 않는 경우에는 ARP Request/Reply 메시지를 통해 ARP 테이블을 채워주어야함)하겠습니다.<br><br></p>
<h3 id="서버1에서-서버3으로-패킷-전달-Flooding"><a href="#서버1에서-서버3으로-패킷-전달-Flooding" class="headerlink" title="서버1에서 서버3으로 패킷 전달(Flooding)"></a>서버1에서 서버3으로 패킷 전달(Flooding)</h3><div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/ehternet-switching-flooding.png" alt="Flooding"><span class="caption">Flooding</span></div>

<ol>
<li>서버1에서 서버3으로 Ping 패킷을 보내려고합니다.</li>
<li>서버1의 <strong>라우팅 테이블</strong>을 참조(Destination 주소 별 게이트웨이 IP와 출력 포트를 확인할 수 있음)하여 서버3이 서버1과 동일한 네트워크라는 것과 패킷을 내보낼 출력 포트를 확인합니다.</li>
<li>서버1의 <strong>ARP 테이블</strong>을 참조하여 서버3의 IP주소에 대한 MAC 주소를 확인합니다.</li>
<li>출력 포트와 MAC 주소를 확인했으니 서버1은 서버3으로 Ping 패킷을 송신합니다.</li>
<li>Ping 패킷은 출력 포트를 통해 L3 스위치로 이동합니다.</li>
<li>Ping 패킷을 수신한 L3 스위치는 해당 패킷을 버퍼(Ingress Packet Buffer)에 잠시 저장해둡니다.</li>
<li>이제 L3 스위치에서 수신한 Ping 패킷의 <strong>Source MAC 주소를 학습</strong>할 차례입니다. 동일 VLAN을 소유한 Line Card들에만 Source MAC 주소 정보를 공유하여 각각의 <strong>MAC 테이블</strong>에 그 값(VLAN, Source MAC 주소, 포트)을 저장하도록 합니다.</li>
<li>다음으로 해당 패킷을 <strong>IP 라우팅</strong>시킬지 <strong>Ethernet 스위칭</strong>시킬것인지를 결정하는데 이를 위해 Destination MAC 주소를 참조합니다.<div class="alert info"><p>Destination MAC 주소가 L3 스위치의 MAC 주소인 경우에는, <strong>IP 라우팅</strong><br>Destination MAC 주소가 L3 스위치의 MAC 주소가 아닌 경우에는, <strong>Ethernet 스위칭</strong></p>
</div>
<br></li>
<li>이 경우에는 해당 패킷의 Destination MAC 주소가 서버3의 MAC 주소이므로 Ethernet 스위칭을 시킵니다.</li>
<li>Ethernet 스위칭을 위해 L3 스위치에서는 해당 패킷의 Destination MAC 주소가 MAC 테이블에 존재하는지 확인합니다.</li>
<li>만약 등록되어 있지 않다면 동일 VLAN에 속한 포트들 중에서 수신 포트(서버1의 포트)를 제외한 나머지 모든 포트(여기서는 서버2와 서버3의 포트라고 가정)로 수신한 Ping 패킷을 <strong>Flooding</strong>해야함을 알게됩니다.</li>
<li>L3 스위치는 앞서 버퍼에 잠시 저장해둔 패킷(6번 과정을 참고)을 출력을 위한 버퍼(Egress Packet Buffer)로 옮긴 후 11번에서 확인된 포트들로 해당 패킷을 Flooding합니다.</li>
<li>이제 서버2와 서버3이 서버1이 보낸 Ping 패킷을 수신하게 됩니다.</li>
</ol>
<hr>
<h3 id="서버3에서-서버1로-패킷-전달-Unicasting"><a href="#서버3에서-서버1로-패킷-전달-Unicasting" class="headerlink" title="서버3에서 서버1로 패킷 전달(Unicasting)"></a>서버3에서 서버1로 패킷 전달(Unicasting)</h3><div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/ehternet-switching-unicasting.png" alt="Unicasting"><span class="caption">Unicasting</span></div>

<ol>
<li>Ping 패킷의 Destination MAC 주소는 서버3의 MAC 주소이기때문에 서버2에서는 수신한 Ping 패킷을 버립니다.</li>
<li>서버3은 수신한 Ping 패킷에 대한 응답 패킷을 서버1로 송신합니다.(서버1에서와 마찬가지로 서버3은 자신의 라우팅 테이블과 ARP 테이블을 참조하여 출력 포트와 서버1의 MAC주소를 확인함)</li>
<li>응답 패킷은 출력 포트를 통해 L3 스위치로 이동합니다.</li>
<li>응답 패킷을 수신한 L3 스위치는 해당 패킷을 버퍼(Ingress Packet Buffer)에 잠시 저장해둡니다.</li>
<li>이제 L3 스위치에서 수신한 응답 패킷의 <strong>Source MAC 주소를 학습</strong>할 차례입니다. 동일 VLAN을 소유한 Line Card들에만 Source MAC 주소 정보를 공유하여 각각의 <strong>MAC 테이블</strong>에 그 값(VLAN, Source MAC 주소, 포트)을 저장하도록 합니다.</li>
<li>다음으로 해당 패킷을 <strong>IP 라우팅</strong>시킬지 <strong>Ethernet 스위칭</strong>시킬것인지를 결정하는데 이를 위해 Destination MAC 주소를 참조합니다.</li>
<li>이 경우에는 해당 패킷의 Destination MAC 주소가 서버1의 MAC 주소이므로 Ethernet 스위칭을 시킵니다.</li>
<li>Ethernet 스위칭을 위해 L3 스위치에서는 해당 패킷의 Destination MAC 주소가 MAC 테이블에 존재하는지 확인합니다. 이번에는 존재(이전의 Source MAC 주소 학습을 통해 서버1의 MAC 주소가 저장된 상태이므로)합니다.</li>
<li>L3 스위치는 앞서 버퍼에 잠시 저장해둔 패킷(4번 과정을 참고)을 출력을 위한 버퍼(Egress Packet Buffer)로 옮긴 후 8번에서 확인된 MAC주소로 해당 패킷을 송신합니다. 이렇게 MAC 테이블에 매칭되어 하나의 포트로 패킷이 나가는 경우를 Unicasting이라고 합니다.</li>
</ol>
<br>
<br>

<span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎

<p><strong>Reference</strong></p>
<ul>
<li><a href="https://www.netmanias.com/ko/?m=view&amp;id=blog&amp;no=5526">https://www.netmanias.com/ko/?m=view&amp;id=blog&amp;no=5526</a></li>
</ul>
]]></content>
      <categories>
        <category>네트워크</category>
      </categories>
      <tags>
        <tag>ethernet switching</tag>
        <tag>이더넷 스위치</tag>
        <tag>Source MAC Learning</tag>
        <tag>ARP Table</tag>
        <tag>L3 스위치</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Tranquilpeak 테마의 Markdown syntax</title>
    <url>/2021/07/08/hello-hexo/</url>
    <content><![CDATA[<p>Hexo 테마 중 하나인 <a href="https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak/blob/master/DOCUMENTATION.md">Tranquilpeak의 공식 문서</a>를 참조하여 Post시에 활용할 수 있는 다양한 Markdown syntax들을 사용해보았습니다.</p>
<span id="more"></span>

<!-- toc -->

<hr>
<h3 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h3><div class="alert danger"><p>알람 표현은 이렇게😨</p>
</div>

<div class="alert info"><p>알람 표현은 이렇게😮</p>
</div>
<br>

<figure class="highlight md"><figcaption><span>Tags</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;% alert danger %&#125;</span><br><span class="line">알람 표현은 이렇게😨</span><br><span class="line">&#123;% endalert %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% alert info %&#125;</span><br><span class="line">알람 표현은 이렇게😮</span><br><span class="line">&#123;% endalert %&#125;</span><br></pre></td></tr></table></figure>
<br>

<hr>
<h3 id="Highlight-text"><a href="#Highlight-text" class="headerlink" title="Highlight text"></a>Highlight text</h3><span class="highlight-text green">하이라이트 그린</span>은 이렇게😎
<p>Tranquilpeak은 <span class="highlight-text" style="background-color:#CCCCFF;">rgb도 지원</span>해줘서 다양한 색상 표현이 가능합니다.😁<br><br></p>
<figure class="highlight md"><figcaption><span>Highlight text</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;% hl<span class="emphasis">_text green %&#125; 하이라이트 그린&#123;% endhl_</span>text %&#125;은 이렇게😎</span><br><span class="line">Tranquilpeak은 &#123;% hl<span class="emphasis">_text #CCCCFF %&#125; rgb도 지원&#123;% endhl_</span>text %&#125;해줘서 다양한 색상 표현이 가능합니다.😁</span><br></pre></td></tr></table></figure>
<br>

<hr>
<h3 id="Tabbed-code-block"><a href="#Tabbed-code-block" class="headerlink" title="Tabbed code block"></a>Tabbed code block</h3><p>동일한 기능에 대한 다양한 언어의 소스코드를 탭으로 구분하여 표현할 수 도 있습니다.</p>
<figure class="codeblock codeblock--tabbed"><figcaption><span>Tabbed code block</span><ul class="tabs"><li class="tab active">cpp</li><li class="tab">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello hex!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight go" style="display: none;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"hello hexo!"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>
<br>

<figure class="highlight md"><figcaption><span>Tabbed code block</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;% tabbed<span class="emphasis">_codeblock Tabbed code block %&#125;</span></span><br><span class="line"><span class="emphasis">    &lt;!-- tab cpp --&gt;</span></span><br><span class="line"><span class="emphasis">    #include <span class="xml"><span class="tag">&lt;<span class="name">iostream</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">    int main()</span></span><br><span class="line"><span class="emphasis">    &#123;</span></span><br><span class="line"><span class="emphasis">        std::cout &lt;&lt; &quot;hello hex!&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="emphasis">        return 0;</span></span><br><span class="line"><span class="emphasis">    &#125;</span></span><br><span class="line"><span class="emphasis">    &lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="emphasis">    &lt;!-- tab go --&gt;</span></span><br><span class="line"><span class="emphasis">    package main</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">    import &quot;fmt&quot;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">    func main() &#123;</span></span><br><span class="line"><span class="emphasis">        fmt.Println(&quot;hello hexo!&quot;)</span></span><br><span class="line"><span class="emphasis">    &#125;</span></span><br><span class="line"><span class="emphasis">    &lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="emphasis">&#123;% endtabbed_</span>codeblock %&#125;</span><br></pre></td></tr></table></figure>
<br>

<hr>
<h3 id="Quote"><a href="#Quote" class="headerlink" title="Quote"></a>Quote</h3><p>링크가 포함된 인용구는 아래와 같이 표현됩니다.</p>
<blockquote><p>나의 Github Repository</p>
<footer><strong>chelseafandev</strong><cite><a href="https://github.com/chelseafandev">Github Repo</a></cite></footer></blockquote>

<p>링크가 없는 인용구는 아래와 같이 표현됩니다.</p>
<blockquote><p>누구나 그럴싸한 계획을 가지고 있다. 한 대 처맞기 전까지는</p>
<footer><strong>Michael Gerard Tyson</strong><cite>he's quotation</cite></footer></blockquote>
<br>

<figure class="highlight md"><figcaption><span>Quote</span></figcaption><table><tr><td class="code"><pre><span class="line">링크가 포함된 인용구는 아래와 같이 표현됩니다.</span><br><span class="line">&#123;% blockquote chelseafandev https://github.com/chelseafandev Github Repo %&#125;</span><br><span class="line">나의 Github Repository</span><br><span class="line">&#123;% endblockquote %&#125;</span><br><span class="line"></span><br><span class="line">링크가 없는 인용구는 아래와 같이 표현됩니다.</span><br><span class="line">&#123;% blockquote Michael Gerard Tyson, he&#x27;s quotation %&#125;</span><br><span class="line">누구나 그럴싸한 계획을 가지고 있다. 한 대 처맞기 전까지는</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure>
<br>

<hr>
<h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h3><p>첨부할 이미지 파일을 themes/tranquilpeak/source/_images 하위에 저장하면 배포 시 public/assets/images 폴더로 이동합니다.</p>
<div class="figure " style="width:;"><img class="fig-img" src="/assets/images/chelsea_cover.jpg" alt="Blue is the Colour"><span class="caption">Blue is the Colour</span></div>
<br>

<figure class="highlight md"><figcaption><span>Image</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;% image /assets/images/chelsea<span class="emphasis">_cover.jpg &quot;Blue is the Colour&quot; %&#125;</span></span><br></pre></td></tr></table></figure>
<br>

<hr>
<h3 id="Wide-Image"><a href="#Wide-Image" class="headerlink" title="Wide Image"></a>Wide Image</h3><p>넓은 이미지도 아래와 같이 표현됩니다.<br><a href="https://www.instagram.com/chelseafc/?hl=ko">첼시 공식 인스타 계정</a>에 올라온 2020 유로 기념 사진을 이어 붙여보았습니다. 조르지뉴 화이팅😁</p>
<!-- endcontent --><div class="figure figure--fullWidth"><img class="figure-img" src="/assets/images/chelsea_instagram.png" alt="UEFA Euro 2020 with chelsea players"><span class="caption">UEFA Euro 2020 with chelsea players</span></div><!-- content -->
<br>

<figure class="highlight md"><figcaption><span>Wide Image</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;% wide<span class="emphasis">_image /assets/images/chelsea_</span>instagram.png &quot;UEFA Euro 2020 with chelsea players&quot; %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>유용한 팁</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>tranquilpeak</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Seg Fault는 왜 발생하는가?</title>
    <url>/2021/11/09/gdb-chapter4-program-crash/</url>
    <content><![CDATA[<p>이번 포스팅에서는 <a href="https://nostarch.com/debugging.htm">The Art of Debugging with GDB, DDD and Eclipse</a>의 <strong>Chatper 4 WHEN A PROGRAM CRASHES</strong> 내용을 번역해보았습니다. 해당 챕터의 앞부분에서는 가상 주소 공간에서의 페이지(page)에 대한 개념을 소개하고 seg fault가 발생하는 원인을 페이지(page)와 연관지어 잘 설명해주고 있습니다.</p>
<span id="more"></span>

<br>

<!-- toc -->

<br>

<h2 id="Background-Material-Memory-Management"><a href="#Background-Material-Memory-Management" class="headerlink" title="Background Material: Memory Management"></a>Background Material: Memory Management</h2><h3 id="Why-does-a-program-crash"><a href="#Why-does-a-program-crash" class="headerlink" title="Why does a program crash?"></a>Why does a program crash?</h3><p>단연코 충돌이 발생하는 가장 일반적인 원인은 프로그램이 접근 권한이 없는 메모리 공간에 접근하려고 시도하기 때문입니다.</p>
<blockquote>
<p>By far the most common cause of a crash is for a program to attempt to access a memory location without having the permission to do so.</p>
</blockquote>
<br>

<p>Unix 계열의 플랫폼에서는 일반적으로 프로그램이 segmentation fault(seg fault로 알려져있는)를 발생시켰다는 것을 알려주고 해당 프로그램의 실행을 중단할 것입니다.</p>
<blockquote>
<p>On Unix-family platforms, the OS will normally announce that the program has caused a segmentation fault, commonly referred to as a seg fault, and discontinue execution of the program.</p>
</blockquote>
<br>

<p>seg fault를 처리하기 위한 용도로 GDB를 효율적으로 사용하기 위해서는, 메모리 접근 에러가 어떻게 발생하는지에 대해 정확히 이해하는 것이 중요합니다.</p>
<blockquote>
<p>In order to effectively use GDB to deal with seg faults, it is important to understand exactly how memory access errors occur.</p>
</blockquote>
<br>

<h3 id="Program-layout-in-memory"><a href="#Program-layout-in-memory" class="headerlink" title="Program layout in memory"></a>Program layout in memory</h3><p>Unix 플랫폼에서 프로그램에 할당된 가상 주소들의 집합은 Figure 4-1 그림과 같은 형태로 배치되어있습니다.</p>
<blockquote>
<p>On Unix platforms, a program’s set of allocated virtual addresses typically is laid out something like the diagram in Figure 4-1.</p>
</blockquote>
<div class="figure " style="width:;"><img class="fig-img" src="/assets/images/figure-4-1-program-memory-layout.png" alt=""></div>

<br>

<p><strong>text section</strong>은 컴파일러가 당신의 프로그램 소스 코드를 통해 생성해낸 기계 지시어들로 구성되어있습니다.</p>
<blockquote>
<p>The <strong>text section</strong> consists of the machine instructions produced by the compiler from your program’s source code.</p>
</blockquote>
<br>

<p><strong>data section</strong>은 컴파일 타임에 할당되는 모든 프로그램 변수들을 포함합니다. (초기화된 변수는 data영역에 초기화되지않은 변수는 bss영역에 저장됨)</p>
<blockquote>
<p>The <strong>data section</strong> contains all the program variables that are allocated at compile time. </p>
</blockquote>
<br>

<p>당신의 프로그램이 런타임에 OS로부터 추가적인 메모리를 요청하는 경우에 해당 메모리는 <strong>heap</strong>이라는 공간에 할당됩니다.</p>
<blockquote>
<p>When your program requests additional memory from the operating system at run time the requested memory is allocated in an area called the <strong>heap</strong>.</p>
</blockquote>
<br>

<p><strong>stack section</strong>은 동적으로 할당된 데이터를 위한 공간입니다. 함수 호출 시 사용되는 인자들이나 지역 변수들 그리고 반환 주소값들이 stack 공간에 저장됩니다. stack의 크기는 함수 호출이 발생할 때 증가하고 호출자에게 함수가 다시 반환될때 감소합니다.</p>
<blockquote>
<p>The <strong>stack section</strong> is space for dynamically allocated data. The data for function calls — including arguments, local variables, and return addresses — are stored on the stack. The stack grows each time a function call is made and shrinks each time a function returns to its caller.</p>
</blockquote>
<br>

<h3 id="The-notion-of-pages"><a href="#The-notion-of-pages" class="headerlink" title="The notion of pages"></a>The notion of pages</h3><p>가상 주소 공간은 <strong>페이지</strong>라고 불리는 덩어리(chunk)들의 구성으로 표현됩니다. RAM이나 ROM과 같은 물리적 메모리 또한 페이지들로 나누어진 무언가로 표현됩니다.</p>
<blockquote>
<p>A virtual address space is viewed as organized into chunks called <strong>pages</strong>. Physical memory (both RAM and ROM) is also viewed as divided into pages.</p>
</blockquote>
<br>

<p>실행에 의해 프로그램이 메모리에 로드될 때, OS는 프로그램의 몇몇 페이지들을 물리적 메모리의 페이지에 저장되도록 배열시킵니다. 이러한 페이지들을 <strong>resident</strong>라고 부르며 resident를 제외한 나머지 페이지들은 디스크에 저장됩니다.</p>
<blockquote>
<p>When a program is loaded into memory for execution, the OS arranges for some of the pages of the program to be stored in pages of physical memory. These pages are said to be <strong>resident</strong>, and the rest are stored on disk.</p>
</blockquote>
<br>

<p>지금 현재는 resident(물리적 메모리의 페이지에 저장된 프로그램의 페이지)가 아닌 몇몇 프로그램 페이지들이 프로그램이 실행 중인 동안의 다양한 시점에 필요할 수 있습니다. 이러한 시점에 그것은 하드웨어에 의해 감지되고 이를 통해 당신의 프로그램은 제어권을 OS로 넘겨주게 됩니다. OS는 필요한 프로그램의 페이지를 메모리로 로딩하고나서 제어권 다시 프로그램에게 넘겨줍니다. 이 과정에서 더이상 resident가 아닌 프로그램 페이지(= nonresident)는 디스크에 저장될 것입니다.</p>
<blockquote>
<p>At various times during execution, some program page that is not currently resident will be needed. When this occurs, it will be sensed by the hardware, which transfers control to the OS. The latter brings the required page into memory and then returns control to our program. The evicted program page, if any, becomes nonresident and will be stored on disk.</p>
</blockquote>
<br>

<p>위의 모든 과정을 관리하기 위해서 OS는 각각의 프로세스마다 <strong>페이지 테이블</strong>이라는 것을 유지하게 됩니다. 프로세스의 가상 페이지들 각각은 테이블 내에 entry를 가지고 있으며 이 entry에는 아래 정보들을 포함하고 있습니다.</p>
<blockquote>
<p>To manage all of this, the OS maintains a <strong>page table</strong> for each process. Each of the process’s virtual pages has an entry in the table, which includes the following information:</p>
</blockquote>
<br>

<ul>
<li>페이지의 메모리 혹은 디스크 상의 현재 물리적 위치 정보</li>
<li>페이지의 read, write, execute 권한 정보</li>
</ul>
<blockquote>
<ul>
<li>The current physical location of this page in memory or on disk.</li>
<li>Permissions — read, write, execute — for this page.</li>
</ul>
</blockquote>
<br>

<p>OS가 부분적인 페이지들을 프로그램에 할당하는 것이 아니라는 것에 주목합시다. 예를 들어, 실행 중인 프로그램이 약 10,000 bytes의 사이즈를 갖는다고 한다면, 이 프로그램이 온전히 로드됐을 경우 메모리의 3개 페이지를 차지(페이지 기본 사이즈가 4,096 bytes인 경우)할 것입니다. 페이지는 VM 시스템에 의해 조작되는 메모리의 가장 작은 단위이기 때문에 약 2.5 페이지를 차지한다거나 하지는 않을것입니다. 바로 이 지점이 디버깅 시에 매우 중요한 포인트입니다. 왜냐하면 이것은 프로그램에 의해 발생하는 몇몇 잘못된 메모리 접근들이 seg fault를 발생시키지 않을 수 있음을 의미하기 때문입니다. </p>
<blockquote>
<p>Note that the OS will not allocate partial pages to a program. For example, if the program to be run has a total size of about 10,000 bytes, it would occupy three pages of memory if fully loaded. It would not merely occupy about 2.5 pages, as pages are the smallest unit of memory manipulated by the VM system. This is an important point to understand when debugging, because it implies that some erroneous memory accesses by the program will not trigger seg faults, as you will see below.</p>
</blockquote>
<br>

<p>다시 말해, 디버깅 세션에 있는 동안에 당신은 “소스 코드의 이 라인은 seg fault를 발생시키지 않았기 때문에 틀림없이 괜찮을 것이다”와 같이 이야기 할 수 없다는 것입니다.</p>
<blockquote>
<p>In other words, during your debugging session, you cannot say something like, “This line of source code must be okay, since it didn’t cause a seg fault.”</p>
</blockquote>
<br>

<h3 id="Details-on-the-role-of-the-page-table"><a href="#Details-on-the-role-of-the-page-table" class="headerlink" title="Details on the role of the page table"></a>Details on the role of the page table</h3><div class="alert info"><p>아래 설명에 나오는 페이지의 크기는 4,096 bytes 라고 가정하자</p>
<p>virtual page 0 : 0 ~ 4,095 bytes<br>virtual page 1 : 4,096 ~ 8,191 bytes<br>…</p>
<p>Keep the virtual address space in Table 4-1 in mind, and continue to assume that the page size is 4,096 bytes. Then virtual page 0 comprises bytes 0 though 4,095 of the virtual address space, page 1 comprises bytes 4,096 through 8,191, and so on.</p>
</div>

<br>

<p>위에서 언급했듯이, 우리가 프로그램을 실행시킬때, OS는 프로그램 코드를 실행시키는 프로세스의 가상 메모리를 관리하기 위해 사용하는 페이지 테이블을 생성합니다. 프로세스가 실행 중이라면 언제든지, 하드웨어의 page table register는 페이지 테이블을 가리키고 있을겁니다.</p>
<blockquote>
<p>As mentioned, when we run a program, the OS creates a page table that it uses to manage the virtual memory of the process that executes the program code. Whenever that process runs, the hardware’s page table register will point to that table.</p>
</blockquote>
<br>

<p>개념적으로 이야기하자면, 프로세스 가상 주소 공간의 각각의 페이지는 페이지 테이블 안의 entry를 갖고 있습니다. 이 페이지 테이블 entry는 페이지와 관련된 다양한 정보들을 저장하고 있습니다. 이러한 정보들 중에서 seg faults와 관련된 데이터는 페이지에 대한 접근 권한입니다. 이는 read, write, execute와 같은 파일 접근 권한과 유사합니다. 예를 들어 페이지 3번에 대한 페이지 테이블 entry는 여러분의 프로세스가 그 페이지로부터 데이터를 읽을 권한이 있는지, 그 페이지에 데이터를 쓸 권한이 있는지, 그 페이지에 지시어를 실행할 권한이 있는지 가리킬 것입니다.</p>
<blockquote>
<p>Conceptually speaking, each page of the virtual address space of the process has an entry in the page table. This page table entry stores various pieces of information related to the page. The data of interest in relation to seg faults are the access permissions for the page, which are similar to file access permissions: read, write, and execute. For example, the page table entry for page 3 will indicate whether your process has the right to read data from that page, the right to write data to it, and the right to execute instructions on it.</p>
</blockquote>
<br>

<p>프로그램의 실행 과정에서, 프로그램의 실행에 의해 생성되는 주소들은 가상의 값일 것입니다. 프로그램이 y라고하는 특정한 가상 주소를 갖는 메모리에 접근하려고 할때, 하드웨어는 이 가상 주소 y를 가상 페이지 번호 v로 변환할 것입니다. 여기서 가상 페이지 번호인 v는 가상 주소 y를 4,096으로 나눈 것과 같습니다. 그리고나서 하드웨어는 페이지 테이블내에서 entry값인 v가 수행하고자 하는 연산과 일치하는 권한을 가지고있는지 여부를 확인할 것입니다. 만약 일치한다면, 하드웨어는 이 테이블 entry로부터 실제 물리적 메모리 공간의 페이지 번호를 얻어낼 것이며 요청된 메모리 연산을 수행할 것입니다. 하지만 만약 테이블 entry가 요청한 연산에 대한 적절한 권한이 없을때에는 내부적인 인터럽트를 실행할 것입니다. 이 인터럽트는 OS의 에러 핸들링 루틴으로 jump하도록 해줍니다. OS는 일반적으로 메모리 접근 위반을 알려주고 프로그램의 실행을 중단시킵니다.</p>
<blockquote>
<p>During the execution of the program, the addresses it generates will be virtual. When the program attempts to access memory at a certain virtual address, say y, the hardware will convert that to a virtual page number v, which equals y divided by 4,096. The hardware will then check entry v in the page table to see whether the permissions for the page match the operation to be performed. If they do match, the hardware will get the desired location’s actual physical page number from this table entry and then carry out the requested memory operation. But if the table entry shows that the requested operation does not have the proper permission, the hardware will execute an internal interrupt. This will cause a jump to the OS’s error-handling routine. The OS will normally then announce a memory access violation and discontinue execution of the program.</p>
</blockquote>
<br>

<h3 id="A-slight-memory-access-bug-might-not-cause-a-seg-fault"><a href="#A-slight-memory-access-bug-might-not-cause-a-seg-fault" class="headerlink" title="A slight memory-access bug might not cause a seg fault"></a>A slight memory-access bug might not cause a seg fault</h3><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> q[<span class="number">200</span>];</span><br><span class="line">main()</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) {</span><br><span class="line">    q[i] = i;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<br>

<p>거의 대부분의 경우 실행 시간에 seg fault가 발생할 것입니다. 하지만 에러가 발생하는 시점이 당신을 놀라게 할 것입니다. 에러는 자연스러운 시점에 발생하지 않을 가능성이 있는데, 다시 말해, i가 200인 경우가 아닌 그 이후 시점에 발생할 수 있다는 것입니다.</p>
<blockquote>
<p>At execution time, a seg fault is quite likely to occur. However, the timing of the error may surprise you. The error is not likely to appear at the “natural” time, that is, when i = 200; rather, it is likely to happen much later than that. </p>
</blockquote>
<br>

<p>이 현상을 재현하기 위해 우리는 이 프로그램을 변수의 주소를 검색하기에 편리한 GDB를 통해 실행시켰습니다. 이를 통해 seg fault는 i가 200이 아닌 728(테스트 환경에 따라 i의 값은 달라질 수 있음)에서 발생했다는 것을 확인할 수 있었습니다. 왜 이러한 현상이 발생하는지 살펴봅시다.</p>
<blockquote>
<p>To illustrate this, we ran this program on a Linux PC under GDB, in order to conveniently query addresses of variables. It turned out that the seg fault occurred not at i = 200, but at i = 728. Let’s see why.</p>
</blockquote>
<br>

<p>GDB에 질의 결과, 우리는 배열 q(q[])의 주소값이 0x80497bf로 끝난다는 것을 확인했습니다. 즉, q[199]의 마지막 byte가 해당 메모리 주소에 존재한다는 것입니다. 페이지 크기는 4,096 byte에 32-bit의 word 크기를 갖는 장치라고 고려해본다면, 가상 주소 공간은 20-bit의 페이지 번호와 12-bit의 오프셋으로 나누어집니다. 우리 프로그램의 경우, 배열 q[]는 가상 페이지 번호 0x8049 = 32841, 오프셋 값 0x7bf = 1983이 됩니다. 그래서 q가 할당된 메모리의 페이지 위에 여전히 2,112 byte의 공간이 남아있게 됩니다. 이 공간은 integer 변수 528개를 저장할 수 있으며, 우리 프로그램은 그것을 마치 q의 요소들이 포함된 공간으로 처리하게 됩니다(q[200] ~ q[727]).</p>
<blockquote>
<p>From queries to GDB we found that the array q[] ended at address 0x80497bf; that is, the last byte of q[199] was at that memory location. Taking into account the Intel page size of 4,096 bytes and the 32-bit word size of this machine, a virtual address breaks down into a 20-bit page number and a 12-bit offset. In our case, q[] ended in virtual page number 0x8049 = 32841, offset 0x7bf = 1983. So there were still 4,096 − 1,984 = 2,112 bytes on the page of memory on which q was allocated. That space can hold 2112 / 4 = 528 integer variables (since each is 4 bytes wide on the machine used here), and our code treated it as if it contained elements of q at “positions” 200 through 727.</p>
</blockquote>
<br>

<p>물론 q[] 배열의 이러한 요소(q[200] ~ q[727])들은 실제로 존재하지 않지만, 컴파일러는 불만을 제기하지 않습니다. 여전히 해당 페이지는 쓰기 권한을 가지고 있기 떄문에 하드웨어 또한 불만을 제기하지 않습니다. 오로지 i가 728이 되는 시점에 q[i]는 다른 페이지를 가리키게 됩니다. 바로 이 경우에, 해당 페이지에는 쓰기 권한이 없게되고 가상 메모리 하드웨어는 이를 감지하여 seg fault를 발생시킵니다.</p>
<blockquote>
<p>Those elements of q[] don’t exist, of course, but the compiler did not complain. Neither did the hardware, since the writes were still being performed to a page for which we certainly had write permission. Only when i became 728 did q[i] refer to an address on a different page. In this case, it was a page for which we didn’t have write (or any other) permission; the virtual memory hardware detected this and triggered a seg fault.</p>
</blockquote>
<br>

<span class="highlight-text green">교훈: 이전에 언급했듯이, seg fault가 발생하지 않았다는 것이 메모리 연산에 오류가 없다는 것은 아닙니다.</span>
<blockquote>
<p>The moral: As stated earlier, we can’t conclude from the absence of a seg fault that a memory operation is correct.</p>
</blockquote>
<br>
<br>
<span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎

<p><strong>Reference</strong></p>
<ul>
<li>Norman Matloff, Peter Jay Salzman. (2008). The Art of Debugging with GDB, DDD, and Eclipse. No Starch Press</li>
<li><a href="https://nostarch.com/debugging.htm">https://nostarch.com/debugging.htm</a></li>
</ul>
]]></content>
      <categories>
        <category>기술문서 번역</category>
      </categories>
      <tags>
        <tag>gdb</tag>
        <tag>coredump</tag>
        <tag>gdb debugging</tag>
        <tag>page</tag>
        <tag>page table</tag>
        <tag>seg fault</tag>
        <tag>segmentation fault</tag>
      </tags>
  </entry>
  <entry>
    <title>SELECT 쿼리 결과 동적으로 받아오는 방법</title>
    <url>/2023/01/26/how-to-get-query-result-dynamically/</url>
    <content><![CDATA[<p><escape><span id="more"></span></escape></p>
<p><code>SelectQueryResultType</code>은 쿼리 조회 결과로 나온 칼럼 이름을 key값으로 하고 해당 칼럼의 타입에 관계 없이 그 값을 저장하기 위한 빈 인터페이스 타입의 value를 갖는 map 슬라이스이고 조회된 row 개수 만큼 해당 슬라이스에 append 작업을 수행합니다.</p>
<p><code>pointers</code>라는 빈(empty) 인터페이스 슬라이스를 추가한 이유는 pq 라이브러리의 Scan() 함수는 조회된 칼럼 값을 저장하기 위한 <strong>변수의 주소 값</strong>을 인자로 받기 때문에 <code>values</code> 라는 빈(empty) 인터페이스 슬라이스(조회된 칼럼 값을 저장할 공간)의 요소 별 주소 값을 저장하기 위한 슬라이스를 추가적으로 생성합니다. <img src="/assets/images/how-to-get-query-result-dynamically-figure1.jpeg" class="" width="200" height="200"></p>
<br>

<figure class="highlight go"><figcaption><span>postgres.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> postgres</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;database/sql&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line">	_ <span class="string">&quot;github.com/lib/pq&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SelectQueryResultType []<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">SelectQuery</span><span class="params">(query <span class="keyword">string</span>)</span> <span class="params">(SelectQueryResultType, error)</span></span> &#123;</span><br><span class="line">	rows, err := db.db.Query(query)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cols, err := rows.Columns()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;db columns fail: %s\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> result SelectQueryResultType</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">		values := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(cols))</span><br><span class="line">		pointers := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(cols))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> values &#123;</span><br><span class="line">			pointers[i] = &amp;values[i]</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err = rows.Scan(pointers...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;db scan fail: %s\n&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		row := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">		<span class="keyword">for</span> i, val := <span class="keyword">range</span> values &#123;</span><br><span class="line">			row[strings.ToLower(cols[i])] = val</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		result = <span class="built_in">append</span>(result, row)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>Reference</strong></p>
<ul>
<li><a href="https://stackoverflow.com/questions/53435455/handling-dynamic-queries-cant-scan-into-struct">https://stackoverflow.com/questions/53435455/handling-dynamic-queries-cant-scan-into-struct</a></li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>lib/pq</tag>
        <tag>Scan()</tag>
        <tag>Golang query</tag>
      </tags>
  </entry>
  <entry>
    <title>인텔 Hyperscan 레퍼런스 가이드 번역</title>
    <url>/2021/09/24/hyperscan-phase1/</url>
    <content><![CDATA[<p>이번 포스팅에서는 인텔 Hyperscan의 <a href="http://intel.github.io/hyperscan/dev-reference/index.html">공식 문서</a>를 통해 컴파일(compile)이나 스캔(scan)과 같은 Hyperscan의 기본적인 개념들에 대해 알아보도록 하겠습니다. 추후에는 Hyperscan API를 직접 사용하여 정규 표현식 패턴 매칭을 수행하는 샘플 코드도 업로드할 예정입니다.</p>
<span id="more"></span>

<br>

<!-- toc -->

<br>

<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Hyperscan은 높은 성능과 유연성을 고려하여 디자인된 정규 표현식 매칭 엔진 소프트웨어 입니다. 이것은 직관적인 C API 형태의 라이브러리로 구현되었습니다.</p>
<blockquote>
<p>Hyperscan is a software regular expression matching engine designed with high performance and flexibility in mind. It is implemented as a library that exposes a straightforward C API.</p>
</blockquote>
<br>

<p>Hyperscan API는 2가지 요소(<strong>compilation</strong>과 <strong>scanning</strong>)로 구성되어 있습니다.</p>
<blockquote>
<p>The Hyperscan API itself is composed of two major components:</p>
</blockquote>
<br>

<h3 id="Compilation"><a href="#Compilation" class="headerlink" title="Compilation"></a>Compilation</h3><p>이 함수들은 식별자나 옵션 플래그값에 따른 정규 표현식 그룹을 전달받아 Hyperscan의 scanning API에서 사용하는 변경이 불가한 데이터베이스 형태로 변환(compile)합니다. 이 변환 과정에서 주어진 표현식들을 효율적으로 매칭하기위한 데이터베이스를 생성하기 위해 많은 양의 분석 및 최적화 작업을 수행합니다.</p>
<blockquote>
<p>These functions take a group of regular expressions, along with identifiers and option flags, and compile them into an immutable database that can be used by the Hyperscan scanning API. This compilation process performs considerable analysis and optimization work in order to build a database that will match the given expressions efficiently.</p>
</blockquote>
<br>

<p>만약 (Hyperscan에서 지원하지 않는 정규표현식을 사용하거나 리소스 임계치 초과와 같은)어떠한 이유에서든 특정 패턴이 데이터베이스화되지 않는다면 패턴 컴파일러에 의해 에러가 반환될 것입니다.</p>
<blockquote>
<p>If a pattern cannot be built into a database for any reason (such as the use of an unsupported expression construct, or the overflowing of a resource limit), an error will be returned by the pattern compiler.</p>
</blockquote>
<br>

<p>변환된 데이터베이스는 직렬화되거나 재배치될 수 있으며 이를 통해 디스크에 저장되거나 호스트 간 이동이 가능합니다. 또한 이 데이터베이스는 특정한 플랫폼 특성의 대상이 될 수 있습니다. (예를 들어, Intel® AVX2 지시어의 사용)</p>
<blockquote>
<p>Compiled databases can be serialized and relocated, so that they can be stored to disk or moved between hosts. They can also be targeted to particular platform features (for example, the use of Intel® Advanced Vector Extensions 2 (Intel® AVX2) instructions).</p>
</blockquote>
<br>

<h3 id="Scanning"><a href="#Scanning" class="headerlink" title="Scanning"></a>Scanning</h3><p>일단 Hyperscan 데이터베이스가 생성이 된다면, 이 데이터베이스는 메모리 상에 있는 데이터를 스캔하기 위해 사용될 수 있습니다. Hyperscan은 몇가지 스캐닝 모드를 제공하는데, 이 모드는 스캔한 데이터가 단일 인접 블록(single contiguous block)으로 사용이 가능한지, 메모리에 있는 몇몇 블록에 동시에 분배가 가능한지 또는 스트림 안에서 일련의 블록(sequence of blocks)으로 스캔되는지에 따라 결정됩니다.</p>
<blockquote>
<p>Once a Hyperscan database has been created, it can be used to scan data in memory. Hyperscan provides several scanning modes, depending on whether the data to be scanned is available as a single contiguous block, whether it is distributed amongst several blocks in memory at the same time, or whether it is to be scanned as a sequence of blocks in a stream.</p>
</blockquote>
<br>

<p>매칭된 정보는 각각의 매칭 과정에서 동기적으로 호출되는 사용자 정의 콜백 함수를 통해 어플리케이션으로 전달됩니다.</p>
<blockquote>
<p>Matches are delivered to the application via a user-supplied callback function that is called synchronously for each match.</p>
</blockquote>
<br>

<p>주어진 데이터베이스에 대해, Hyperscan은 몇가지 보장들을 제공합니다.</p>
<blockquote>
<p>For a given database, Hyperscan provides several guarantees:</p>
</blockquote>
<br>

<ul>
<li>2가지 고정 사이즈 할당을 제외하면 런타임시에 메모리 할당은 발생하지 않으며, 2가지 고정 사이즈 할당 과정은 반드시 performance-critical 어플리케이션 전에 끝나야합니다.<ul>
<li>스크래치 공간: 스캔 시점에 내부 데이터에 사용되는 임시 메모리 공간입니다. 단일 스캔 호출이 끝난 이후에 scratch 공간 내의 구조들은 유지되지 않습니다.</li>
<li>스트림 공간: 스트리밍 모드인 경우에만 해당하며, 각각의 스트림에 대한 스캔 호출 사이에서 유지되는 데이터를 저장하기 위해 몇몇 상태 공간이 요구됩니다. 이를 통해 Hyperscan은 복수의 데이터 블록에 걸쳐 매칭되는 정보를 트랙킹할 수 있습니다.</li>
</ul>
</li>
<li>주어진 데이터베이스에서 요구하는 scratch 공간 및 stream 상태(스트리밍 모드에서) 공간의 크기는 고정되어있으며 데이터베이스 컴파일 타임에 결정됩니다. 이는 어플리케이션의 메모리 요구사항을 사전에 알 수 있다는 의미이며, 성능상의 이유로 필요한 경우라면, 이러한 구조들은 미리 할당될 수 있습니다.</li>
<li>Hyperscan 컴파일러에 의해 정상적으로 컴파일된 패턴이라면 어떠한 입력 값이 들어오더라도 스캔이 가능합니다. 런타임 시 스캔 호출이 에러를 반환하도록 하는 내부적인 리소스 제한이나 다른 제약사항들은 없습니다.</li>
</ul>
<blockquote>
<ul>
<li>No memory allocations occur at runtime with the exception of two fixed-size allocations, both of which should be done ahead of time for performance-critical applications:<ul>
<li>Scratch space: temporary memory used for internal data at scan time. Structures in scratch space do not persist beyond the end of a single scan call.</li>
<li>Stream state: in streaming mode only, some state space is required to store data that persists between scan calls for each stream. This allows Hyperscan to track matches that span multiple blocks of data.</li>
</ul>
</li>
<li>The sizes of the scratch space and stream state (in streaming mode) required for a given database are fixed and determined at database compile time. This means that the memory requirements of the application are known ahead of time, and these structures can be pre-allocated if required for performance reasons.</li>
<li>Any pattern that has successfully been compiled by the Hyperscan compiler can be scanned against any input. There are no internal resource limits or other limitations at runtime that could cause a scan call to return an error.</li>
</ul>
</blockquote>
<br>
<br>

<hr>
<h2 id="Compiling-Patterns"><a href="#Compiling-Patterns" class="headerlink" title="Compiling Patterns"></a>Compiling Patterns</h2><h3 id="Building-a-Database"><a href="#Building-a-Database" class="headerlink" title="Building a Database"></a>Building a Database</h3><p>Hyperscan 컴파일러 API는 정규표현식을 입력받아 그것들을 스캔 작업시에 사용되는 컴파일된 패턴 데이터베이스 형태로 변환합니다.</p>
<blockquote>
<p>The Hyperscan compiler API accepts regular expressions and converts them into a compiled pattern database that can then be used to scan data.</p>
</blockquote>
<br>

<p>API에서는 정규표현식을 데이터베이스화하기 위한 3가지 형태의 함수를 제공하고 있습니다.</p>
<blockquote>
<p>The API provides three functions that compile regular expressions into databases:</p>
</blockquote>
<br>

<ol>
<li>hs_compile(): 단일 정규표현식을 패턴 데이터베이스로 컴파일합니다.</li>
<li>hs_compile_multi(): 정규표현식의 배열(정규표현식의 집합)을 패턴 데이터베이스로 컴파일합니다. 지원하는 모든 패턴들이 매칭에 성공하는 경우에 반환되는 사용자 정의 구분자(id)를 가지고 동시에 스캔될 것입니다. </li>
<li>hs_compile_ext_multi(): 위 함수와 마찬가지로 정규표현식의 배열(정규표현식의 집합)을 패턴 데이터베이스로 컴파일하며, 각각의 표현식에 대해 확장된 파라미터가 명시되도록 허용합니다.</li>
</ol>
<blockquote>
<ol>
<li>hs_compile(): compiles a single expression into a pattern database.</li>
<li>hs_compile_multi(): compiles an array of expressions into a pattern database. All of the supplied patterns will be scanned for concurrently at scan time, with user-supplied identifiers returned when they match.</li>
<li>hs_compile_ext_multi(): compiles an array of expressions as above, but allows Extended Parameters to be specified for each expression.</li>
</ol>
</blockquote>
<br>

<p>컴파일 작업은 Hyperscan 라이브러리가 주어진 패턴들을 분석할 수 있도록 해주고, 런타임 시에 계산했다면 비용이 굉장히 클 수 있는 이러한 패턴들을 어떻게하면 최적화된 방식으로 스캔할 수 있을지를 미리 결정하도록 해줍니다.</p>
<blockquote>
<p>Compilation allows the Hyperscan library to analyze the given pattern(s) and pre-determine how to scan for these patterns in an optimized fashion that would be far too expensive to compute at run-time.</p>
</blockquote>
<br>

<p>표현식들을 컴파일하고자 할때는, 컴파일된 패턴들의 결과가 스트리밍 모드에 사용될것인지 블록 또는 벡터 모드에서 사용될 것인지 여부를 결정해야합니다.</p>
<blockquote>
<p>When compiling expressions, a decision needs to be made whether the resulting compiled patterns are to be used in a streaming, block or vectored mode:</p>
</blockquote>
<br>

<ul>
<li>스트리밍 모드: 스캔하려는 대상이 연속적인 스트림이며 이를 한번에 스캔할 수는 없습니다; 데이터의 블록이 순차적으로 스캔되며 스트림 내 여러 블록들에서 매칭이 발생할 수 있습니다. 스트리밍 모드에서 각각의 스트림은 스캔 호출 간의 스트림 상태를 저장하기 위한 메모리 블록을 필요로 합니다.</li>
<li>블록 모드: 스캔 대상이 개별적이고 인접한 블록이며 이 블록은 한번의 호출로 스캔될 수 있으며 상태값 저장이 필요하지 않습니다.</li>
<li>벡터 모드: 스캔 대상이 한번에 처리가 가능한 인접하지 않은 블록의 리스트로 구성되어있습니다. 블록 모드와 마찬가지로 상태값 저장은 필요하지 않습니다.</li>
</ul>
<blockquote>
<ul>
<li>Streaming mode: the target data to be scanned is a continuous stream, not all of which is available at once; blocks of data are scanned in sequence and matches may span multiple blocks in a stream. In streaming mode, each stream requires a block of memory to store its state between scan calls.</li>
<li>Block mode: the target data is a discrete, contiguous block which can be scanned in one call and does not require state to be retained.</li>
<li>Vectored mode: the target data consists of a list of non-contiguous blocks that are available all at once. As for block mode, no retention of state is required.</li>
</ul>
</blockquote>
<br>

<p>스트리밍 모드에 사용되는 패턴들을 컴파일하기 위해서는 hs_compile() 함수의 모드 파라미터 값을 HS_MODE_STREAM으로 설정해야합니다; 이와 동일하게, 블록 모드는 HS_MODE_BLCOK, 벡터 모드에서는 HS_MODE_VECTORED로 설정해야합니다. 하나의 모드로 컴파일된 패턴 데이터베이스는 오직 그 모드에서만 사용할 수 있습니다. 패턴 데이터베이스를 컴파일하기 위해 사용된 Hyperscan 버전과 스캔을 위한 Hyperscan 버전은 반드시 일치해야합니다.</p>
<blockquote>
<p>To compile patterns to be used in streaming mode, the mode parameter of hs_compile() must be set to HS_MODE_STREAM; similarly, block mode requires the use of HS_MODE_BLOCK and vectored mode requires the use of HS_MODE_VECTORED. A pattern database compiled for one mode (streaming, block or vectored) can only be used in that mode. The version of Hyperscan used to produce a compiled pattern database must match the version of Hyperscan used to scan with it.</p>
</blockquote>
<br>

<h3 id="Pattern-Support"><a href="#Pattern-Support" class="headerlink" title="Pattern Support"></a>Pattern Support</h3><p>Hyperscan은 PCRE 라이브러리(“libpcre”)에서 사용되는 패턴 문법(<a href="https://www.pcre.org/">https://www.pcre.org</a> 참조)을 지원합니다. 하지만 libpcre에서 사용가능한 모든 구조들을 지원하는 것은 아닙니다. 지원하지 않는 구조들을 사용하는 경우 컴파일 에러를 발생시킬 것입니다.</p>
<blockquote>
<p>Hyperscan supports the pattern syntax used by the PCRE library (“libpcre”), described at <a href="https://www.pcre.org/">https://www.pcre.org</a>. However, not all constructs available in libpcre are supported. The use of unsupported constructs will result in compilation errors.</p>
</blockquote>
<br>

<p>PCRE 8.41 또는 그 상위 버전을 사용해야만 Hyperscan의 PCRE 라이브러리 문법 분석이 유효합니다.</p>
<blockquote>
<p>The version of PCRE used to validate Hyperscan’s interpretation of this syntax is 8.41 or above.</p>
</blockquote>
<br>

<h4 id="Supported-Constructs"><a href="#Supported-Constructs" class="headerlink" title="Supported Constructs"></a>Supported Constructs</h4><p>지원하는 정규표현식 구조들은 <a href="http://intel.github.io/hyperscan/dev-reference/compilation.html#pattern-support">해당 링크</a>를 통해 확인가능하며, 아래 2가지 정보를 참고하시기 바랍니다.</p>
<div class="alert info"><p>임의 표현식의 매우 큰 반복 횟수를 갖는 경계가 있는 반복 한정사(예를 들어, ([a-z]|bc*d|xy?z){1000,5000})는 패턴 컴파일 타임에 “Pattern too large” 에러를 발생시킬 것입니다.</p>
<p>Bounded-repeat quantifiers with large repeat counts of arbitrary expressions (e.g. ([a-z]|bc*d|xy?z){1000,5000}) will result in a “Pattern too large” error at pattern compile time.</p>
</div>

<div class="alert info"><p>매칭의 시작 지점을 추출하는 옵션 플래그값인 HS_FLAG_SOM_LEFTMOST를 사용하여 컴파일하는 경우에는 모든 패턴이 정상적으로 컴파일되지 않을 수 있습니다. 해당 플래그 값을 지원하는 패턴들은 Hyperscan에 의해 정상적으로 컴파일되는 패턴들의 일부입니다; 주목할점은, 매칭의 시작 지점을 추출하는 옵션을 사용하지 않고 Hyperscan 컴파일이 가능한 대다수의 경계가 있는 반복 한정사 형태들은 해당 옵션을 사용하는 경우에는 컴파일되지 않을 수 있습니다. (반복 한정사를 사용하는 패턴들의 경우에는 컴파일 시 SOM값 사용에 주의해야함)</p>
<p>At this time, not all patterns can be successfully compiled with the HS_FLAG_SOM_LEFTMOST flag, which enables per-pattern support for Start of Match. The patterns that support this flag are a subset of patterns that can be successfully compiled with Hyperscan; notably, many bounded repeat forms that can be compiled with Hyperscan without the Start of Match flag enabled cannot be compiled with the flag enabled.</p>
</div>

<br>

<h3 id="Semantics"><a href="#Semantics" class="headerlink" title="Semantics"></a>Semantics</h3><p>Hyperscan은 기본적으로 libpcre 문법을 따르지만, 약간은 다른 문법를 제공합니다. libpcre 문법과의 주요한 차이는 스트리밍과 다중 동시(multiple simultaneous) 패턴 매칭의 요구 사항들에 의해 발생한 것입니다.</p>
<blockquote>
<p>While Hyperscan follows libpcre syntax, it provides different semantics. The major departures from libpcre semantics are motivated by the requirements of streaming and multiple simultaneous pattern matching.</p>
</blockquote>
<br>

<p>libpcre 문법과 주요한 차이는 아래와 같습니다.</p>
<blockquote>
<p>The major departures from libpcre semantics are:</p>
</blockquote>
<br>

<ol>
<li>다중 패턴 매칭: Hyperscan은 패턴 매칭이 몇몇 패턴에 대해 동시에 분석되도록 허용합니다. 이것은 libpcre에서 |(파이프)를 통해 패턴들을 구분하는 것과는 다릅니다.</li>
<li>순서를 보장하지 않음: Hyperscan에서 제공하는 다중 매치는 순서를 보장하지 않습니다.</li>
<li><U>종료 오프셋만 제공</U>: Hyperscan의 기본 동작은 매칭의 종료 오프셋만을 알려주도록 되어있습니다. 시작 오프셋 값의 사용 여부는 패턴 컴파일 타임에 표현식 마다 특정 플래그값(HS_FLAG_SOM_LEFTMOS)을 통해 설정할 수 있습니다. Start of Match 단락에서 자세한 내용을 살펴볼 수 있습니다.</li>
<li><U>“모든 매칭”에 대한 리포트</U>: 표현식 fooxyzbarbar에 대해 foo.*bar 패턴을 스캔하는 경우 Hyperscan은 2가지 매칭 결과(fooxyzbar와 fooxyzbarbar의 끝지점과 일치하는 시점에)를 반환할 것입니다. 이와 대조적으로 기본적인 libpcre 문법에서는 오로지 하나의 매칭 결과만을 반환하게 됩니다. (greedy semantics을 사용하는 경우라면 fooxyzbarbar를 non-greedy semantics을 사용하는 경우라면 fooxyzbar를) 이것은 greedy와 non-greedy semantics간의 전환 과정이 Hyperscan에서는 존재하지 않는다는 것을 의미합니다.</li>
</ol>
<blockquote>
<ol>
<li>Multiple pattern matching: Hyperscan allows matches to be reported for several patterns simultaneously. This is not equivalent to separating the patterns by | in libpcre, which evaluates alternations left-to-right.</li>
<li>Lack of ordering: the multiple matches that Hyperscan produces are not guaranteed to be ordered, although they will always fall within the bounds of the current scan.</li>
<li>End offsets only: Hyperscan’s default behaviour is only to report the end offset of a match. Reporting of the start offset can be enabled with per-expression flags at pattern compile time. See Start of Match for details.</li>
<li>“All matches” reported: scanning /foo.*bar/ against fooxyzbarbar will return two matches from Hyperscan – at the points corresponding to the ends of fooxyzbar and fooxyzbarbar. In contrast, libpcre semantics by default would report only one match at fooxyzbarbar (greedy semantics) or, if non-greedy semantics were switched on, one match at fooxyzbar. This means that switching between greedy and non-greedy semantics is a no-op in Hyperscan.</li>
</ol>
</blockquote>
<br>

<h4 id="Start-of-Match-SOM"><a href="#Start-of-Match-SOM" class="headerlink" title="Start of Match(SOM)"></a>Start of Match(SOM)</h4><p>기본적으로 Hyperscan은 매칭 콜백 함수(패턴 매칭이 발생하는 경우 어플리케이션에게 호출 결과를 알려주는 콜백 함수)가 호출될 때 매칭의 종료 오프셋만을 제공할 것입니다. 만약 HS_FLAG_SOM_LEFTMOST 플래그값을 특정 패턴에 적용한다면 동일한 매칭 결과뿐만 아니라 종료 오프셋에 부합하는 가장 왼쪽의 시작 오프셋도 제공할 것입니다.</p>
<blockquote>
<p>In standard operation, Hyperscan will only provide the end offset of a match when the match callback is called. If the HS_FLAG_SOM_LEFTMOST flag is specified for a particular pattern, then the same set of matches is returned, but each match will also provide the leftmost possible start offset corresponding to its end offset.</p>
</blockquote>
<br>

<p>SOM(Start of Match) 플래그의 사용은 몇가지 트레이드오프와 제한들을 수반합니다.</p>
<blockquote>
<p>Using the SOM flag entails a number of trade-offs and limitations:</p>
</blockquote>
<br>

<ul>
<li>지원하는 패턴의 감소: 많은 패턴에 대해, SOM을 추적하는 과정은 복잡하며 Hyperscan의 패턴 컴파일 과정에서 “Pattern too large” 에러를 발생시킬 수 있습니다. (SOM 플래그를 사용하지 않으면 지원하는 패턴이라할지라도)</li>
<li>증가된 스트림 상태: 스캔 시점에 상태 공간은 SOM 오프셋값을 추적하는데 필요하며, 스트리밍 모드 사용 시 해당 공간에는 지속적인 스트림 상태 정보가 저장되어야합니다. 이와 같은 이유로 SOM은 패턴 매칭 시 요구되는 스트림 상태를 증가시킬 것입니다.</li>
<li>성능 오버헤드: 일반적으로 SOM을 추적하는 것과 관련된 성능 비용이 존재합니다.</li>
<li>양립할 수 없는 특성: 몇가지 다른 Hyperscan 패턴 플래그(HS_FLAG_SINGLEMATCH나 HS_FLAG_PREFILTER)들과 SOM은 동시에 사용될 수 없습니다. 이들을 HS_FLAG_SOM_LEFTMOST와 함께 사용하는 경우에는 컴파일 에러를 발생시킬 것입니다.</li>
</ul>
<blockquote>
<ul>
<li>Reduced pattern support: For many patterns, tracking SOM is complex and can result in Hyperscan failing to compile a pattern with a “Pattern too large” error, even if the pattern is supported in normal operation.</li>
<li>Increased stream state: At scan time, state space is required to track potential SOM offsets, and this must be stored in persistent stream state in streaming mode. Accordingly, SOM will generally increase the stream state required to match a pattern.</li>
<li>Performance overhead: Similarly, there is generally a performance cost associated with tracking SOM.</li>
<li>Incompatible features: Some other Hyperscan pattern flags (such as HS_FLAG_SINGLEMATCH and HS_FLAG_PREFILTER) can not be used in combination with SOM. Specifying them together with HS_FLAG_SOM_LEFTMOST will result in a compilation error.</li>
</ul>
</blockquote>
<br>

<p>스트리밍 모드에서는 SOM에 의해 전달되는 정밀성의 정도를 SOM horizon 플래그들을 통해 조절할 수 있습니다. 이 플래그들은 Hyperscan이 종료 오프셋의 특정 길이 내에서 정확한 SOM 정보를 전달하도록 하며, 그렇지않은 경우에는 HS_OFFSET_PAST_HORIZON의 특별한 시작 오프셋을 반환하도록 합니다.</p>
<blockquote>
<p>In streaming mode, the amount of precision delivered by SOM can be controlled with the SOM horizon flags. These instruct Hyperscan to deliver accurate SOM information within a certain distance of the end offset, and return a special start offset of HS_OFFSET_PAST_HORIZON otherwise. Specifying a small or medium SOM horizon will usually reduce the stream state required for a given database.</p>
</blockquote>
<div class="alert info"><p>스트리밍 모드에서 매칭 결과로 반환되는 시작 오프셋은 현재 스캔중인 블록 이전의 스트림 내 한 지점을 가리킵니다. Hyperscan은 이전 블록들을 평가하는 도구를 제공하지 않습니다; 만약 이전 데이터에 대한 검사가 필요하다면 어플리케이션 자체적으로 그 데이터들을 저장해야만 합니다.</p>
<p>In streaming mode, the start offset returned for a match may refer to a point in the stream before the current block being scanned. Hyperscan provides no facility for accessing earlier blocks; if the calling application needs to inspect historical data, then it must store it itself.</p>
</div>

<br>
<br>

<hr>
<h2 id="Scanning-for-Patterns"><a href="#Scanning-for-Patterns" class="headerlink" title="Scanning for Patterns"></a>Scanning for Patterns</h2><p>Hyperscan은 3가지 다른 스캐닝 모드를 제공합니다. 각각의 모드들은 hs_scan으로 시작하는 그들만의 스캐닝 함수를 갖고 있습니다. 추가적으로 스트리밍 모드에는 스트림 상태를 관리하는 몇가지 다른 API 함수들이 존재합니다.</p>
<blockquote>
<p>Hyperscan provides three different scanning modes, each with its own scan function beginning with hs_scan. In addition, streaming mode has a number of other API functions for managing stream state.</p>
</blockquote>
<br>

<h3 id="Handling-Matches"><a href="#Handling-Matches" class="headerlink" title="Handling Matches"></a>Handling Matches</h3><p>매칭이 발생한 경우 모든 스캐닝 함수들은 사용자가 정의한 콜백 함수를 호출할 것입니다. 이 콜백 함수는 아래와 같은 반환 값과 매개변수를 갖습니다:</p>
<blockquote>
<p>All of these functions will call a user-supplied callback function when a match is found. This function has the following signature:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*match_event_handler)</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> id, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> from, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> to, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">void</span> *context)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>매개변수 id</strong>에는 매칭된 표현에대해 컴파일 타임에 입력됐던 id값이 저장되며, <strong>매개변수 to</strong>에는 매칭의 종료 오프셋이 저장될 것입니다. 만약 해당 패턴에 SOM이 요청됐다면, <strong>매개변수 from</strong>에는 매칭의 가장 왼쪽의 시작 오프셋이 저장될 것입니다.</p>
<blockquote>
<p>The id argument will be set to the identifier for the matching expression provided at compile time, and the to argument will be set to the end-offset of the match. If SOM was requested for the pattern (see Start of Match), the from argument will be set to the leftmost possible start-offset for the match.</p>
</blockquote>
<br>

<p>콜백 함수에는 0이 아닌 값을 반환하여 스캐닝 작업을 중지할 수 있는 기능이 있습니다.</p>
<blockquote>
<p>The match callback function has the capability to halt scanning by returning a non-zero value.</p>
</blockquote>
<br>

<p>콜백 함수에 대한 더 많은 정보는 <a href="http://intel.github.io/hyperscan/dev-reference/api_files.html#c.match_event_handler">match_event_handler</a>을 참조하시기 바랍니다.</p>
<blockquote>
<p>See match_event_handler for more information.</p>
</blockquote>
<br>

<h3 id="Streaming-Mode"><a href="#Streaming-Mode" class="headerlink" title="Streaming Mode"></a>Streaming Mode</h3><p><del>일단은 블록모드부터😁</del><br><a href="http://intel.github.io/hyperscan/dev-reference/runtime.html#streaming-mode">링크 참조</a></p>
<br>

<h3 id="Block-Mode"><a href="#Block-Mode" class="headerlink" title="Block Mode"></a>Block Mode</h3><p>블록 모드 API는 hs_scan() 함수 하나로 구성되어 있습니다. 해당 함수는 컴파일된 패턴을 사용하여 타겟 데이터내의 매치 정보를 추출하고, 함수 포인터 콜백을 사용하여 어플리케이션과 통신합니다.</p>
<blockquote>
<p>The block mode runtime API consists of a single function: hs_scan(). Using the compiled patterns this function identifies matches in the target data, using a function pointer callback to communicate with the application.</p>
</blockquote>
<p>hs_scan() 함수는 블록 모드에서는 스트림과 관련된 오버레드를 발생시키지 않는 다는 점만 제외하면 hs_open_stream() → hs_scan_stream() → hs_close_stream()의 호출 과정과 동일합니다.</p>
<blockquote>
<p>This single hs_scan() function is essentially equivalent to calling hs_open_stream(), making a single call to hs_scan_stream(), and then hs_close_stream(), except that block mode operation does not incur all the stream related overhead.</p>
</blockquote>
<br>

<h3 id="Vectored-Mode"><a href="#Vectored-Mode" class="headerlink" title="Vectored Mode"></a>Vectored Mode</h3><p><del>일단은 블록모드부터😁</del><br><a href="http://intel.github.io/hyperscan/dev-reference/runtime.html#vectored-mode">링크 참조</a></p>
<br>

<h3 id="Scratch-Space"><a href="#Scratch-Space" class="headerlink" title="Scratch Space"></a>Scratch Space</h3><p>데이터를 스캐닝하는 동안 Hyperscan은 그때 그때 생성되는 내부 데이터를 저장하기 위한 용도로 임시 메모리 공간의 일부를 필요로합니다. 이 메모리 공간이 불운하게도 스택에 올라가기에는 너무 크고, 특히나 임베디드 어플리케이션의 경우에, 동적으로 할당하기에는 비용이 너무나 큽니다. 그래서 미리 할당되는 공간인 “스크래치” 공간이 스캐닝 함수에 제공되어야만 합니다.</p>
<blockquote>
<p>While scanning data, Hyperscan needs a small amount of temporary memory to store on-the-fly internal data. This amount is unfortunately too large to fit on the stack, particularly for embedded applications, and allocating memory dynamically is too expensive, so a pre-allocated “scratch” space must be provided to the scanning functions.</p>
</blockquote>
<br>

<p>hs_alloc_scratch() 함수는 주어진 데이터베이스를 지원하기 위해 충분히 큰 스크래치 공간을 할당합니다. 만약 어플리케이션이 다중 데이터베이스를 사용하는 경우라면, 오직 하나의 스크래치 영역만이 필요합니다: 이 경우, 각각의 데이터베이스마다 (동일한 스크래치 포인터로) hs_alloc_scratch()함수를 호출하는 것은 주어진 데이터베이스라면 어떠한 것이든지 스캐닝을 지원하기 위한 충분한 스크래치 공간을 보장합니다.</p>
<blockquote>
<p>The function hs_alloc_scratch() allocates a large enough region of scratch space to support a given database. If the application uses multiple databases, only a single scratch region is necessary: in this case, calling hs_alloc_scratch() on each database (with the same scratch pointer) will ensure that the scratch space is large enough to support scanning against any of the given databases.</p>
</blockquote>
<br>

<p>Hyperscan 라이브러리는 re-entrant(여러 쓰레드가 코드를 동시에 수행할 수 있고, 그런 경우에도 실행 결과의 correctness가 보장되는 것) 하지만, 스크래치 공간의 사용은 그렇지 않습니다. 예를 들어, 구성 상 재귀적이고 중첩되는 스캐닝 동작이 필요로 하다면, 컨텍스트 마다의 스크래치 공간이 요구됩니다.</p>
<blockquote>
<p>While the Hyperscan library is re-entrant, the use of scratch spaces is not. For example, if by design it is deemed necessary to run recursive or nested scanning (say, from the match callback function), then an additional scratch space is required for that context.</p>
</blockquote>
<p>재귀적인 스캐닝이 없는 경우라면, 쓰레드 하나 당 오로지 하나의 스크래치 공간만이 필요하며 이 공간은 데이터 스캐닝이 시작되기 전에 할당될 수 있습니다.</p>
<blockquote>
<p>In the absence of recursive scanning, only one such space is required per thread and can (and indeed should) be allocated before data scanning is to commence.</p>
</blockquote>
<p>하나의 “main” 쓰레드에서 표현식들의 집합이 컴파일되고 데이터가 다중 “worker” 쓰레드에 의해 스캐닝되는 상황에서는, hs_clone_scratch()라는 편리한 함수가 이미 존재하는 스크래치 공간의 복사본이 각각의 쓰레드들에게 할당될 수 있도록해줍니다.</p>
<blockquote>
<p>In a scenario where a set of expressions are compiled by a single “main” thread and data will be scanned by multiple “worker” threads, the convenience function hs_clone_scratch() allows multiple copies of an existing scratch space to be made for each thread (rather than forcing the caller to pass all the compiled databases through hs_alloc_scratch() multiple times).</p>
</blockquote>
<br>

<p>예를 들어</p>
<blockquote>
<p>For example:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">hs_error_t</span> err;</span><br><span class="line"><span class="keyword">hs_scratch_t</span> *scratch_prototype = <span class="literal">NULL</span>;</span><br><span class="line">err = <span class="built_in">hs_alloc_scratch</span>(db, &amp;scratch_prototype);</span><br><span class="line"><span class="keyword">if</span> (err != HS_SUCCESS) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hs_alloc_scratch failed!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">hs_scratch_t</span> *scratch_thread1 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">hs_scratch_t</span> *scratch_thread2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 위에서 할당한 scratch_prototype 공간을 복사(clone)해서 scratch_thread1에서도 사용</span></span><br><span class="line">err = <span class="built_in">hs_clone_scratch</span>(scratch_prototype, &amp;scratch_thread1);</span><br><span class="line"><span class="keyword">if</span> (err != HS_SUCCESS) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hs_clone_scratch failed!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 위에서 할당한 scratch_prototype 공간을 복사(clone)해서 scratch_thread2에서도 사용</span></span><br><span class="line">err = <span class="built_in">hs_clone_scratch</span>(scratch_prototype, &amp;scratch_thread2);</span><br><span class="line"><span class="keyword">if</span> (err != HS_SUCCESS) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hs_clone_scratch failed!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">hs_free_scratch</span>(scratch_prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Now two threads can both scan against database db, each with its own scratch space. */</span></span><br></pre></td></tr></table></figure>

<br>
<br>
<span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎

<p><strong>Reference</strong></p>
<ul>
<li><a href="https://www.hyperscan.io/">https://www.hyperscan.io/</a></li>
<li><a href="http://intel.github.io/hyperscan/dev-reference/index.html">http://intel.github.io/hyperscan/dev-reference/index.html</a></li>
<li><a href="https://github.com/intel/hyperscan">https://github.com/intel/hyperscan</a></li>
<li><a href="http://pcre.org/">http://pcre.org/</a></li>
</ul>
]]></content>
      <categories>
        <category>기술문서 번역</category>
      </categories>
      <tags>
        <tag>hyperscan</tag>
        <tag>regex</tag>
        <tag>regular expression</tag>
        <tag>인텔 하이퍼스캔</tag>
        <tag>정규표현식 패턴 매칭</tag>
      </tags>
  </entry>
  <entry>
    <title>IP 라우팅 과정에 대해 알아보자</title>
    <url>/2021/12/06/ip-routing-flow/</url>
    <content><![CDATA[<p><a href="https://chelseafandev.github.io/2021/12/06/ethernet-switching-flow/">저번 포스팅</a>에 이어서 이번에는 L3 스위치에서의 IP 라우팅 과정에 대해 알아보겠습니다.</p>
<span id="more"></span>
<p><a href="https://www.netmanias.com/ko/">넷매니아즈</a>라는 사이트에 총 4편의 시리즈로 연재된 L3 스위치의 패킷 전달에 대한 아주 양질의 게시물을 참고하여 정리해보았으며, 실제 연재글에서는 상세한 그림과 함께 L3 스위치 내부 구조를 좀 더 세분화하여 설명하고 있으니 관심이 있으신분들은 <a href="https://www.netmanias.com/ko/?m=view&id=blog&no=5529">여기</a>를 참조해주시기 바랍니다.</p>
<br>

<!-- toc -->

<p>서버1과 서버4는 서로 다른 VLAN(서버1은 VLAN ID: 10, 서버4는 VLAN ID: 20)에 존재하며, 서버1의 ARP 테이블에는 L3 스위치(여기서는 Gateway)의 엔트리가 이미 존재한다고 가정하겠습니다.<br><br></p>
<h3 id="서버1에서-서버4로-패킷-전달-ARP-Request-Flooding"><a href="#서버1에서-서버4로-패킷-전달-ARP-Request-Flooding" class="headerlink" title="서버1에서 서버4로 패킷 전달 - ARP Request Flooding"></a>서버1에서 서버4로 패킷 전달 - ARP Request Flooding</h3><div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/ip-routing-arp-request-flooding.png" alt="ARP Request Flooding"><span class="caption">ARP Request Flooding</span></div>

<ol>
<li>서버1에서 서버4로 패킷을 보내려고 합니다.</li>
<li>서버1의 <strong>라우팅 테이블</strong>을 참조(Destination 주소 별 게이트웨이 IP와 출력 포트를 확인할 수 있음)하여 서버4의 IP주소는 디폴트 라우트에 매칭된다는 사실과 Gateway IP주소(여기서는 L3 스위치의 주소임) 및 출력 포트를 확인할 수 있습니다.</li>
<li>서버1은 <strong>ARP 테이블</strong>을 참조하여 Gateway IP주소에 대한 MAC 주소를 확인합니다.</li>
<li>출력 포트와 MAC 주소를 확인했으니 서버1은 서버4로 패킷을 송신합니다.</li>
<li>해당 패킷은 출력 포트를 통해 L3 스위치로 이동합니다.</li>
<li>패킷을 수신한 L3 스위치는 해당 패킷을 버퍼(Ingress Packet Buffer)에 잠시 저장해둡니다.</li>
<li>이제 L3 스위치에서 수신한 패킷의 <strong>Source MAC 주소를 학습</strong>할 차례입니다. 동일 VLAN을 소유한 Line Card들에만 Source MAC 주소 정보를 공유하여 각각의 <strong>MAC 테이블</strong>에 그 값(VLAN, Source MAC 주소, 포트)을 저장하도록 합니다.</li>
<li>다음으로 해당 패킷을 <strong>IP 라우팅</strong>시킬지 <strong>Ethernet 스위칭</strong>시킬것인지를 결정하는데 이를 위해 Destination MAC 주소를 참조합니다.<div class="alert info"><p>Destination MAC 주소가 L3 스위치의 MAC 주소인 경우에는, <strong>IP 라우팅</strong><br>Destination MAC 주소가 L3 스위치의 MAC 주소가 아닌 경우에는, <strong>Ethernet 스위칭</strong></p>
</div>
<br></li>
<li>이 경우에는 해당 패킷의 Destination MAC 주소가 Gateway 즉, L3 스위치의 MAC 주소이므로 IP 라우팅을 시킵니다.</li>
<li>IP 라우팅을 위해 L3 스위치는 Destination IP 주소에 대한 FIB lookup(LPM: Longest Prefix Match)을 수행하여 해당 패킷이 L3 스위치와 바로 연결되어 있는 목적지인 서버4로 가고자한다는 것을 확인합니다.</li>
<li>다음으로 L3 스위치는 ARP 테이블을 확인하여 Destination IP 주소에 대한 MAC 주소가 존재하는지 확인합니다.</li>
<li>만약 존재하지 않는다(ARP Miss!)면 동일한 VLAN에 속한 Line Card들에게 ARP Request 패킷을 Flooding합니다.</li>
</ol>
<hr>
<h3 id="서버1에서-서버4로-패킷-전달-ARP-Reply-수신"><a href="#서버1에서-서버4로-패킷-전달-ARP-Reply-수신" class="headerlink" title="서버1에서 서버4로 패킷 전달 - ARP Reply 수신"></a>서버1에서 서버4로 패킷 전달 - ARP Reply 수신</h3><div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/ip-routing-arp-reply-receiving.png" alt="ARP Reply 수신"><span class="caption">ARP Reply 수신</span></div>

<ol>
<li>ARP Request 패킷을 수신한 서버4, 서버5, 서버6중에 해당 IP 주소를 소유한 서버4가 이에 대한 응답으로 ARP Reply를 L3 스위치로 전달합니다.</li>
<li>ARP Reply 패킷을 수신한 L3 스위치는 해당 패킷을 버퍼(Ingress Packet Buffer)에 잠시 저장해둡니다.</li>
<li>이제 L3 스위치에서 수신한 패킷의 <strong>Source MAC 주소를 학습</strong>할 차례입니다. 동일 VLAN을 소유한 Line Card들에만 Source MAC 주소 정보를 공유하여 각각의 <strong>MAC 테이블</strong>에 그 값(VLAN, Source MAC 주소, 포트)을 저장하도록 합니다.</li>
<li>다음으로 해당 패킷을 <strong>IP 라우팅</strong>시킬지 <strong>Ethernet 스위칭</strong>시킬것인지를 결정하는데 이를 위해 Destination MAC 주소를 참조합니다.</li>
<li>이 경우에는 해당 패킷의 Destination MAC 주소가 L3 스위치의 MAC 주소이므로 IP 라우팅을 시킵니다.</li>
<li>여기서 만약 해당 패킷의 타입(Ethernet Header에 있는 EtherType)이 ARP 패킷(EtherType = 0x0806)인 경우에는 라우팅 시키지 않고 무조건 Control Module(L3 스위치 내에 존재하는 특정 모듈)이라는 곳으로 올려줍니다.</li>
<li>ARP Reply 패킷을 수신한 Control Module은 ARP 테이블에 서버4의 IP 주소에 대한 MAC주소를 저장합니다.</li>
<li>여기까지 완료하면 이제 L3 스위치는 서버1에서 받은 패킷을 서버4로 송신할 수 있습니다.</li>
</ol>
<hr>
<h3 id="서버1에서-서버4로-패킷-전달-IP-라우팅"><a href="#서버1에서-서버4로-패킷-전달-IP-라우팅" class="headerlink" title="서버1에서 서버4로 패킷 전달 - IP 라우팅"></a>서버1에서 서버4로 패킷 전달 - IP 라우팅</h3><div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/ip-routing.png" alt="IP 라우팅"><span class="caption">IP 라우팅</span></div>

<ol>
<li>서버1이 목적지 주소가 서버4인 패킷을 L3 스위치로 보냅니다.</li>
<li>패킷을 수신한 L3 스위치는 해당 패킷을 버퍼(Ingress Packet Buffer)에 잠시 저장해둡니다.</li>
<li>Source MAC 주소를 학습해볼까 했지만 해당 패킷의 Source MAC 주소는 이미 학습된 서버1의 정보입니다. 그러니 건너뜁니다.</li>
<li>이제 수신 패킷의 Destination IP 주소로 FIB lookup을해서 OIF(Outgoing Interface)를 확인(여기서는 서버4가 속한 VLAN ID를 확인할 수 있음)합니다.</li>
<li>그리고 ARP 테이블을 참조하여 Destination IP에 대한 MAC 주소를 확인합니다.</li>
<li>마지막으로 5번에서 찾은 MAC 주소를 통해 MAC 테이블에서 출력 포트를 확인합니다.</li>
<li>L3 스위치는 앞서 버퍼에 잠시 저장해둔 패킷(2번 과정을 참고)을 출력을 위한 버퍼(Egress Packet Buffer)로 옮긴 후 6번에서 확인된 MAC주소로 해당 패킷을 송신합니다.</li>
<li>서버1이 송신한 패킷은 최종적으로 서버4에 도달하게됩니다.</li>
</ol>
<hr>
<h3 id="L3-스위치-동작의-핵심-정리"><a href="#L3-스위치-동작의-핵심-정리" class="headerlink" title="L3 스위치 동작의 핵심 정리"></a>L3 스위치 동작의 핵심 정리</h3><ul>
<li>L3 스위치는 수신 패킷에 대해 항상 Source MAC 학습부터 수행한다.</li>
<li>L3 스위치는 수신 패킷의 Destination MAC 주소가 L3 스위치의 MAC 주소이면 IP 라우팅시키고, 그렇지 않은 경우는 Ethernet 스위칭시킨다.</li>
<li>L3 스위치는 IP 라우팅 과정에서 RIB/FIB에 명시된 OIF(Outgoing Interface)가 물리적 포트가 아닌 VLAN ID 정보가 될 수 있으므로, 실제 패킷을 송신할 출력 포트를 확인하기 위해서는 MAC 테이블을 참조해야한다. 즉,<ol>
<li><strong>FIB</strong> lookup을 통해 <strong>Next Hop IP와 OIF</strong>를 알아내고</li>
<li><strong>ARP 테이블</strong> lookup을 통해 Next Hop IP에 대한 <strong>MAC 주소</strong>를 알아내고 (만약 목적지가 L3 스위치와 바로 연결된 경우라면, Destination IP 주소에 대한 MAC 주소를 알아냄)</li>
<li><strong>MAC 테이블</strong> lookup을 통해 MAC 주소에 대한 <strong>물리적 포트</strong>를 알아낸다 (만약 IP 라우팅 과정에서 MAC 테이블에 해당 엔트리가 존재하지 않으면, VLAN 테이블을 참조하여 OIF에 속한 모든 물리적 포트로 패킷을 Flooding 함)</li>
</ol>
</li>
</ul>
<br>
<br>

<span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎

<p><strong>Reference</strong></p>
<ul>
<li><a href="https://www.netmanias.com/ko/?m=view&amp;id=blog&amp;no=5529">https://www.netmanias.com/ko/?m=view&amp;id=blog&amp;no=5529</a></li>
</ul>
]]></content>
      <categories>
        <category>네트워크</category>
      </categories>
      <tags>
        <tag>L3 스위치</tag>
        <tag>ip routing</tag>
        <tag>ip 라우팅</tag>
        <tag>ARP Request</tag>
        <tag>ARP Reply</tag>
      </tags>
  </entry>
  <entry>
    <title>인텔 Hyperscan API 테스트 코드 작성</title>
    <url>/2021/10/12/hyperscan-phase2/</url>
    <content><![CDATA[<p>이번 포스팅에서는 <a href="https://chelseafandev.github.io/2021/09/24/hyperscan-phase1/">인텔 Hyperscan 레퍼런스 가이드 번역</a>에 이어서 Hyperscan API를 직접 사용하여 정규 표현식 패턴 매칭을 수행하는 샘플 코드를 작성하고 테스트 해보는 시간을 갖겠습니다.</p>
<span id="more"></span>

<p>해당 포스팅의 Hyperscan 설치 및 테스트 환경은 <span class="highlight-text yellow">Ubuntu 18.04.5 LTS 기준</span>입니다. 다른 OS에서 Hyperscan 테스트 코드를 작성하고자 하시는 분들은 <a href="http://intel.github.io/hyperscan/dev-reference/getting_started.html#requirements">Hyperscan 공식 홈페이지에 명시된 요구사항 정보</a>를 확인해주시기 바랍니다. </p>
<br>

<!-- toc -->

<br>

<p>아래 그림은 Hyperscan 라이브러리를 컴파일하기 위해 미리 설치되어야할 소프트웨어 목록과 최소 버전 정보입니다. Pcap은 hyperscan에서 제공하는 샘플 코드를 사용하지 않을거라면 굳이 설치할 필요는 없기때문에 제외하도록 하겠습니다. (설치 과정에서 발생하는 오류 댓글로 남겨주시면 피드백드리겠습니다😁)</p>
<div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/hyperscan_dependency.png" alt=""></div>

<br>

<h3 id="CMake-설치"><a href="#CMake-설치" class="headerlink" title="CMake 설치"></a>CMake 설치</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install cmake</span><br></pre></td></tr></table></figure>

<br>

<h3 id="Ragel-설치"><a href="#Ragel-설치" class="headerlink" title="Ragel 설치"></a>Ragel 설치</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install ragel</span><br></pre></td></tr></table></figure>

<br>

<h3 id="Python-설치"><a href="#Python-설치" class="headerlink" title="Python 설치"></a>Python 설치</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install python</span><br></pre></td></tr></table></figure>

<br>

<h3 id="Boost-설치"><a href="#Boost-설치" class="headerlink" title="Boost 설치"></a>Boost 설치</h3><p><a href="https://www.boost.org/doc/libs/1_77_0/more/getting_started/unix-variants.html">Boost 공식 홈페이지</a>를 참조하여 최신 버전(21.10.11 기준 1.77.0) 설치를 수행합니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ wget https://boostorg.jfrog.io/artifactory/main/release/1.77.0/source/boost_1_77_0.tar.bz2</span><br><span class="line">$ tar xvf boost_1_77_0.tar.bz2</span><br><span class="line">$ cd boost_1_77_0</span><br><span class="line">$ sudo ./bootstrap.sh</span><br><span class="line">$ sudo ./b2 install</span><br></pre></td></tr></table></figure>

<br>

<h3 id="Hyperscan-소스-빌드"><a href="#Hyperscan-소스-빌드" class="headerlink" title="Hyperscan 소스 빌드"></a>Hyperscan 소스 빌드</h3><p><a href="https://github.com/intel/hyperscan">해당 링크</a>에서 Hyperscan 최신 소스 코드(21.10.11 기준 5.4.0)를 다운로드 받으실 수 있습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tar xvf v5.4.0.tar.gz</span><br><span class="line">$ cd hyperscan-5.4.0</span><br><span class="line">$ mkdir build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake -DBUILD_STATIC_AND_SHARED=1 ../</span><br><span class="line">$ sudo make</span><br><span class="line">$ sudo make install</span><br><span class="line">ln -s /usr/local/include/boost &lt;hyperscan-source-path&gt;/include/boost</span><br></pre></td></tr></table></figure>

<br>

<h3 id="테스트코드-작성"><a href="#테스트코드-작성" class="headerlink" title="테스트코드 작성"></a>테스트코드 작성</h3><p>테스트코드에 대한 설명은 코드 내 주석으로 대신하겠습니다.</p>
<figure class="codeblock codeblock--tabbed"><figcaption><span>Hyperscan API test code</span><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HyperscanTest</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	HyperscanTest()</span><br><span class="line">	{</span><br><span class="line">		db_ = <span class="literal">nullptr</span>;</span><br><span class="line">		scratch_ = <span class="literal">nullptr</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	~HyperscanTest()</span><br><span class="line">	{</span><br><span class="line">		hs_free_scratch(scratch_);</span><br><span class="line">		hs_free_database(db_);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 정규표현식 샘플 패턴이 저장된 파일을 Hyperscan Pattern DB를 컴파일하기 위한 형태로 파싱해주는 함수입니다.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 파싱하는 파일의 구조는 &lt;id&gt;:/&lt;pattern&gt;/&lt;flags&gt; 형태이며, </span></span><br><span class="line">	<span class="comment">// id/pattern/flags를 각각 멤버 변수인 ids_, patterns_, flags_에 저장합니다.</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">parseFile</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;filename)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::ifstream <span class="title">inFile</span><span class="params">(filename, <span class="built_in">std</span>::ifstream::in)</span></span>;</span><br><span class="line">		<span class="keyword">if</span> (!inFile.good())</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR: unable to open file \""</span> &lt;&lt; filename &lt;&lt; <span class="string">"\""</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; !inFile.eof(); i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">string</span> line;</span><br><span class="line">			getline(inFile, line);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (line.empty() || line[<span class="number">0</span>] == <span class="string">'#'</span>)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="keyword">size_t</span> colonIdx = line.find_first_of(<span class="string">':'</span>);</span><br><span class="line">			<span class="keyword">if</span> (colonIdx == <span class="built_in">std</span>::<span class="built_in">string</span>::npos)</span><br><span class="line">			{</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR: Could not parse line "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">				inFile.close();</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> id = <span class="built_in">std</span>::stoi(line.substr(<span class="number">0</span>, colonIdx).c_str());</span><br><span class="line"></span><br><span class="line">			<span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">expr</span><span class="params">(line.substr(colonIdx + <span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">size_t</span> flagsStart = expr.find_last_of(<span class="string">'/'</span>);</span><br><span class="line">			<span class="keyword">if</span> (flagsStart == <span class="built_in">std</span>::<span class="built_in">string</span>::npos)</span><br><span class="line">			{</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR: no trailing '/' char"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">				inFile.close();</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">pcre</span><span class="params">(expr.substr(<span class="number">1</span>, flagsStart - <span class="number">1</span>))</span></span>;</span><br><span class="line">			<span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">flagsStr</span><span class="params">(expr.substr(flagsStart + <span class="number">1</span>, expr.size() - flagsStart))</span></span>;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> flag = parseFlags(flagsStr);</span><br><span class="line"></span><br><span class="line">			patterns_.push_back(pcre);</span><br><span class="line">			flags_.push_back(flag);</span><br><span class="line">			ids_.push_back(id);</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		inFile.close();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 파싱된 데이터들을 활용하여 Hyperscan에서 사용하는 Pattern DB를 컴파일하는 함수입니다.</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">compileDatabase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">hs_database_t</span> *db = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">hs_compile_error_t</span> *compileErr;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; cstrPatterns;</span><br><span class="line">		cstrPatterns.reserve(patterns_.size());</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;pattern : patterns_)</span><br><span class="line">		{</span><br><span class="line">			cstrPatterns.push_back(pattern.c_str());</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">hs_error_t</span> err_compile = hs_compile_multi(cstrPatterns.data(), flags_.data(), ids_.data(), cstrPatterns.size(), HS_MODE_BLOCK, <span class="literal">nullptr</span>, &amp;db, &amp;compileErr);</span><br><span class="line">		<span class="keyword">if</span> (err_compile != HS_SUCCESS)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (compileErr-&gt;expression &lt; <span class="number">0</span>)</span><br><span class="line">			{</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR: "</span> &lt;&lt; compileErr-&gt;message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">				hs_free_compile_error(compileErr);</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			{</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR: Pattern '"</span> &lt;&lt; patterns_[compileErr-&gt;expression] &lt;&lt; <span class="string">"' failed with error '"</span> &lt;&lt; compileErr-&gt;message &lt;&lt; <span class="string">"'"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">				hs_free_compile_error(compileErr);</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (db_ != <span class="literal">nullptr</span>)</span><br><span class="line">			hs_free_database(db_);</span><br><span class="line"></span><br><span class="line">		db_ = db;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">hs_error_t</span> err_scratch = hs_alloc_scratch(db_, &amp;scratch_);</span><br><span class="line">		<span class="keyword">if</span> (err_scratch != HS_SUCCESS)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR: hs_alloc_scratch failed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 인자로 전달된 패턴 정보가 Hyperscan Pattern DB에 존재하는지 여부를 반환하는 함수입니다.</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">scanPattern</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> pattern)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> match_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 매칭되는 패턴이 Hyperscan Pattern DB에 존재한다면 hs_scan 함수의 6번째 인자로 등록되는 </span></span><br><span class="line">		<span class="comment">// 콜백 함수(해당 코드에서는 람다 함수로 구현)를 통해 결과를 확인할 수 있으며,</span></span><br><span class="line">		<span class="comment">// 5번째 인자인 ctx를 통해 hs_scan 외부의 변수에 콜백 함수의 결과를 저장할 수도 있습니다.</span></span><br><span class="line">		<span class="keyword">if</span> (hs_scan(</span><br><span class="line">				db_,</span><br><span class="line">				pattern.c_str(),</span><br><span class="line">				pattern.length(),</span><br><span class="line">				<span class="number">0</span>,</span><br><span class="line">				scratch_,</span><br><span class="line">				[](<span class="keyword">unsigned</span> <span class="keyword">int</span> id, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> from, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> to, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">void</span> *ctx) -&gt; <span class="keyword">int</span></span><br><span class="line">				{</span><br><span class="line">					<span class="keyword">size_t</span> *matches = (<span class="keyword">size_t</span> *)ctx;</span><br><span class="line">					(*matches)++;</span><br><span class="line">					<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"id: "</span> &lt;&lt; id &lt;&lt; <span class="string">" from: "</span> &lt;&lt; from &lt;&lt; <span class="string">" to: "</span> &lt;&lt; to &lt;&lt; <span class="string">" flags: "</span> &lt;&lt; flags &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				},</span><br><span class="line">				&amp;match_count) != HS_SUCCESS)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hs_scan failed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"match count: "</span> &lt;&lt; match_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">hs_database_t</span> *db_;</span><br><span class="line">   	<span class="keyword">hs_stream_t</span> *stream_;</span><br><span class="line">   	<span class="keyword">hs_scratch_t</span> *scratch_;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; ids_;</span><br><span class="line">   	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; patterns_;</span><br><span class="line">   	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; flags_;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// parseFile 함수에서 호출하며 파일에 등록된 flags 정보를 Hyperscan에서 정의한 상수 값으로 변환하는 작업을 합니다.</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">parseFlags</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;flagsStr)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c : flagsStr)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">switch</span> (c)</span><br><span class="line">			{</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line">				flags |= HS_FLAG_CASELESS;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'m'</span>:</span><br><span class="line">				flags |= HS_FLAG_MULTILINE;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">				flags |= HS_FLAG_DOTALL;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'H'</span>:</span><br><span class="line">				flags |= HS_FLAG_SINGLEMATCH;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'V'</span>:</span><br><span class="line">				flags |= HS_FLAG_ALLOWEMPTY;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'8'</span>:</span><br><span class="line">				flags |= HS_FLAG_UTF8;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'W'</span>:</span><br><span class="line">				flags |= HS_FLAG_UCP;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'\r'</span>: <span class="comment">// stray carriage-return</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> flags;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">   	HyperscanTest hst;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 정규표현식 샘플 패턴들이 등록된 파일을 Hyperscan에서 사용 가능한 형태로 파싱</span></span><br><span class="line">	<span class="keyword">if</span>(!hst.parseFile(<span class="string">"./pattern.db"</span>))</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"parseFile failed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. Hyperscan Pattern DB 컴파일</span></span><br><span class="line">	<span class="keyword">if</span>(!hst.compileDatabase())</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"compileDatabase failed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">   	{</span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">string</span> pattren = <span class="string">""</span>;</span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"체크할 패턴을 입력하세요 &gt;&gt; "</span>;</span><br><span class="line">    	getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, pattren);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3. 컴파일된 Hyperscan Pattern DB를 기반으로 패턴 체크</span></span><br><span class="line">		<span class="keyword">if</span>(!hst.scanPattern(pattren))</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"scanPattern failed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">   	} <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<br>

<h3 id="정규표현식-샘플-패턴-등록"><a href="#정규표현식-샘플-패턴-등록" class="headerlink" title="정규표현식 샘플 패턴 등록"></a>정규표현식 샘플 패턴 등록</h3><p>아래 예시는 (순서대로) 이메일, 전화번호, 휴대폰번호, 우편번호, 주민등록번호에 대한 정규표현식 샘플 패턴이며, 생성한 pattern.db는 테스트코드 빌드 결과 생성되는 실행 파일(example)과 동일한 경로에 위치시키면 됩니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vim pattern.db</span><br><span class="line"></span><br><span class="line">1:/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]&#123;2,4&#125;$/</span><br><span class="line">2:/^(070|02|031|032|033|041|042|043|051|052|053|054|055|061|062|063|064)-\d&#123;3,4&#125;-\d&#123;4&#125;$/</span><br><span class="line">3:/^(010|011|016|017|018|019)-\d&#123;3,4&#125;-\d&#123;4&#125;$/</span><br><span class="line">4:/^\d&#123;3&#125;-?\d&#123;3&#125;$/</span><br><span class="line">5:/^\d&#123;2&#125;[0-1]\d[0-3]\d-?[1-6]\d&#123;6&#125;$/</span><br></pre></td></tr></table></figure>

<br>

<h3 id="빌드-및-테스트"><a href="#빌드-및-테스트" class="headerlink" title="빌드 및 테스트"></a>빌드 및 테스트</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ c++ -I /usr/local/include/hs example.cpp -o example -L &lt;hyperscan-source-path&gt;/build/lib -lhs</span><br><span class="line">$ ./example</span><br><span class="line">체크할 패턴을 입력하세요 &gt;&gt; 900101-1234567</span><br><span class="line">id: 5 from: 0 to: 14 flags: 0</span><br><span class="line">match count: 1</span><br><span class="line">체크할 패턴을 입력하세요 &gt;&gt; 010-1234-5678</span><br><span class="line">id: 3 from: 0 to: 13 flags: 0</span><br><span class="line">match count: 1</span><br><span class="line">체크할 패턴을 입력하세요 &gt;&gt; bluetomorrow90@gmail.com</span><br><span class="line">id: 1 from: 0 to: 24 flags: 0</span><br><span class="line">match count: 1</span><br><span class="line">체크할 패턴을 입력하세요 &gt;&gt; </span><br></pre></td></tr></table></figure>

<div class="alert info"><p>example 실행 시 libhs.so를 참조하지 못하는 경우에는 아래 명령어를 통해 라이브러리 참조 경로를 직접 지정해줍니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ export LD_LIBRARY_PATH=&lt;hyperscan-source-path&gt;/build/lib</span><br></pre></td></tr></table></figure></div>

<br>

<h3 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h3><p>지금까지 Hyperscan 소스 빌드 과정과 정규표현식 샘플 패턴을 체크하기 위한 테스트 코드 작성에 대해 알아보았습니다. 해당 포스팅에서는 Hyperscan API의 가장 기본적인 동작들만을 살펴보았구요, Hyperscan 공식 문서를 살펴보면 멀티쓰레드 환경(“main” thread에서 pattern db를 compile하고 2개 이상의 “worker” thread에서 scan을 수행)에서도 사용이 가능하다고 하니 어떤식으로 구현해야할지 함께 고민해보면 좋을 것 같습니다. 긴 글 읽어주셔서 감사합니다🙂</p>
<blockquote>
<p>In a scenario where a set of expressions are compiled by a single “main” thread and data will be scanned by multiple “worker” threads, the convenience function hs_clone_scratch() allows multiple copies of an existing scratch space to be made for each thread (rather than forcing the caller to pass all the compiled databases through hs_alloc_scratch() multiple times).</p>
</blockquote>
<br>
<br>
<span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎

<p><strong>Reference</strong></p>
<ul>
<li><a href="https://intel.github.io/hyperscan/dev-reference/getting_started.html">https://intel.github.io/hyperscan/dev-reference/getting_started.html</a></li>
<li><a href="https://www.boost.org/doc/libs/1_77_0/more/getting_started/unix-variants.html">https://www.boost.org/doc/libs/1_77_0/more/getting_started/unix-variants.html</a></li>
<li><a href="https://github.com/intel/hyperscan">https://github.com/intel/hyperscan</a></li>
<li><a href="https://myeonguni.tistory.com/1555">https://myeonguni.tistory.com/1555</a></li>
</ul>
]]></content>
      <categories>
        <category>기술문서 번역</category>
      </categories>
      <tags>
        <tag>hyperscan</tag>
        <tag>regex</tag>
        <tag>regular expression</tag>
        <tag>인텔 하이퍼스캔</tag>
        <tag>정규표현식 패턴 매칭</tag>
      </tags>
  </entry>
  <entry>
    <title>boost::multiprecision을 활용하여 Java의 BigInteger 흉내내기</title>
    <url>/2023/05/12/impl-big-integer-in-cpp/</url>
    <content><![CDATA[<p><escape><span id="more"></span></escape></p>
<p>아래 표에서 처럼 C/C++에서 지원하는 정수 타입의 자료형(long long 또는 unsigned long long)은 최대 8byte입니다. 그렇다면 8byte(32bit)를 초과하는 정수는 어떤 자료형을 통해 관리해야할까요?</p>
<table>
<thead>
<tr>
<th><strong>자료형</strong></th>
<th><strong>크기</strong></th>
<th><strong>범위</strong></th>
</tr>
</thead>
<tbody><tr>
<td>long long</td>
<td>8 byte</td>
<td>-9,223,372,036,854,775,807 ~ 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td>unsigned long long</td>
<td>8 byte</td>
<td>0 ~ 18,446,744,073,709,551,615</td>
</tr>
</tbody></table>
<p>Java에서는 이처럼 8byte를 초과하는 큰 정수들을 처리하기 위한 BigInteger라는 클래스를 제공하고 있습니다.</p>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">java</li></ul></figcaption><div class="tabs-content"><figure class="highlight java" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line">String left = <span class="string">"18446744073709551615"</span>;</span><br><span class="line">String right = <span class="string">"18446744073709551615"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열 타입의 첫번째 인자 값을 두번째 인자로 지정된 N진수로 변환해줌</span></span><br><span class="line">BigInteger bi_left = <span class="keyword">new</span> BigInteger(left, <span class="number">10</span>);</span><br><span class="line">BigInteger bi_right = <span class="keyword">new</span> BigInteger(right, <span class="number">10</span>);</span><br><span class="line">BigInteger output = bi_left.add(bi_right);</span><br><span class="line">System.out.println(<span class="string">"output(dec): "</span> + output.toString());</span><br><span class="line">      </span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">byte</span>[] ba = output.toByteArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">final</span> <span class="keyword">byte</span> b: ba)</span><br><span class="line">{</span><br><span class="line">  sb.append(String.format(<span class="string">"0x%02x "</span>, b&amp;<span class="number">0xff</span>));</span><br><span class="line">}</span><br><span class="line">System.out.println(<span class="string">"output(hex): "</span> + sb);</span><br></pre></td></tr></tbody></table></figure></div></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">output(dec) : 36893488147419103230</span><br><span class="line">output(hex) : 0x01 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xfe</span><br></pre></td></tr></table></figure>

<br>

<p>불행히도 C/C++ 내장형 타입 중에는 8byte를 초과하는 자료형이 존재하지 않습니다. stackoverflow를 찾아보니 직접 구현을 해서 사용하거나 외부 라이브러리(<a href="https://gmplib.org/">Gmplib</a>, <a href="https://gist.github.com/bloopletech/338338">bigint</a>)를 사용하라고 하는데..<br>입맛에 맞게 사용하기 위해 boost::multiprecision을 활용하여 간략하게 구현해보았습니다.</p>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cinttypes&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/multiprecision/cpp_int.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> left = <span class="string">"18446744073709551615"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> right = <span class="string">"18446744073709551615"</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 18446744073709551615는 10진수로 표현된 20자리 정수 값이며 풀어써보면 (1*10^19) + (8*10^18) + (4*10^17) + ... + (1*10^1) + (5*10^0) 입니다.</span></span><br><span class="line">  <span class="comment">// 해당 과정을 구현한 코드는 아래와 같습니다.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 사실 10진수 정수의 경우에는 문자열 타입의 값을 boost::multiprecision::cpp_int 생성자의 인자로 전달하면 쉽게 변환하여 연산이 가능합니다.</span></span><br><span class="line">  <span class="comment">//   std::string value = "18446744073709551615";</span></span><br><span class="line">  <span class="comment">//   boost::multiprecision::cpp_int bi_value(value);</span></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="comment">// 하지만 Java의 BigInteger 처럼 사용자가 직접 특정 진수를 지정하여 변환할 수는 없었기때문에 진수 변환 로직을 추가했습니다.</span></span><br><span class="line">  boost::<span class="function">multiprecision::cpp_int <span class="title">bi_left</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> len = left.length();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> tmp_str;</span><br><span class="line">    tmp_str.append(<span class="number">1</span>, left[i]);</span><br><span class="line">    bi_left += (boost::multiprecision::<span class="built_in">pow</span>(boost::multiprecision::cpp_int(<span class="number">10</span>), len - i - <span class="number">1</span>) * <span class="built_in">std</span>::strtoimax(tmp_str.c_str(), <span class="literal">nullptr</span>, <span class="number">10</span>));</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  boost::<span class="function">multiprecision::cpp_int <span class="title">bi_right</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  len = right.length();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> tmp_str;</span><br><span class="line">    tmp_str.append(<span class="number">1</span>, left[i]);</span><br><span class="line">    bi_right += (boost::multiprecision::<span class="built_in">pow</span>(boost::multiprecision::cpp_int(<span class="number">10</span>), len - i - <span class="number">1</span>) * <span class="built_in">std</span>::strtoimax(tmp_str.c_str(), <span class="literal">nullptr</span>, <span class="number">10</span>));</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  boost::multiprecision::cpp_int output = bi_left + bi_right;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"output(dec): "</span> &lt;&lt; output &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> byte_array_type = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;;</span><br><span class="line">  byte_array_type ba_output;</span><br><span class="line">  boost::multiprecision::export_bits(output, <span class="built_in">std</span>::back_inserter(ba_output), <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"output(hex): "</span>);</span><br><span class="line">  <span class="keyword">int</span> ba_output_len = ba_output.size();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ba_output_len; ++i)</span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0x%02x "</span>, ba_output[i]);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">output(dec) : 36893488147419103230</span><br><span class="line">output(hex) : 0x01 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xfe</span><br></pre></td></tr></table></figure>

<br>

<p><strong>Reference</strong></p>
<ul>
<li><a href="https://learn.microsoft.com/ko-kr/cpp/cpp/data-type-ranges?view=msvc-170">https://learn.microsoft.com/ko-kr/cpp/cpp/data-type-ranges?view=msvc-170</a></li>
<li><a href="https://stackoverflow.com/questions/36952038/how-to-handle-big-integer-data-more-than-8-byte-or-more-than-20-digits-in-c">https://stackoverflow.com/questions/36952038/how-to-handle-big-integer-data-more-than-8-byte-or-more-than-20-digits-in-c</a></li>
<li><a href="https://gmplib.org/">https://gmplib.org/</a></li>
<li><a href="https://gist.github.com/bloopletech/338338">https://gist.github.com/bloopletech/338338</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>boost::multiprecision</tag>
        <tag>biginteger in c++</tag>
      </tags>
  </entry>
  <entry>
    <title>클래스 템플릿의 특정 멤버 함수만 특수화하기</title>
    <url>/2023/05/02/make-specific-memberfunc-to-templatefunc/</url>
    <content><![CDATA[<p><escape><span id="more"></span></escape></p>
<p>아래와 같이 클래스 템플릿에서 <code>특정 멤버 함수만 특수화</code>가 가능합니다.</p>
<figure class="codeblock codeblock--tabbed"><figcaption><span>mytemplateclass.h</span><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mytemplateclass</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">get_name</span><span class="params">()</span></span>; <span class="comment">// 특수화 하려는 대상</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get_grade</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> name_;</span><br><span class="line">  <span class="keyword">int</span> grade_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mytemplateclass.impl.h"</span></span></span><br></pre></td></tr></tbody></table></figure></div></figure>

<figure class="codeblock codeblock--tabbed"><figcaption><span>mytemplateclass.impl.h</span><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> mytemplateclass&lt;T&gt;::get_name()</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">return</span> name_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> mytemplateclass&lt;<span class="keyword">int</span>&gt;::get_name()</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"specific member function specialization"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> mytemplateclass&lt;T&gt;::get_grade()</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">return</span> grade_;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<br>

<p>C++17 부터는 <code>if constexpr</code>와 <code>std::is_same_v</code>를 조합하여 좀 더 깔끔하게 처리할 수 있습니다.</p>
<figure class="codeblock codeblock--tabbed"><figcaption><span>mytemplateclass_v2.h</span><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mytemplateclass_v2</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">get_name</span><span class="params">()</span></span>; <span class="comment">// 특수화 하려는 대상</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get_grade</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> name_;</span><br><span class="line">  <span class="keyword">int</span> grade_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mytemplateclass_v2.impl.h"</span></span></span><br></pre></td></tr></tbody></table></figure></div></figure>

<figure class="codeblock codeblock--tabbed"><figcaption><span>mytemplateclass_v2.impl.h</span><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> mytemplateclass_v2&lt;T&gt;::get_name()</span><br><span class="line">{</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="built_in">std</span>::is_same_v&lt;<span class="keyword">int</span>, T&gt;)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"specific member function specialization"</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> name_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> mytemplateclass_v2&lt;T&gt;::get_grade()</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">return</span> grade_;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<br>

<p><strong>Reference</strong></p>
<ul>
<li><a href="https://stackoverflow.com/questions/5512910/explicit-specialization-of-template-class-member-function">https://stackoverflow.com/questions/5512910/explicit-specialization-of-template-class-member-function</a></li>
<li><a href="https://en.cppreference.com/w/cpp/types/is_same">https://en.cppreference.com/w/cpp/types/is_same</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>template</tag>
        <tag>template function specialization</tag>
        <tag>if constexpr</tag>
        <tag>std::is_same_v</tag>
      </tags>
  </entry>
  <entry>
    <title>Blocking, Nonblocking, Sync, Async</title>
    <url>/2021/08/02/os-sync-async-block-nonblock/</url>
    <content><![CDATA[<p>오늘은 공룡책🦕에 언급된 Blocking과 Nonblocking, Synchronous와 Asynchronous에 대해서 정리해보고자 합니다. Synchronous와 Asynchronous의 개념은 <strong>쓰레드</strong>와 <strong>I/O</strong>에서 등장하게 되는데요, 각각이 어떠한 의미로 사용되는지도 구분해서 살펴보도록 하겠습니다.</p>
<span id="more"></span>

<!-- toc -->
<br>

<h2 id="I-O-관점에서의-동기와-비동기"><a href="#I-O-관점에서의-동기와-비동기" class="headerlink" title="I/O 관점에서의 동기와 비동기"></a>I/O 관점에서의 동기와 비동기</h2><p>동기(synchronous) 장치는 예측 가능한 응답 시간을 갖는 데이터 전송 작업을 수행합니다. 이와 반대로 비동기(asynchronous) 장치는 데이터 전송 작업에 대한 응답 시간이 불규칙 하거나 예측이 불가능합니다.</p>
<blockquote>
<p>A synchronous device performs data transfers with predictable response times, in coordination with other aspects of the system. An asynchronous device exhibits irregular or unpredictable response times not coordinated with other computer events.</p>
</blockquote>
<div class="alert info"><p>동기 장치로는 테이프, 비동기 장치로는 키보드를 예로 들수 있습니다.</p>
</div>

<br>

<p>아래 그림은 I/O 처리에 있어서 동기와 비동기의 차이(I/O처리가 완료될때까지 기다리느냐 기다리지 않느냐)를 보여주고 있습니다.</p>
<div class="figure " style="width:;"><img class="fig-img" src="/assets/images/os-sync-async-figure1.png" alt=""></div>
<hr>
<h2 id="논블록킹과-비동기-I-O"><a href="#논블록킹과-비동기-I-O" class="headerlink" title="논블록킹과 비동기 I/O"></a>논블록킹과 비동기 I/O</h2><p>시스템 콜 인터페이스의 또 다른 측면은 블록킹(blocking) I/O와 논블록킹(nonblocking) I/O 중 무엇을 선택하는지와 관련되어있습니다. 어플리케이션이 블록킹 시스템 콜을 요청하는 경우에는 해당 시스템 콜을 요청한 쓰레드의 실행이 중단됩니다. 이 쓰레드는 운영 체제의 실행 큐(run queue)에서 대기 큐(wait queue)로 이동하게 됩니다. 시스템 콜이 완료된 이후에는, 해당 쓰레드가 실행이 재개될 수 있는 상태인 실행 큐(run queue)로 다시 이동합니다. 실행이 재개된 어플리케이션에서는 시스템 콜로 부터 반환된 결과를 전달받습니다. I/O 장치에 의해 수행되는 물리적인 행위들은 일반적으로 비동기적(I/O 장치마다 물리적 행위들을 수행하는데 걸리는 시간이 다양하고 예측할 수 없기때문에)입니다. 그럼에도 불구하고 운영 체제는 블록킹 어플리케이션 코드가 논블록킹 어플리케이션 코드보다 상대적으로 작성하기 쉽기 때문에 어플리케이션 인터페이스로 블록킹 시스템 콜을 제공하고 있습니다.</p>
<blockquote>
<p>Another aspect of the system-call interface relates to the choice between blocking I/O and nonblocking I/O. When an application issues a blocking system call, the execution of the calling thread is suspended. The thread is moved from the operating system’s run queue to a wait queue. After the system call completes, the thread is moved back to the run queue, where it is eligible to resume execution. When it resumes execution, it will receive the values returned by the system call. The physical actions performed by I/O devices are generally asynchronous— they take a varying or unpredictable amount of time. Nevertheless, operating systems provide blocking system calls for the application interface, because blocking application code is easier to write than nonblocking application code.</p>
</blockquote>
<br>

<p>몇몇 사용자 레벨의 프로세스들에서 논블록킹 I/O가 필요한 경우가 있습니다. 한가지 예로 모니터에 데이터를 출력함과 동시에 키보드와 마우스의 입력 값을 받는 사용자 인터페이스를 생각해 볼 수 있습니다. 또다른 예로 출력 값의 압축을 풀면서 모니터 화면에 뿌려줌과 동시에 디스크에 저장된 파일에서 프레임들을 읽어들이는 비디오 어플리케이션을 생각해볼 수 있습니다.</p>
<blockquote>
<p>Some user-level processes need nonblocking I/O. One example is a user interface that receives keyboard and mouse input while processing and displaying data on the screen. Another example is a video application that reads frames from a file on disk while simultaneously decompressing and displaying the output on the display.</p>
</blockquote>
<br>

<p>어플리케이션 개발자가 I/O와 동시에 또 다른 실행 흐름을 처리할 수 있는 한가지 방법은 멀티쓰레드를 사용하는 것입니다. 일부 쓰레드는 블록킹 시스템 콜을 처리할 수 있고 나머지 쓰레드들은 작업을 계속해나가면 됩니다. 몇몇 운영 체제는 논블록킹 I/O 시스템 콜을 제공합니다. 논블록킹 호출은 쓰레드의 실행을 중단시키지 않는 대신 몇 바이트가 전달됐는지에 대한 정보를 곧바로 리턴합니다.</p>
<blockquote>
<p>One way an application writer can overlap execution with I/O is to write a multithreaded application. Some threads can perform blocking system calls, while others continue executing. Some operating systems provide nonblocking I/O system calls. A nonblocking call does not halt the execution of the thread for an extended time. Instead, it returns quickly, with a return value that indicates how many bytes were transferred.</p>
</blockquote>
<br>

<p>논블록킹 시스템 콜에 대한 대안으로 비동기 시스템 콜이 있습니다. 비동기 호출은 I/O 처리가 끝나기를 기다리기 않고 곧바로 리턴합니다. 쓰레드는 계속해서 코드를 실행해 나갑니다. I/O 처리가 완료되는 시점이 되면 쓰레드의 주소 공간에 저장된 변수를 사용하거나 시그널 또는 인터럽트를 발생시키거나 쓰레드의 선형 컨트롤 흐름 바깥에서 실행되는 콜백 루틴을 통해 I/O 처리 완료 여부가 쓰레드로 전달됩니다. 논블록킹 read() 함수의 경우에는 사용 가능한 데이터가 무엇이든 즉시 리턴(리턴 값은 요청받은 바이트 전체가 될 수도 있고 혹은 그 보다 적거나 또는 아예 없을 수도 있음)하게 되며, 비동기 read() 함수의 경우에는 함수 전체에 걸쳐 수행될 예정이나 나중에 완료될 전송을 요청한다는 것에 차이가 있습니다.</p>
<blockquote>
<p>An alternative to a nonblocking system call is an asynchronous system call. An asynchronous call returns immediately, without waiting for the I/O to complete. The thread continues to execute its code. The completion of the I/O at some future time is communicated to the thread, either through the setting of some variable in the address space of the thread or through the triggering of a signal or software interrupt or a call-back routine that is executed outside the linear control flow of the thread. The difference between nonblocking and asynchronous system calls is that a nonblocking read() returns immediately with whatever data are available— the full number of bytes requested, fewer, or none at all. An asynchronous read() call requests a transfer that will be performed in its entirety but will complete at some future time.</p>
</blockquote>
<div class="alert info"><p>해당 설명만으로는 nonblocking과 asynchronous의 차이가 명확히 이해가 되질 않아 <a href="https://stackoverflow.com/questions/7931537/whats-the-difference-between-asynchronous-non-blocking-event-base-architectu/9489547#9489547">stack-overflow의 관련 답변</a>을 참조하였습니다. 해당 링크에서 Non-Blocking에 대한 설명 중 “expect caller to execute the call again” 라는 문장이 눈에 들어오네요🙂</p>
</div>

<br>

<p>논블록킹 동작의 좋은 예로 네트워크 소켓에서 사용되는 select() 시스템 콜이 있습니다. 이 시스템 콜은 최대 대기 시간 정보를 인자로 갖고 있습니다. 이 값을 0으로 설정하게 되면 쓰레드는 블록킹없이 네트워크 활동에 대해서 주기적으로 확인합니다. 하지만 select() 함수를 사용하게 되면 추가적인 오버헤드가 발생하게 되는데 이는 select() 함수가 오직 I/O가 가능한지 여부만을 확인(실제 데이터 전송은 일어나지 않음)하기 때문입니다. 실제 데이터 전송을 위해서는 select() 함수 이후에 read()나 write() 함수 호출이 반드시 수반되어야 합니다.</p>
<blockquote>
<p>A good example of nonblocking behavior is the select() system call for network sockets. This system call takes an argument that specifies a maximum waiting time. By setting it to 0, a thread can poll for network activity without blocking. But using select() introduces extra overhead, because the select() call only checks whether I/O is possible. For a data transfer, select() must be followed by some kind of read() or write() command.</p>
</blockquote>
<hr>
<h2 id="쓰레드-관점에서의-동기와-비동기"><a href="#쓰레드-관점에서의-동기와-비동기" class="headerlink" title="쓰레드 관점에서의 동기와 비동기"></a>쓰레드 관점에서의 동기와 비동기</h2><p>멀티 쓰레드 생성의 2가지 전략인 비동기 쓰레드와 동기 쓰레드에 대해 소개해보려합니다. 비동기 쓰레드에서는 부모 쓰레드가 자식 쓰레드를 생성하고나서 자신의 실행을 이어나가는데 이것은 부모와 자식 쓰레드가 동시에 작업을 수행하며 각각의 실행 흐름이 독립적임을 의미합니다. 쓰레드들은 독립적이므로 대게 쓰레드 간의 데이터 공유가 발생하게 됩니다.</p>
<blockquote>
<p>We introduce two general strategies for creating multiple threads: asynchronous threading and synchronous threading. With asynchronous threading, once the parent creates a child thread, the parent resumes its execution, so that the parent and child execute concurrently and independently of one another. Because the threads are independent, there is typically little data sharing between them.</p>
</blockquote>
<p>동기 쓰레드는 부모 쓰레드가 한개 또는 그 이상의 자식 쓰레드를 생성하고 모든 자식의 작업이 끝날때까지 대기한 후에 부모 자신의 실행이 재개됩니다. 부모에 의해 생성된 자식 쓰레드들은 동시에 작업을 수행하지만 자식 쓰레드들의 작업이 모두 완료될때까지 부모 쓰레드는 중단됩니다. 각각의 자식 쓰레드가 작업을 마치게 되면 그것들은 종료되고 그들의 부모 쓰레드로 합류(join)하게 됩니다. 일반적으로 동기 쓰레드는 쓰레드들 간의 중요한 데이터 공유를 수반합니다. 예를 들어 부모 쓰레드가 여러 자식 쓰레드에 의해 계산된 결과들을 취합해야할 수 있습니다.</p>
<blockquote>
<p>Synchronous threading occurs when the parent thread creates one or more children and then must wait for all of its children to terminate before it resumes. Here, the threads created by the parent perform work concurrently, but the parent cannot continue until this work has been completed. Once each thread has finished its work, it terminates and joins with its parent. Only after all of the children have joined can the parent resume execution. Typically, synchronous threading involves significant data sharing among threads. For example, the parent thread may combine the results calculated by its various children.</p>
</blockquote>
<hr>
<h2 id="정리해보면"><a href="#정리해보면" class="headerlink" title="정리해보면"></a>정리해보면</h2><p><strong>블록킹 vs 논블록킹</strong></p>
<ul>
<li>시스템 콜의 요청 주체가 되는 쓰레드를 중단하느냐(대기 큐로 이동시키느냐) 그렇지 않느냐</li>
</ul>
<p><strong>논블록킹 vs 비동기</strong></p>
<ul>
<li>시스템 콜이 곧바로 반환되는 경우, 사용할 수 있는 데이터를 갖고 있느냐 그렇지 않느냐</li>
</ul>
<p><strong>동기 vs 비동기</strong></p>
<ul>
<li>시스템 콜의 완료를 기다리느냐 기다리지 않느냐</li>
</ul>
<hr>
<br>
<br>
<span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎

<p><strong>Reference</strong></p>
<ul>
<li>Abraham Silberschatz, Greg Gagne, Peter B. Galvin. (2018). Operating System Concepts, 10th Edition. Wiley</li>
<li><a href="http://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/">http://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/</a></li>
</ul>
]]></content>
      <categories>
        <category>운영체제</category>
      </categories>
      <tags>
        <tag>async</tag>
        <tag>sync</tag>
        <tag>blocking</tag>
        <tag>nonblocking</tag>
      </tags>
  </entry>
  <entry>
    <title>boost::io_context 실행 모델에 대해 알아보자</title>
    <url>/2023/05/19/multithreaded-execution/</url>
    <content><![CDATA[<p><em><strong>뭐하는 놈인지는 알고 쓰자</strong></em> 시리즈의 네번째 주제는 <code>boost io_context 실행 모델</code>입니다.</p>
<span id="more"></span>

<p><a href="https://dens.website/tutorials/cpp-asio/multithreading">execution model where you launch N threads for the same io_context class instance.</a>와 <a href="https://dens.website/tutorials/cpp-asio/multithreading-2">execution model where you create N pairs of “1 io_context + 1 thread”</a>에 포스팅된 내용을 바탕으로 작성되었으니 참고부탁드립니다.</p>
<br>

<!-- toc -->

<br>

<h2 id="N개의-쓰레드에서-1개의-io-context를-사용하는-실행-모델"><a href="#N개의-쓰레드에서-1개의-io-context를-사용하는-실행-모델" class="headerlink" title="N개의 쓰레드에서 1개의 io_context를 사용하는 실행 모델"></a>N개의 쓰레드에서 1개의 io_context를 사용하는 실행 모델</h2><p>멀티 쓰레드 접근 방식에 뛰어들기 위한 가장 간단한 방법은 각각의 쓰레드들에서 동일한 io_context 객체에 대해서 io_context::run 멤버 함수를 실행하는 것입니다.</p>
<blockquote>
<p>The simplest way to jump into a multithreaded approach is to run io_context::run member function on multiple threads with the same io_context object.</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOOST_ASIO_NO_DEPRECATED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">io::io_context io_context;</span><br><span class="line"><span class="comment">// Prepare things</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line"><span class="keyword">auto</span> count = <span class="built_in">std</span>::thread::hardware_concurrency() * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; count; ++n)</span><br><span class="line">{</span><br><span class="line">    threads.emplace_back([&amp;]</span><br><span class="line">    {</span><br><span class="line">        io_context.run();</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; thread : threads)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(thread.joinable())</span><br><span class="line">    {</span><br><span class="line">        thread.join();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>이 경우에 io_context는 클래식한 쓰레드 풀과 같이 동작합니다. 비동기 작업들은 OS 측면의 어딘가에서 수행되지만 완료 핸들러는 io_context::run 함수가 실행중인 쓰레드들에서 발생하게 됩니다. 좀 더 정확히 말하자면: 모든 완료 핸들러는 io_context::run 함수가 실행 중인 최초의 유휴 상태 쓰레드에서 발생합니다.</p>
<blockquote>
<p>In that case io_context operates like a classic thread pool. Asynchronous tasks are performed somewhere on the OS side, however completion handlers are invoked on those threads where io_context::run function is running. To be more precise: every completion handler is invoked on a first free thread which io_context::run function is running on.</p>
</blockquote>
<p>이것은 완료 핸들러가 병렬적으로 실행될 수 있다는 것을 의미합니다. 그리고 이것은 우리가 동기화가 필요한 지점에 도달했다는 것을 의미하기도 합니다.</p>
<blockquote>
<p>It means that completion handlers could run in parallel. And this is, in turn, mean that we’ve reached a point where we need some synchronization.</p>
</blockquote>
<p>멀티쓰레드 환경에서 여러분이 동기화에 대해 신경써야하는 부분들을 줄일 수록 더 좋을 것입니다. 좋은 소식은 Boost.Asio를 활용한 멀티쓰레드 환경에서는 동기화를 위해 뮤텍스 또는 세마포어와 같은 엣지 로우 레벨 동기화 툴들이 필요하지 않다는 것입니다.</p>
<blockquote>
<p>The less you have to care about synchronization in a multithreaded environment — the better. The good news is that we don’t need such edgy low-level synchronization tools like mutexes or semaphores to get things synchronized in the Boost.Asio multithreaded environment.</p>
</blockquote>
<p>여러분의 완료 핸들러를 적절하게 동기화하기 위해 필요한 것은 io_context::strand 클래스 인스턴스뿐입니다. 그것은 꽤 단순하게 동작합니다: 동일한 io_context::strand에 할당된 완료 핸들러는 순차적으로 실행될 것입니다. 그것들은 서로 다른 쓰레드들에서 실행되지만, 그것들의 실행은 순차적이게 될 것입니다. 이것은 그것들이 병렬적으로 처리되지 않을것이며 여러분이 동기화 처리를 해줄 필요가 없다는 것을 의미합니다.</p>
<blockquote>
<p>The only thing you need to get your completion handlers synchronized properly is io_context::strand class instance. It works pretty simple: completion handlers attached to the same io_context::strand will be invoked serially. They could be invoked from different threads, however those invocations will be serialized. This means that things won’t go in parallel and you don’t have to deal with synchronization.</p>
</blockquote>
<p>따라서 여러분이 해야 할 일은 공유 데이터에서 작동하는 완료 핸들러와 동일한 io_context::strand에 연결되어야 하는 완료 핸들러, 그리고 이들 중 어느 것이 독립적이고 병렬적으로 처리할 수 있는지를 결정하는 것입니다. 여러분은 완료 핸들러를 strand로 감싸기위해 boost::asio::bind_executor 함수를 사용해야합니다. 예제를 살펴봅시다. 우리의 io_context::run 함수가 멀티 쓰레드 환경에서 실행중이라고 가정해보겠습니다.</p>
<blockquote>
<p>So, everything you need to do is to decide which completion handlers operate on a shared data and should be attached to the same io_context::strand, and which of them are independent and can go in parallel. You should use boost::asio::bind_executor function to wrap a completion handler into a strand. Let’s look at the example. Assume that our io_context::run is running on multiple threads:</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">session</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    session(io::io_context&amp; io_context)</span><br><span class="line">    : socket(io_context)</span><br><span class="line">    , read  (io_context)</span><br><span class="line">    , write (io_context)</span><br><span class="line">    {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">async_read</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        io::async_read(socket, read_buffer, io::bind_executor(read, [&amp;] (error_code error, <span class="built_in">std</span>::<span class="keyword">size_t</span> bytes_transferred)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(!error)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                async_read();</span><br><span class="line">            }</span><br><span class="line">        }));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">async_write</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        io::async_read(socket, write_buffer, io::bind_executor(write, [&amp;] (error_code error, <span class="built_in">std</span>::<span class="keyword">size_t</span> bytes_transferred)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(!error)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                async_write();</span><br><span class="line">            }</span><br><span class="line">        }));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    tcp::socket socket;</span><br><span class="line">    io::io_context::strand read;</span><br><span class="line">    io::io_context::strand write;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>위의 예제에서 우리는 2개의 strand를 사용했는데 하나는 read 연산을 다른 하나는 write 연산을 처리하기 위함입니다. 이것은 read 완료 핸들러와 write 완료 핸들러가 서로 다른 strand에서 직렬화 될 것이라는 것을 의미합니다. 또한 이것은 동일한 타입(여기서는 read냐 write냐)의 완료 핸들러들은 순차적으로 진행되나 read와 write 핸들러는 각각 병렬적으로 진행될 것이라는 의미이기도 합니다. 이것이 여러분이 제어 흐름을 동기적으로 유지하기 위해 해야할 전부입니다. 너무 간단하지 않은가요! 여러분이 strand를 적절하게 할당해주는 한 교착상태에 빠지거나 다른 일반적인 멀티쓰레딩 이슈가 발생할 수 없습니다.</p>
<blockquote>
<p>In the example above we used two strands, one for reading and one for writing operations. This means that read completion handlers will be serialized with one strand and write handlers will be serialized with another strand. Which means that completion handlers of the same type will go serially, however read and write handlers will go in parallel to each other. And that’s all you need to keep your control flow synchronized, so simple! Note that you can’t get deadlocked here or run into other common multithreading issues. As long as you designate your strands properly.</p>
</blockquote>
<p>여러분은 주어진 strand안에서 여러분의 functor를 실행하기 위해 boost::asio::post 함수를 사용할 수도 있습니다.</p>
<blockquote>
<p>You can also use boost::asio::post function with io_context::strand to execute your functors within a given strand:</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line">io::post(read, []</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"We're inside a read sequence, it's safe to access a read-related data here!\n"</span>;</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure></div></figure>

<br>

<h2 id="1개의-io-context와-1개의-쓰레드-쌍을-N개-생성하는-실행-모델"><a href="#1개의-io-context와-1개의-쓰레드-쌍을-N개-생성하는-실행-모델" class="headerlink" title="1개의 io_context와 1개의 쓰레드 쌍을 N개 생성하는 실행 모델"></a>1개의 io_context와 1개의 쓰레드 쌍을 N개 생성하는 실행 모델</h2><p>이전 강의에서 N개의 쓰레드를 하나의 io_context 클래스 객체에서 동작하도록 하는 실행 모델을 배워보았습니다. 이 경우에 io_context는 여러분을 위해 자체적으로 로드 밸런싱을 수행하며, 여러분은 다음 핸들러를 실행하기 위해 어떤 쓰레드를 사용해야하는지에 대해 신경 쓸 필요가 없습니다.</p>
<blockquote>
<p>In the previous lesson we’ve learned an execution model where you launch N threads for the same io_context class instance. In that case io_context do load balancing for you, and you don’t need to care which thread should be used for the next handler to execute on.</p>
</blockquote>
<p>1개의 io_context와 1개의 쓰레드 쌍을 N개 생성하는 또 다른 실행 모델이 있습니다. 이 경우에 모든 쓰레드는 각자의 io_context 클래스 객체를 갖게됩니다. 아래 예제를 살펴봅시다. io_context group wrapper는 요청된 io_context, work guard 그리고 쓰레드 클래스 객체의 카운트 값을 생성합니다. 우리는 아래 예제를 통해 이 실행 모델에 대해 논의할 예정입니다.</p>
<blockquote>
<p>There is another execution model where you create N pairs of “1 io_context + 1 thread” instead. In that case every thread has its own io_context class instance. Look at the example below. It’s io_context group wrapper which creates requested count of io_context, work guard and thread class instances. We will discuss this execution model below the example.</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOOST_ASIO_NO_DEPRECATED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> io = boost::asio;</span><br><span class="line"><span class="keyword">using</span> tcp = io::ip::tcp;</span><br><span class="line"><span class="keyword">using</span> work_guard_type = io::executor_work_guard&lt;io::io_context::executor_type&gt;;</span><br><span class="line"><span class="keyword">using</span> error_code = boost::system::error_code;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">io_context_group</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    io_context_group(<span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Create io_context and work guard pairs</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="keyword">size_t</span> n = <span class="number">0</span>; n &lt; size; ++n)</span><br><span class="line">        {</span><br><span class="line">            contexts.emplace_back(<span class="built_in">std</span>::make_shared&lt;io::io_context&gt;());</span><br><span class="line">            guards.emplace_back(<span class="built_in">std</span>::make_shared&lt;work_guard_type&gt;(contexts.back()-&gt;get_executor()));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// Create threads</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; io_context : contexts)</span><br><span class="line">        {</span><br><span class="line">            threads.emplace_back([&amp;]</span><br><span class="line">            {</span><br><span class="line">                io_context-&gt;run();</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Join threads</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; thread : threads)</span><br><span class="line">        {</span><br><span class="line">            thread.join();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Round-robin io_context&amp; query</span></span><br><span class="line">    <span class="function">io::io_context&amp; <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> *contexts[index++ % contexts.size()];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">using</span> vector_ptr = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    vector_ptr&lt;io::io_context&gt; contexts;</span><br><span class="line">    vector_ptr&lt;work_guard_type&gt; guards;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt; index = <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">io_context_group <span class="title">group</span><span class="params">(<span class="built_in">std</span>::thread::hardware_concurrency() * <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">tcp::socket <span class="title">socket</span><span class="params">(group.query())</span></span>;</span><br><span class="line">    <span class="comment">// Schedule some tasks</span></span><br><span class="line">    group.run();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>여러분이 이 실행 모델에 관해 알아야하는 내용들:</p>
<blockquote>
<p>Things you should know about this execution model:</p>
</blockquote>
<p>여러분은 strands 또는 다른 어떤 동기화 도구들로 스트레스 받을 필요가 없습니다: 모든 io_context가 단일 쓰레드 내에서 실행되기때문에 동기화가 필요한 데이터가 없습니다. 물론 동일한 io_context 핸들러에서 동일한 데이터에 접근하는것에 한해서 입니다. 이러한 점은 플러스 요인으로 보입니다.</p>
<blockquote>
<p>💡 You don’t need to mess with strands or any other synchronization tools: since every io_context runs within a single thread, no data requires synchronization. As long as you access the same data from the same io_context handlers only. That looks like a plus.</p>
</blockquote>
<p>io_context에서 동작하는 socket이나 acceptor 등과 같은 객체들은 io_context 객체에 한 번만 바인딩됩니다. 여러분은 이러한 객체들의 생명주기 내에서는 또 다른 io_context에 다시 바인딩할 수 없습니다. 이 말은 곧 동일한 io_context에 바인딩된 모든 객체들은 단일 쓰레드 내에서 실행될 것이라는 것을 의미합니다. 이것이 그들이 모든 시간 동안에 동일한 CPU 코어에 바인딩된다는 의미는 아닙니다 - OS는 가장 적합한 코어라고 생각되는 곳에서 쓰레드를 실행하며 쓰레드의 생명주기 내에서 쓰레드의 코어가 변경될 수 있습니다. 하지만 쓰레드가 실행되는 코어가 어디냐에 관계없이 모든 io_context 객체들은 항상 (현재의)단일 코어 내에서 실행될 것입니다. 그래서 여러분은 하나의 코어가 100% 사용률을 보이는 반면 다른 코어들은 놀고 있는 상태인 상황을 직면할 수도 있습니다. 언뜻보기에 이것은 마이너스 요인처럼 보입니다.</p>
<blockquote>
<p>💡 Objects working on io_context, such as sockets, acceptors, etc, are bound to io_context object once. You can’t rebind any of them to another io_context within their lifetime. Which means that all objects bound to the same io_context will run within a single thread. This doesn’t mean that they’re bound to the same hardware CPU core all the time — an operating system runs a thread on the most suitable core and may change a thread’s core within a thread’s lifetime. However wherever that thread is running, all io_context objects will always run within a single (current) core. So you may face a situation when one core runs at 100% load while the others are idle. At a first glance that’s look like a minus.</p>
</blockquote>
<p>진짜 마이너스 요인은 이러한 사실 자체(하나의 코어가 100% 사용률을 보이는 반면 다른 코어들은 놀고 있는 상태)라기 보다는 선택한 밸런싱 알고리즘 또는 특정한 이용 사례에 대한 실행 모델의 부적절한 사용의 결과라고 볼 수 있습니다. 이전에 살펴본 1:N 실행 모델의 경우에는 자체적으로 여러분에게 밸런싱을 제공해주는 반면, 이 모델은 어플리케이션(또는 라이브러리) 개발자에 의해 구현되는 밸런싱 알고리즘을 요구하게 됩니다.</p>
<blockquote>
<p>💡 Well, it’s not really a minus of the execution model itself, but a minus of a balancing algorithm chosen or a result of improper usage of the execution model for a specific use-case. While the execution model from the previous lesson do balancing for you, this lesson’s model requires balancing algorithm to be implemented by the application (or a library) developer.</p>
</blockquote>
<p>이전 강의에서 살펴본 1:N 실행 모델은 범용적으로 사용되는 모델입니다. 여러분이 선택해야하는 밸런싱 알고리즘이 무엇인지 모르겠는 상황이라면 이 모델을 선택하시면 됩니다. 위에서 살펴본 1:1 실행 모델은 더 빠르게 동작할 수 있습니다. 하지만 이것은 특별한 케이스에 대해서만 알맞은 선택입니다: 여러분의 어플리케이션이 또 다른 어플리케이션과 몇가지 특별한 방식으로 상호작용하는 경우에. 그리고 이 특별한 방식은 적절한 밸런싱 알고리즘을 요구합니다. 위에서 본 예제에서는 라운드로빈 알고리즘을 사용했고, 일반적으로 그 알고리즘이 나쁘다 혹은 좋다라고 말할 수는 없습니다 - 이 알고리즘이 적절한지에 대한 판단은 다른 어플리케이션과의 상호작용 방식이 무엇이냐에 따라 달라집니다. 예를 들어, 우리의 어플리케이션이 많은 랜덤한 가벼운 작업들을 처리하는 경우라면 자동화된 밸런서보다 더 나은 해결책일 수 있습니다. 하지만 이러한 판단을 명확히 하는것은 쉽지 않습니다. 커스텀 밸런서의 다른 이용 사례나 디자인 패턴들은 이번 강의의 범위를 벗어나는 내용입니다. 이것들에 대해서는 나중에 다루어보도록 하겠습니다. 다시 한번: 여러분이 어떠한 타입의 실행 모델을 사용해야할지 확신이 서지 않는다면 이전 강의에서 살펴본 1:N 실행 모델을 선택하는것이 바람직합니다.</p>
<blockquote>
<p>💡 The execution model from the previous lesson is a universal one. Pick it if you don’t really know what balancing algorithm you should choose. The execution model from the current lesson may work faster though. However it best fit for special cases only: when your application interacts with other applications in some of special ways. And those special ways require a proper balancing algorithms. In the example above we used a round-robin algorithm, and we can’t really say if that algorithm is bad or good in general — that depends on a way of interaction of our application with other applications. For example, if our application handles a lot of random lightweight tasks then it could be a better solution than the automatic balancer. However things could be not as obvious as they’re appear to be at a first glance. Different use-cases and design patterns of a custom balancer is out of scope of this lesson. We will discuss them some later. Once again: if you’re not sure what type of execution model you should choose then pick an automatic one from the previous lesson.</p>
</blockquote>
<br>

<h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>지금까지 boost::io_context의 실행 모델(execution model)에 대해 알아보았습니다. 아래와 같이 정리해보며 해당 포스팅은 여기서 마치도록 하겠습니다.<br><br></p>
<ul>
<li>boost::io_context의 실행 모델이란 하나의 어플리케이션에서 특정한 작업을 수행하는 <em><strong>thread</strong></em>와 그 쓰레드를 구동하는 공간인 <em><strong>io_context</strong></em>간의 관계를 규정해놓은 것이다.</li>
<li>boost::io_context의 실행 모델에는 1:N 방식과 1:1 방식이 있다. (io_context:thread)</li>
<li>1:N 실행 모델의 경우에는 N개의 쓰레드를 하나의 io_context에서 처리하는 구조이다.</li>
<li>1:1 실행 모델의 경우에는 모든 쓰레드가 각자의 io_context를 갖는 구조이다.</li>
<li>1:N 실행 모델은 N개의 쓰레드들에 대해서 자체적인 로드 밸런싱을 제공하지만, 1:1 실행 모델의 경우에는 그렇지 않다(적절한 밸런싱 알고리즘을 개발자가 선택해서 적용해야함).</li>
<li>어떠한 타입의 실행 모델을 사용해야할지 확신이 서지 않는다면 1:N 모델을 택하라.</li>
</ul>
<br>
<br>

<span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎

<p><strong>Reference</strong></p>
<ul>
<li><a href="https://dens.website/tutorials/cpp-asio/multithreading">https://dens.website/tutorials/cpp-asio/multithreading</a></li>
<li><a href="https://dens.website/tutorials/cpp-asio/multithreading-2">https://dens.website/tutorials/cpp-asio/multithreading-2</a></li>
</ul>
]]></content>
      <categories>
        <category>기술문서 번역</category>
      </categories>
      <tags>
        <tag>boost asio</tag>
        <tag>io_context</tag>
        <tag>thread</tag>
        <tag>execution model</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O는 어떻게 처리될까?</title>
    <url>/2021/07/13/os-io-system/</url>
    <content><![CDATA[<p>운영 체제의 바이블 <a href="https://www.wiley.com/en-us/Operating+System+Concepts%2C+10th+Edition-p-9781119320913">Operating System Concepts</a>(흔히 공룡책🦕이라고들 하죠)을 바탕으로 I/O 시스템에 대해 정리해보았습니다.</p>
<span id="more"></span>

<!-- toc -->
<br>

<h2 id="I-O가-대체-뭐지"><a href="#I-O가-대체-뭐지" class="headerlink" title="I/O가 대체 뭐지?"></a>I/O가 대체 뭐지?</h2><p>컴퓨터는 크게 2가지 역할을 수행한다고 볼 수 있는데 하나는 <span class="highlight-text" style="background-color:#fbf595;">연산(computing)</span> 이고, 하나는 I/O 즉, <span class="highlight-text" style="background-color:#fbf595;">입출력을 처리</span>하는 것입니다. 대부분의 경우 컴퓨터의 주요한 역할은 입출력은 처리하는 I/O라고 생각하면 됩니다. (우리가 웹 페이지에 접속한다거나 파일을 편집하거나 또는 어떠한 정보를 읽거나 입력하고자 할 때 엄청난 연산이 일어나지는 않죠?)<br>컴퓨터에서 운영 체제는 이러한 입출력에 대한 수행과 물리적인 입출력 장치(하드웨어)를 관리하고 컨트롤해주고 있습니다. 그렇다면 (키보드의 입력과 같은) 하드웨어가 주는 입출력 신호를 어떻게 내 PC에 있는 프로그램이 전달받아 처리할 수 있는 걸까요?</p>
<hr>
<h2 id="I-O-요청은-어떻게-처리되는-걸까"><a href="#I-O-요청은-어떻게-처리되는-걸까" class="headerlink" title="I/O 요청은 어떻게 처리되는 걸까?"></a>I/O 요청은 어떻게 처리되는 걸까?</h2><p>공룡책🦕의 내용을 바탕으로 I/O 요청이 처리되는 과정을 하나씩 알아보도록 하겠습니다.<br><br></p>
<div class="figure " style="width:;"><img class="fig-img" src="/assets/images/os-io-system-figure1.png" alt=""></div>

<ol>
<li>사용자 프로세스는 열고 있던 파일의 파일 디스크립터(fd)를 통해 blocking 함수인 read()를 호출(시스템 콜)합니다.</li>
<li>커널 내부의 시스템 콜 코드에서는 정확성을 위해 파라미터들을 체크합니다. 입력 값인 경우에는 해당 데이터가 이미 버퍼 캐시에 존재하여 접근이 가능한 상태라면 그 데이터는 사용자 프로세스로 곧장 반환되고 I/O 요청은 완료됩니다.</li>
<li>만약 버퍼 캐시에 데이터가 없는 상태라면 물리적인 I/O가 반드시 수행되어야 합니다. 시스템 콜을 요청한 사용자 프로세스는 실행 큐(run queue)에서 삭제되고 대기 큐(wait queue)에 추가됩니다. 그리고나서 시스템 콜에 의한 I/O 작업 요청이 스케줄에 포함됩니다. 궁극적으로 I/O 서브 시스템이 해당 요청을 디바이스 드라이버로 전달합니다. I/O 작업 요청이 디바이스 드라이버로 전달되는 방식은 운영 체제의 종류에 따라 subroutine call이 될 수도 있고, in-kernel message가 될 수도 있습니다.</li>
<li>디바이스 드라이버는 커널 버퍼 공간을 할당받아 데이터를 수신할 준비를 하고 I/O 스케줄을 처리합니다. 궁극적으로 디바이스 드라이버는 디바이스 컨트롤 레지스터를 통해서 디바이스 컨트롤러에게 실제 커맨드를 전달합니다.</li>
<li>디바이스 컨트롤러는 데이터 전송을 수행하기 위해 디바이스 하드웨어를 동작시킵니다. <span class="highlight-text red">여기까지가 사용자 프로세스에서의 I/O 요청이 실제 하드웨어까지 도달하는 과정입니다😁</span></li>
<li>지금 보고 있는 예시의 경우에 (디바이스로 I/O 요청 전송이 완료된 경우 인터럽트를 발생시키는)DMA 컨트롤러가 전송 과정을 관리한다고 가정해봅시다.</li>
<li>인터럽트 벡터 테이블을 참조하여 해당 인터럽트 신호가 적절한 인터럽트 핸들러에게 전달되고, 해당 인터럽트 핸들러는 필요한 모든 정보를 저장하고 디바이스 드라이버로 신호를 전달합니다.</li>
<li>디바이스 드라이버가 완료된 I/O 요청 상태를 결정하고 커널 I/O 서브 시스템에게 전달된 요청 정보 처리가 완료됐다고 알려줍니다.</li>
<li>커널은 디바이스 드라이버로부터 전달받은 데이터를 전송하고 사용자 프로세스의 주소 공간에 코드를 반환합니다. 그리고나서 사용자 프로세스는 대기 큐(wait queue)에서 준비 큐(ready queue)로 이동하게 됩니다.</li>
<li>사용자 프로세스를 준비 큐(ready queue)로 이동시키는 작업은 해당 사용자 프로세스의 blocking 상태를 풀겠다는 의미입니다. 스케줄러는 사용자 프로세스를 다시 CPU에 할당하고 시스템 콜이 완료되는 시점에 사용자 프로세스는 실행 상태로 재개됩니다.</li>
</ol>
<hr>
<h2 id="로컬-PC의-키보드-입력을-원격지-PC로-전달하는-과정"><a href="#로컬-PC의-키보드-입력을-원격지-PC로-전달하는-과정" class="headerlink" title="로컬 PC의 키보드 입력을 원격지 PC로 전달하는 과정"></a>로컬 PC의 키보드 입력을 원격지 PC로 전달하는 과정</h2><p>공룡책🦕에서 가져온 예시를 통해 키보드로 부터 들어온 입력 신호가 어떻게 내 PC의 프로그램으로 전달되는지, 더 나아가 전달받은 키보드 입력을 어떻게 멀리 떨어진 원격지 PC에 전달할 수 있는지 살펴보겠습니다.<br><br></p>
<div class="figure " style="width:;"><img class="fig-img" src="/assets/images/os-io-system-figure2.png" alt=""></div>

<p>네트워크 트래픽 또한 높은 컨텍스트 스위치 비율의 원인이 될 수 있습니다. 한 장비에서 또 다른 장비로 원격 로그인을 하는 상황을 예로 들어 보겠습니다. 로컬 장비에서 입력 되는 각각의 문자들은 원격지 장비로 전달돼야 합니다. 로컬 장비에서의 상황을 보면 문자가 입력되고; 키보드 인터럽트가 발생하며; 입력된 문자는 인터럽트 핸들러와 디바이스 드라이버, 커널을 차례대로 통과하여 사용자 프로세스에 도달합니다. 사용자 프로세스는 원격지 장비에 문자를 전송하기 위해 네트워크 I/O 시스템 콜을 사용합니다.</p>
<blockquote>
<p>Network traffic can also cause a high context-switch rate. Consider, for instance, a remote login from one machine to another. Each character typed on the local machine must be transported to the remote machine. On the local machine, the character is typed; a keyboard interrupt is generated; and the character is passed through the interrupt handler to the device driver, to the kernel, and then to the user process. The user process issues a network I/O system call to send the character to the remote machine.</p>
</blockquote>
<p>이후 입력된 문자는 네트워크 패킷을 생성하는 네트워크 레이어를 통해 로컬 커널에서 네트워크 디바이스 드라이버로 흘러 들어갑니다. 네트워크 디바이스 드라이버는 전송할 문자가 포함된 네트워크 패킷을 네트워크 컨트롤러에게 전달하며 이 과정에서 문자가 전송되고 인터럽트가 발생하게 됩니다. 인터럽트는 커널을 통해 사용자 프로세스로 다시 돌아가게 되는데 이는 네트워크 I/O 시스템 콜이 완료되었음을 사용자 프로세스에 알리기 위함입니다.</p>
<blockquote>
<p>The character then flows into the local kernel, through the network layers that construct a network packet, and into the network device driver. The network device driver transfers the packet to the network controller, which sends the character and generates an interrupt. The interrupt is passed back up through the kernel to cause the network I/O system call to complete.</p>
</blockquote>
<p>이제 원격지 시스템(위 그림의 receiving system)의 네트워크 하드웨어는 (위 그림의 sending system에서 전송한)패킷을 수신하며 패킷 수신에 대한 인터럽트가 발생됩니다. 전송된 문자는 네트워크 프로토콜을 통해 언패키징되고 적절한 네트워크 데몬으로 전달됩니다. 네트워크 데몬은 이 전송과 관련된 원격지 장비의 로그인 세션을 확인하여 해당 서브 데몬으로 패킷을 전달합니다. 이러한 과정에서 컨텍스트 스위치와 스테이트 스위치가 수반됩니다 (Figure 12.16).</p>
<blockquote>
<p>Now, the remote system’s network hardware receives the packet, and an interrupt is generated. The character is unpacked from the network protocols and is given to the appropriate network daemon. The network daemon identifies which remote login session is involved and passes the packet to the appropriate subdaemon for that session. Throughout this flow, there are context switches and state switches (Figure 12.16).</p>
</blockquote>
<hr>
<h2 id="I-O에-대해-정리해보면"><a href="#I-O에-대해-정리해보면" class="headerlink" title="I/O에 대해 정리해보면"></a>I/O에 대해 정리해보면</h2><span class="highlight-text" style="background-color:#fbf595;">I/O란 하드웨어 장치를 통한 입출력 정보를 컴퓨터에서 구동 중인 어플리케이션에서 컨트롤하고자 할 때 사용하는 일종의 인터페이스</span>라고 생각하시면 됩니다.

<p>I/O 시스템 콜은 물리적인 장치와 사용자 프로세스 사이의 많은 소프트웨어 계층을 오가는 일이기 때문에 CPU 사용 측면에서 비용이 많이 드는 작업이기도 합니다. 이 둘 간에 존재하는 계층들은 커널의 보호 경계를 오가며 발생하는 컨텍스트 스위칭이나 I/O 장치를 서비스하기 위한 시그널링이나 인터럽트 핸들링, 커널 버퍼와 사용자 프로세스간의 데이터 복사 과정에서의 CPU나 메모리 시스템의 부하로부터 발생하는 일종의 오버헤드입니다.</p>
<blockquote>
<p>I/O system calls are costly in terms of CPU consumption because of the many layers of software between a physical device and an application. These layers imply overhead from several sources: context switching to cross the kernel’s protection boundary, signal and interrupt handling to service the I/O devices, and the load on the CPU and memory system to copy data between kernel buffers and application space.</p>
</blockquote>
<hr>
<h2 id="I-O를-좀-더-효율적으로-처리하기-위해서는"><a href="#I-O를-좀-더-효율적으로-처리하기-위해서는" class="headerlink" title="I/O를 좀 더 효율적으로 처리하기 위해서는?"></a>I/O를 좀 더 효율적으로 처리하기 위해서는?</h2><p>I/O 처리 과정의 효율성을 높이기 위한 몇가지 이론적인 가이드라인이 있습니다.<br><br></p>
<ol>
<li>컨텍스트 스위치의 횟수를 줄인다.</li>
<li>디바이스 장치와 어플리케이션 간의 데이터 교환 과정에서 반드시 수행돼야 하는 메모리 상의 데이터 복사 횟수를 줄인다.</li>
<li>대용량 전송, 스마트 컨트롤, 폴링을 사용함으로써 인터럽트의 빈도를 줄인다.</li>
<li>CPU에서 발생하는 단순 데이터 복사 작업을 줄이기 위해 DMA-knowledgable 컨트롤러를 사용하거나 채널을 사용함으로써 동시성을 높인다.</li>
<li>디바이스 컨트롤러에서의 작업을 CPU와 Bus에서의 작업과 동시에 처리하기 위해 I/O의 기본적인 처리는 하드웨어로 이관한다.</li>
<li>CPU, 메모리 서브시스템, Bus, I/O 수행간(이들 중 어느 한쪽에 일이 몰린다는건 다른 쪽은 노는 시간이 발생한다는 의미)의 밸런스를 맞춘다.</li>
</ol>
<hr>
<h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>지금까지 공룡책🦕을 바탕으로 I/O 시스템에 대해 간략히 정리해보는 시간을 가졌습니다. I/O 처리 단계별로 좀 더 세부적인 동작 방식을 알고 싶다면 아래 레퍼런스를 참고하시기 바랍니다.</p>
<br>
<br>
<span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎

<p><strong>Reference</strong></p>
<ul>
<li>Abraham Silberschatz, Greg Gagne, Peter B. Galvin. (2018). Operating System Concepts, 10th Edition. Wiley</li>
</ul>
]]></content>
      <categories>
        <category>운영체제</category>
      </categories>
      <tags>
        <tag>I/O</tag>
        <tag>I/O system</tag>
      </tags>
  </entry>
  <entry>
    <title>io_context::run 함수가 반환되는 것을 막는 방법</title>
    <url>/2022/01/11/prevent-io-context-run-from-returning/</url>
    <content><![CDATA[<p><em><strong>뭐하는 놈인지는 알고 쓰자</strong></em> 시리즈의 두번째 주제는 <code>boost io_context::run 함수를 실행 상태로 유지하는 방법</code>입니다.</p>
<span id="more"></span>
<p>해당 포스팅에서는 io_context를 사용하기 위해서는 반드시 run 함수를 호출해야한다는 주입식(?) 교육에서 벗어나고자 boost io_context::run 함수에 대해 간략히 알아보고, 우리의 최종 목표인 io_context에 당장에 할당된 작업이 없더라도 io_context::run 함수를 실행 상태로 유지하는 방법에 대해 알아보도록 하겠습니다. <a href="https://dens.website/tutorials/cpp-asio/work">Prevent io_context::run from returning</a> 사이트의 내용을 바탕으로 작성되었으니 참고부탁드립니다.</p>
<br>

<!-- toc -->

<br>

<h2 id="io-context-run-함수란"><a href="#io-context-run-함수란" class="headerlink" title="io_context::run 함수란?"></a>io_context::run 함수란?</h2><p>먼저 <a href="https://www.boost.org/doc/libs/1_78_0/doc/html/boost_asio/reference/io_context/run/overload1.html">Boost 공식 매뉴얼</a>의 내용을 참고하여 io_context::run 함수에 대해 간략히 알아보도록 하겠습니다.</p>
<br>

<p>io_context::run 함수는 io_context 객체의 이벤트 처리 루프를 실행합니다.</p>
<blockquote>
<p>Run the io_context object’s event processing loop.</p>
</blockquote>
<p>run() 함수는 모든 작업이 완료되거나 더이상 처리할 핸들러가 없을때까지 블록상태를 유지합니다. </p>
<blockquote>
<p>The run() function blocks until all work has finished and there are no more handlers to be dispatched, or until the io_context has been stopped.</p>
</blockquote>
<p>io_context가 핸들러를 실행하는 공간인 쓰레드 풀을 설정하기 위해 다중 쓰레드에서도 run() 함수를 호출할 수 있습니다. 쓰레드 풀에서 대기 중인 쓰레드들은 모두 동등한 자격을 가지며 io_context는 핸들러를 실행시키기위해 임의로 그들중 한개를 선택하게됩니다.</p>
<blockquote>
<p>Multiple threads may call the run() function to set up a pool of threads from which the io_context may execute handlers. All threads that are waiting in the pool are equivalent and the io_context may choose any one of them to invoke a handler.</p>
</blockquote>
<p>run() 함수로 부터 빠져나오기 위한 일반적인 방법은 io_context 객체가 종료되도록하는 것입니다. run(), run_one(), poll() 또는 poll_one() 함수를 restart() 함수 호출없이 연속해서 호출하는 경우에는 곧바로 해당 함수를 빠져나오게 될 것입니다.</p>
<blockquote>
<p>A normal exit from the run() function implies that the io_context object is stopped (the stopped() function returns true). Subsequent calls to run(), run_one(), poll() or poll_one() will return immediately unless there is a prior call to restart().</p>
</blockquote>
<p>여기서 저희가 주목할 내용은 io_context::run 함수는 (의도적인 종료 함수의 호출을 제외하고는) io_context 상의 모든 작업이 종료되고, 더이상 io_context에 할당(dispatch)된 핸들러가 없을때까지만 블록(block)상태를 유지한다는 것입니다.</p>
<br>

<h2 id="io-context-run-함수가-반환되지-않도록-하는-방법"><a href="#io-context-run-함수가-반환되지-않도록-하는-방법" class="headerlink" title="io_context::run 함수가 반환되지 않도록 하는 방법"></a>io_context::run 함수가 반환되지 않도록 하는 방법</h2><p>그렇다면 io_context에 당장에 할당할 작업은 없더라도 run 함수를 블록상태로 유지하기 위해서는 어떻게 해야할까요? 여기서 부터는 원문 포스팅에 대한 번역 내용입니다.</p>
<br>

<p><strong>io_context::run</strong>은 모든 예약된 작업이 완료될때까지 실행 상태를 유지합니다. 모든 작업이 완료된 이후에 <strong>io_context::run</strong>은 반환될것이며, 해당 함수를 호출한 쓰레드는 블록이 해제될 것입니다.</p>
<blockquote>
<p><strong>io_context::run</strong> runs until all scheduled tasks are completed. After that <strong>io_context::run</strong> will return and the caller thread will unblock:</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line">boost::asio::io_context io_context;</span><br><span class="line"><span class="comment">// Schedule some tasks</span></span><br><span class="line">io_context.run();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Job's done! Continue the execution\n"</span>;</span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>하지만 때때로 수행할 작업의 유무에 관계없이 io_context::run의 실행 상태를 유지해야하는 경우가 있습니다. 지금까지 살펴보았던 서버들은 항상 <strong>async_accept</strong>를 수행중이었기때문에 적어도 하나의 예약된 작업을 계속해서 가지고 있었습니다. 그렇기때문에 우리는 특정한 방법을 활용하여 그들을 실행중인 상태로 유지해야할 필요가 없었습니다.</p>
<blockquote>
<p>However sometimes you may need to keep it running regardless if there are tasks to execute or not. Servers we’ve reviewed so far were always doing <strong>async_accept</strong>, so they always had at least one task scheduled, so we didn’t really need to keep them running in such a way. </p>
</blockquote>
<p>하지만 클라이언트는 <strong>async_accept</strong> 작업을 수행하지 않으며, 그것의 입장에서 어떠한 특정 시점에 예약된 작업이 없다는 것은 지극히 일반적인 상황입니다. 이러한 상황에서 <strong>io_context::run</strong> 함수가 반환되는 것을 막기 위해 여러분은 <strong>boost::asio::executor_work_guard</strong> 클래스 인스턴스를 사용해야 합니다. 그것의 이름이 너무 길어지는 관계로 별칭(alias)을 사용하도록 하겠습니다.</p>
<blockquote>
<p>However a client doesn’t do <strong>async_accept</strong> and it’s a normal thing for it not to have scheduled tasks at some point at all. To prevent <strong>io_context::run</strong> from returning you should use <strong>boost::asio::executor_work_guard</strong>(a former <strong>io_context::work</strong> which is currently deprecated) class instance. Its name is too long, so let’s alias it right away:</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> work_guard_type = boost::asio::executor_work_guard&lt;boost::asio::io_context::executor_type&gt;;</span><br><span class="line"></span><br><span class="line">boost::asio::io_context io_context;</span><br><span class="line"><span class="function">work_guard_type <span class="title">work_guard</span><span class="params">(io_context.get_executor())</span></span>;</span><br><span class="line"><span class="comment">// Schedule some tasks or not</span></span><br><span class="line">io_context.run();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorry, we'll never reach this!\n"</span>;</span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>여러분은 여전히 어플리케이션을 강제로 혹은 우아하게 종료하기 위한 방법이 필요합니다. 이를 위해 <strong>io_context::stop</strong> 함수를 사용할 수 있습니다.</p>
<blockquote>
<p>You still need a way to stop your application somehow, and to stop it gracefully. You may use <strong>io_context::stop</strong> function:</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line">boost::asio::io_context io_context;</span><br><span class="line"><span class="function">work_guard_type <span class="title">work_guard</span><span class="params">(io_context.get_executor())</span></span>;</span><br><span class="line"><span class="comment">// Schedule some tasks or not</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">watchdog</span><span class="params">([&amp;]</span></span></span><br><span class="line"><span class="function"><span class="params">{</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="number">10</span>s);</span></span></span><br><span class="line"><span class="function"><span class="params">    io_context.stop(); <span class="comment">// That's OK, io_context::stop is thread-safe</span></span></span></span><br><span class="line"><span class="function"><span class="params">})</span></span>;</span><br><span class="line">io_context.run();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"We stopped after 10 seconds of running\n"</span>;</span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>위 경우에 <strong>io_context::run</strong> 함수는 그 즉시 종료되지는 않을 것이지만 가장 적절한 시점에 종료될 것이며 남아있는 예약 작업들은 버려지게 될 것입니다. 이것은 정확히 우리가 원하던 동작일 겁니다.</p>
<blockquote>
<p>In that case <strong>io_context::run</strong> won’t stop right away but do this in the nearest suitable point of time, and the rest of scheduled tasks will be discarded. And that may be exactly what you’re needed.</p>
</blockquote>
<p>여러분은 또한 예약된 모든 작업이 완료될때까지 대기하다 그 이후에 <strong>io_context::run</strong> 함수가 반환되길 원할수도 있습니다. 이를위해 <strong>io_context::work</strong> 클래스 인스턴스를 파괴해주기만 하면 됩니다. 파괴하는 연산 또한 쓰레드에 안전합니다.</p>
<blockquote>
<p>You may also need to wait until all scheduled tasks are completed and return from <strong>io_context::run</strong> after that. To do so you just need to destroy <strong>io_context::work</strong> class instance. This operation is also thread-safe:</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line">boost::asio::io_context io_context;</span><br><span class="line"><span class="keyword">auto</span> work_guard = <span class="built_in">std</span>::make_unique&lt;work_guard_type&gt;(io_context.get_executor());</span><br><span class="line"><span class="comment">// Schedule some tasks or not</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">watchdog</span><span class="params">([&amp;]</span></span></span><br><span class="line"><span class="function"><span class="params">{</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="number">10</span>s);</span></span></span><br><span class="line"><span class="function"><span class="params">    work_guard.reset(); <span class="comment">// Work guard is destroyed, io_context::run is free to return</span></span></span></span><br><span class="line"><span class="function"><span class="params">})</span></span>;</span><br><span class="line">io_context.run();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"We stopped after 10+ seconds of running\n"</span>;</span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>만약 <strong>io_context::run</strong> 함수가 반환된 후 그것을 다시 호출하고 싶다면 그 전에 <strong>io_context::restart</strong> 함수를 호출해야합니다.</p>
<blockquote>
<p>If you’re going to call <strong>io_context::run</strong> once again after it returned, then you should call <strong>io_context::restart</strong> before that.</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line">boost::asio::io_context context;</span><br><span class="line">boost::asio::post(context, [](){ <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello boost::asio::post in context first"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; });</span><br><span class="line">temp_context.run();</span><br><span class="line">boost::asio::post(temp_context, [](){ <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello boost::asio::post in context second"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; });</span><br><span class="line">temp_context.restart();</span><br><span class="line">temp_context.run();</span><br></pre></td></tr></tbody></table></figure></div></figure>

<br>

<h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>지금까지 io_context에 당장에 할당된 작업이 없더라도 io_context::run 함수를 실행 상태로 유지하는 방법에 대해 알아보았습니다. 아래와 같이 정리해보면서 포스팅을 마치도록 하겠습니다.<br><br></p>
<ul>
<li>io_context에 할당된 작업이 없으면 io_context::run 함수는 즉시 반환된다.</li>
<li>io_context에 당장에 할당된 작업이 없는 상황에서 io_context::run 함수가 반환되는 것을 막기 위해서는 boost::asio::executor_work_guard 클래스 인스턴스를 사용하라.</li>
<li>io_context::run 함수가 반환된 후 다시 한번 호출하고 싶다면 io_context::restart 함수를 먼저 호출하라.</li>
</ul>
<br>
<br>

<span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎

<p><strong>Reference</strong></p>
<ul>
<li><a href="https://www.boost.org/doc/libs/1_78_0/doc/html/boost_asio/reference/io_context/run/overload1.html">https://www.boost.org/doc/libs/1_78_0/doc/html/boost_asio/reference/io_context/run/overload1.html</a></li>
<li><a href="https://dens.website/tutorials/cpp-asio/work">https://dens.website/tutorials/cpp-asio/work</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>boost asio</tag>
        <tag>io_context</tag>
        <tag>io_context run</tag>
        <tag>io_context block</tag>
      </tags>
  </entry>
  <entry>
    <title>자주 사용하는 GDB 명령어</title>
    <url>/2023/02/10/tip-for-gdb-debugging/</url>
    <content><![CDATA[<p><escape><span id="more"></span></escape></p>
<!-- toc -->
<br>

<h3 id="gdb를-통해-프로그램-실행"><a href="#gdb를-통해-프로그램-실행" class="headerlink" title="gdb를 통해 프로그램 실행"></a>gdb를 통해 프로그램 실행</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb &#123;(경로포함)프로그램명&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="브레이크-포인트-등록"><a href="#브레이크-포인트-등록" class="headerlink" title="브레이크 포인트 등록"></a>브레이크 포인트 등록</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) b 소스파일명:라인넘버</span><br></pre></td></tr></table></figure>

<br>

<h3 id="프로그램-시작"><a href="#프로그램-시작" class="headerlink" title="프로그램 시작"></a>프로그램 시작</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) r &#123;인자를 추가해야한다면 입력&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="브레이크-포인트에-걸린-후-이어서-진행"><a href="#브레이크-포인트에-걸린-후-이어서-진행" class="headerlink" title="브레이크 포인트에 걸린 후 이어서 진행"></a>브레이크 포인트에 걸린 후 이어서 진행</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) c</span><br></pre></td></tr></table></figure>

<br>

<h3 id="자주-사용하는-명령어"><a href="#자주-사용하는-명령어" class="headerlink" title="자주 사용하는 명령어"></a>자주 사용하는 명령어</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bt(=backtrace)</span><br><span class="line">p(=print)</span><br><span class="line">set print pretty on(or off)</span><br><span class="line">f(=frame)</span><br><span class="line">up</span><br><span class="line">down</span><br></pre></td></tr></table></figure>

<br>

<h3 id="print-포맷-종류"><a href="#print-포맷-종류" class="headerlink" title="print 포맷 종류"></a>print 포맷 종류</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d decimal</span><br><span class="line">x hex</span><br><span class="line">t binary</span><br><span class="line">f floating point</span><br><span class="line">i instruction</span><br><span class="line">c character</span><br></pre></td></tr></table></figure>

<br>

<h3 id="쓰레드-정보-확인"><a href="#쓰레드-정보-확인" class="headerlink" title="쓰레드 정보 확인"></a>쓰레드 정보 확인</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) info threads</span><br></pre></td></tr></table></figure>

<br>

<h3 id="info-threads-명령어를-통해-출력된-id값을-통한-쓰레드-진입"><a href="#info-threads-명령어를-통해-출력된-id값을-통한-쓰레드-진입" class="headerlink" title="(info threads 명령어를 통해 출력된 id값을 통한)쓰레드 진입"></a>(info threads 명령어를 통해 출력된 id값을 통한)쓰레드 진입</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) thread &#123;id&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="레지스터-정보-확인"><a href="#레지스터-정보-확인" class="headerlink" title="레지스터 정보 확인"></a>레지스터 정보 확인</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) info registers</span><br></pre></td></tr></table></figure>

<ul>
<li>rax (eax) : 누산기(accumulator) 레지스터. 산술연산(덧셈, 나눗셈, 곱셈)이나 논리연산을 수행한 반환값이 저장</li>
<li>rbx (ebx) : 베이스 레지스터</li>
<li>rcx (ecx) : 카운터 레지스터. 반복 명령어 사용 시 반복 카운터로 사용되는 값을 저장</li>
<li>rdx (edx) : 데이터 레지스터. 산술연산과 I/O 명령에서 rax(eax)와 함께 사용</li>
<li>rsi (esi) : source 인덱스 레지스터</li>
<li>rdi (edi) : destination 인덱스 레지스터</li>
<li>rbp (ebp) : 베이스 포인터 레지스터. 스택의 시작 지점 주소를 저장</li>
<li>rsp (esp) : 스택 포인터 레지스터. 스택의 가장 마지막 지점 주소를 저장</li>
<li>rip : 명령 포인터 레지스터이다. 현재 명령의 위치를 가리킴</li>
</ul>
<br>

<h3 id="어셈블러-덤프"><a href="#어셈블러-덤프" class="headerlink" title="어셈블러 덤프"></a>어셈블러 덤프</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) disas</span><br></pre></td></tr></table></figure>

<br>

<h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) layout src</span><br><span class="line">(gdb) layout asm</span><br><span class="line">(gdb) layout reg</span><br></pre></td></tr></table></figure>

<br>

<h3 id="특정-변수-값의-주소-출력"><a href="#특정-변수-값의-주소-출력" class="headerlink" title="특정 변수 값의 주소 출력"></a>특정 변수 값의 주소 출력</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) p &amp;&#123;변수명&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="특정-변수의-헥사값-출력"><a href="#특정-변수의-헥사값-출력" class="headerlink" title="특정 변수의 헥사값 출력"></a>특정 변수의 헥사값 출력</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/&#123;출력할크기&#125;bx &#123;변수의 주소값&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="gdb에서-긴-문자열을-줄이지-않고-그대로-출력"><a href="#gdb에서-긴-문자열을-줄이지-않고-그대로-출력" class="headerlink" title="gdb에서 긴 문자열을 줄이지 않고 그대로 출력"></a>gdb에서 긴 문자열을 줄이지 않고 그대로 출력</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) set print elements 0</span><br></pre></td></tr></table></figure>

<br>

<h3 id="gdb에서-중복된-문자열을-그대로-풀어서-출력"><a href="#gdb에서-중복된-문자열을-그대로-풀어서-출력" class="headerlink" title="gdb에서 중복된 문자열을 그대로 풀어서 출력"></a>gdb에서 중복된 문자열을 그대로 풀어서 출력</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) set print repeats 0</span><br></pre></td></tr></table></figure>

<br>

<h3 id="px-pn"><a href="#px-pn" class="headerlink" title="px pn"></a>px pn</h3><p>Boost::shared_ptr을 사용한다면 gdb 디버깅 시 px와 pn정보를 출력할 수 있음</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">element_type* px;                   <span class="comment">// contained pointer</span></span><br><span class="line">boost::detail::shared_count pn;     <span class="comment">// reference count</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="실행-중인-프로세스의-특정-쓰레드-진입"><a href="#실행-중인-프로세스의-특정-쓰레드-진입" class="headerlink" title="실행 중인 프로세스의 특정 쓰레드 진입"></a>실행 중인 프로세스의 특정 쓰레드 진입</h3><p>프로세스가 실행 중인 상태에서 특정 쓰레드 id를 통해 gdb 진입이 가능하며, 이후 <code>CTRL + C</code>를 통해 해당 쓰레드의 흐름을 중단하여 backtrace 확인이 가능함(c 명령어를 통해 실행 재개)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb -p &#123;gdb로 확인할 쓰레드 id&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="sysroot-solib-search-path-substitute-path"><a href="#sysroot-solib-search-path-substitute-path" class="headerlink" title="sysroot / solib-search-path / substitute-path"></a>sysroot / solib-search-path / substitute-path</h3><p>아래 command들은 gdb 실행 시 -ex 옵션(execute a single GDB command)으로 추가해주면 유용함</p>
<ul>
<li>set sysroot {path}</li>
<li>set solib-search-path {path}</li>
<li>set substitute-path {original path} {substitute path}</li>
</ul>
<br>

<p><strong>Reference</strong></p>
<ul>
<li><a href="https://visualgdb.com/gdbreference/commands/">https://visualgdb.com/gdbreference/commands/</a></li>
<li><a href="https://visualgdb.com/gdbreference/commands/set_sysroot">https://visualgdb.com/gdbreference/commands/set_sysroot</a></li>
<li><a href="https://visualgdb.com/gdbreference/commands/set_solib-search-path">https://visualgdb.com/gdbreference/commands/set_solib-search-path</a></li>
<li><a href="https://www.irya.unam.mx/computo/sites/manuales/fce12/debugger/cl/commandref/gdb_mode/cmd_set_substitu.htm">https://www.irya.unam.mx/computo/sites/manuales/fce12/debugger/cl/commandref/gdb_mode/cmd_set_substitu.htm</a></li>
</ul>
]]></content>
      <categories>
        <category>디버깅</category>
      </categories>
      <tags>
        <tag>gdb</tag>
        <tag>gdb command</tag>
        <tag>backtrace</tag>
        <tag>bt</tag>
      </tags>
  </entry>
  <entry>
    <title>(BBC 스포츠) 첼시의 물망에 오른 루카쿠 적절한 오퍼가 온다면 인터 밀란을 떠나기 원해</title>
    <url>/2021/08/05/tr-lukaku-want-to-chelsea/</url>
    <content><![CDATA[<p>오늘은 첼시 이적설이 가까워져가고 있는 루카쿠 관련 기사를 가져왔습니다. 베르너의 결정력이 너무나도 아쉬웠던 지난 시즌 첼시를 생각하면 꼭 필요한 영입이라고 생각되네요😁</p>
<span id="more"></span>
<p>앞으로 굵직한 첼시 이적 관련 기사들은 계속해서 팔로우업 하도록하겠습니다.</p>
<br>
<br>

<p>By Simon Stone BBC Sport<br>4 August 2021 | <a href="https://www.bbc.com/sport/football/european">European Football</a><br><br></p>
<div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/tr-lukaku-want-to-chelsea.jpg" alt="루카쿠는 2010년 이후 세리에A 첫번째 리그 타이틀을 따낸 인터 밀란의 핵심 선수 였습니다."><span class="caption">루카쿠는 2010년 이후 세리에A 첫번째 리그 타이틀을 따낸 인터 밀란의 핵심 선수 였습니다.</span></div>

<p>첼시의 영입 물망에 오른 로멜루 루카쿠는 적절한 오퍼가 온다면 클럽을 떠나고 싶다는 것을 구단측에 이야기하고 있습니다.</p>
<p>이번주 인터 밀란은 첼시의 85m파운드(한화로 약 1354억) 제의를 거절했습니다.</p>
<p>인터 밀란은 클럽에 남기를 원한다는 루카쿠의 이전 인터뷰를 통해 그를 붙잡을 수 있다는 자신감이 있었습니다.</p>
<p>하지만 루카쿠는 또 다른 생각을 갖고 있으며 그가 2011-2014 시즌 뛰었던 첼시로의 복귀를 열망하고 있다고 알려져있습니다.</p>
<p>재정적으로 어려운 상황에 쳐해있는 인터 밀란과 첼시로의 이적을 원하고 있는 로멜루 루카쿠의 상황을 봤을때 판매는 불가피할 것으로 보입니다.</p>
<p>첼시가 이번 여름 로멜루 루카쿠를 영입하기 위해 기꺼이 오퍼 금액을 올릴지 여부를 주목해봐야 할 것 같습니다.</p>
<p>첼시는 최초 비딩에 스페인 수비수인 마르코스 알론소를 포함시켰다고 알려져 있습니다.</p>
<p>루카쿠는 2011년에서 2014년까지 첼시에서 뛰면서 15경기에 출전했으나 임대 후 인상적인 활약을 펼치면서 에버튼으로 이적하게되었습니다.</p>
<p>2017년 다시 한번 첼시로의 합류가 가까워졌었으나 75m파운드(한화로 약 1195억)에 프리미어 리그 라이벌팀인 맨체스터 유나이티드로 이적하게됩니다.</p>
<p>2019년 이탈리아 세리에A로 넘어오게 된 루카쿠는 인터 밀란과 5년 80m유로(74m파운드, 한화로 약 1179억) 계약을 하며 인터 밀란의 클럽 레코드를 기록했습니다.</p>
<br>
<br>

<span class="highlight-text yellow">번역 과정에서 발생하는 오역 및 의역에 대한 정정 댓글 격하게 환영합니다</span>😎
<p>원문 링크: <a href="https://www.bbc.com/sport/football/58094323">Romelu Lukaku: Chelsea target wants to leave Inter Milan if suitable offer is made</a></p>
]]></content>
      <categories>
        <category>해축기사번역</category>
      </categories>
      <tags>
        <tag>루카쿠</tag>
        <tag>루카쿠 첼시</tag>
        <tag>루카쿠 이적</tag>
      </tags>
  </entry>
  <entry>
    <title>템플릿 클래스를 정의할 때 선언부와 구현부를 서로 다른 파일로 분리하는 방법</title>
    <url>/2023/01/26/seperate-header-and-impl-in-template-class/</url>
    <content><![CDATA[<p><escape><span id="more"></span></escape></p>
<p>헤더 파일의 맨 하단에 템플릿 클래스를 구현한 파일을 include 시켜주면 됩니다. (<strong>#include</strong> 는 대상이 되는 파일을 단순히 붙여 넣어주는 역할을 하므로)</p>
<figure class="codeblock codeblock--tabbed"><figcaption><span>mytemplateclass.h</span><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYTEMPLATECLASS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYTEMPLATECLASS_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ggultip</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">mytemplateclass</span></span></span><br><span class="line"><span class="class">	{</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		mytemplateclass();</span><br><span class="line">		~mytemplateclass();</span><br><span class="line">		</span><br><span class="line">		...</span><br><span class="line">	};</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mytemplateclass.impl.h"</span></span></span><br></pre></td></tr></tbody></table></figure></div></figure>


<figure class="codeblock codeblock--tabbed"><figcaption><span>mytemplateclass.impl.h</span><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ggultip</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	mytemplateclass&lt;T&gt;::mytemplateclass()</span><br><span class="line">	{</span><br><span class="line">		...</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	mytemplateclass&lt;T&gt;::~mytemplateclass()</span><br><span class="line">	{</span><br><span class="line">		...</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<br>

<p><strong>Reference</strong></p>
<ul>
<li>Michael Main, Walter Savitch. (2010). Data Structures &amp; Other Objects Using C++, 4th Edition. Pearson</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>template class</tag>
        <tag>템플릿 클래스 구현부 분리</tag>
      </tags>
  </entry>
  <entry>
    <title>강력한 터미널 멀티플렉서 tmux를 활용해보자</title>
    <url>/2021/07/22/tip-how-to-use-tmux-md/</url>
    <content><![CDATA[<p>이번엔 익숙해지면 정말 강력한 터미널 멀티플렉서인 tmux에 대해 소개해보려고 합니다.</p>
<span id="more"></span>

<!-- toc -->
<br>

<h2 id="tmux란"><a href="#tmux란" class="headerlink" title="tmux란?"></a>tmux란?</h2><p>tmux는 말그대로 <em>멀티플렉서</em> 이기때문에 하나의 터미널 화면에 여러 개의 터미널을 각각 독립적으로 관리할 수 있습니다. tmux를 사용하면 Ctrl + Tab을 누르면서 창을 옮겨 다닐 필요없이 한 눈에 여러 터미널을 볼 수 있고, 다양한 명령어를 통해서 좀 더 효율적으로 터미널 작업을 수행할 수 있습니다.</p>
<hr>
<h2 id="tmux의-구조"><a href="#tmux의-구조" class="headerlink" title="tmux의 구조"></a>tmux의 구조</h2><p>tmux에는 몇가지 논리적인 개념을 도입하여 멀티플렉싱 기능을 구조화하였습니다. <a href="http://man.openbsd.org/OpenBSD-current/man1/tmux.1">tmux의 공식 매뉴얼</a>을 참조하여 이 개념에 대해 알아보겠습니다.</p>
<p>tmux를 실행하면 하나의 윈도우(window)를 갖는 새로운 세션(session)만들고 이 것을 화면에 출력합니다. 화면 하단에는 현재 세션 정보를 알 수 있는 상태 표시줄이 있으며 이는 상호 작용을 위한 커맨드를 입력하는데 사용됩니다.</p>
<blockquote>
<p>When tmux is started it creates a new session with a single window and displays it on screen. A status line at the bottom of the screen shows information on the current session and is used to enter interactive commands.</p>
</blockquote>
<p>세션(session)은 tmux가 관리하는 가상의 터미널 집합입니다. 각각의 세션은 그것과 연결된 하나 또는 2개 이상의 윈도우(window)를 갖고 있습니다. 모니터 화면 전체를 차지하고 있는 것이 윈도우(window)이고, 이 윈도우(window)는 몇 개의 사각 판(pane)으로 나누어져 있을 수 있습니다. 그리고 각각의 사각 판(pane)은 분리된 가상의 터미널입니다.</p>
<blockquote>
<p>A session is a single collection of pseudo terminals under the management of tmux. Each session has one or more windows linked to it. A window occupies the entire screen and may be split into rectangular panes, each of which is a separate pseudo terminal.</p>
</blockquote>
<p>위에서 설명한 개념들을 간략히 도식화해보면 아래와 같습니다. 세션(session) 내부에는 윈도우(window)라는 것이 1개 이상 존재할 수 있고, 윈도우(window)라는 것은 1개 이상의 판(pane)으로 이루어져 있습니다. 그리고 이 각각의 판(pane)이 터미널 하나라고 보시면됩니다. 그리고 세션(session) 또한 1개 이상 존재할 수 있습니다.</p>
<div class="figure " style="width:;"><img class="fig-img" src="/assets/images/tmux-figure-1.png" alt="tmux의 논리 구조 도식화"><span class="caption">tmux의 논리 구조 도식화</span></div>

<hr>
<h2 id="tmux-구조별-명령어-정리"><a href="#tmux-구조별-명령어-정리" class="headerlink" title="tmux 구조별 명령어 정리"></a>tmux 구조별 명령어 정리</h2><p>tmux에서 제공하는 다양한 명령어들을 앞서 살펴봤던 tmux의 구조 별로 정리해보았습니다. 제가 자주 사용하는 명령어들만 나열해보았으니 더 많은 명령어 정보들은 tmux 공식 매뉴얼이나 구글링을 통해 찾아보시면 될 것 같습니다.😎</p>
<p>기본적으로 tmux 명령어는 tmux 세션 내에 진입하였을 때 사용이 가능하며 ctrl + b는 tmux 명령어를 입력하고자 할 때 사용하는 입력 값입니다. 아래 명령어 리스트에 ctrl + b가 포함된 것들은 모두 tmux session 내에서 실행하는 것이라고 보면됩니다.<br><br></p>
<ul>
<li><p>Session</p>
<ul>
<li><strong>tmux</strong> : 새로운 세션 생성</li>
<li><strong>tmux ls</strong> : 현재 생성되어 있는 tmux 세션 목록 확인</li>
<li><strong>tmux a -t 세션번호(또는 세션이름)</strong> : 해당 세션으로 이동</li>
<li><strong>tmux kill-session -t 세션번호(또는 세션이름)</strong> : 해당 세션 종료</li>
<li><strong>(ctrl + b) + $</strong> : 현재 세션 명 변경</li>
<li><strong>(ctrl + b) + d</strong> : tmux 세션 빠져나오기(종료는 아님)</li>
</ul>
</li>
<li><p>Window</p>
<ul>
<li><strong>(ctrl + b) + c</strong> : 새로운 윈도우 생성</li>
<li><strong>(ctrl + b) + &amp;</strong> : 현재 윈도우 삭제</li>
<li><strong>(ctrl + b) + ,</strong> : 현재 윈도우 명 변경</li>
<li><strong>(ctrl + b) + 윈도우번호</strong> : 해당 윈도우로 이동</li>
<li><strong>(ctrl + b) + n</strong> : 다음(next) 윈도우로 이동</li>
<li><strong>(ctrl + b) + p</strong> : 이전(previous) 윈도우로 이동</li>
<li><strong>(ctrl + b) + w</strong> : 생성된 윈도우 리스트 정보</li>
</ul>
</li>
<li><p>Pane</p>
<ul>
<li><strong>(ctrl + b) + %</strong> : 열 분할</li>
<li><strong>(ctrl + b) + “</strong> : 행 분할</li>
<li><strong>(ctrl + b) + 방향키</strong> : 분할된 pane 간의 이동</li>
<li><strong>(ctrl + b) + z</strong> : 현재 pane만 전체 크기로 보기(전체 크기에서 동일한 커맨드를 다시 입력할 경우 원래 분할된 창으로 돌아간다)</li>
<li><strong>(ctrl + b) + x</strong> : 현재 pane 종료</li>
</ul>
</li>
</ul>
<hr>
<h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>지금까지 강력한 터미널 멀티플렉서 tmux의 구조와 몇가지 명령어에 대해 알아보았습니다. 앞으로는 tmux와 함께 터미널을 자유롭게 넘나들어 봅시다😁</p>
<br>
<br>
<span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎

<p><strong>Reference</strong></p>
<ul>
<li><a href="http://man.openbsd.org/OpenBSD-current/man1/tmux.1">http://man.openbsd.org/OpenBSD-current/man1/tmux.1</a></li>
<li><a href="https://github.com/tmux/tmux/wiki">https://github.com/tmux/tmux/wiki</a></li>
</ul>
]]></content>
      <categories>
        <category>유용한 팁</category>
      </categories>
      <tags>
        <tag>tmux</tag>
        <tag>terminal multiplexer</tag>
      </tags>
  </entry>
  <entry>
    <title>(BBC 스포츠) 토트넘 공격수 손흥민 4년 재계약 성사</title>
    <url>/2021/08/12/tr-son-new-contract/</url>
    <content><![CDATA[<p>오늘은 현재 프리미어리그 토트넘 핫스퍼에서 활약 중인 손흥민 선수의 재계약 관련 기사를 가져왔습니다. 다음 시즌 누누감독이 이끌게 되는 토트넘, 쌉월클👍 손흥민선수와 함께 좋은 성적 거뒀으면 좋겠습니다.</p>
<span id="more"></span>
<p>아, 참고로 저는 <span class="highlight-text primary">첼시팬</span>입니다😁</p>
<br>
<br>

<p>23 July 2021 | <a href="https://www.bbc.com/sport/football/teams/tottenham-hotspur">Tottenham</a><br><br></p>
<div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/tr-son-new-contract-figure1.jpg" alt="손흥민은 지난 시즌 프리미어리그 17골을 기록했고 팀성적 7위와 유로파 컨퍼런스 리그 진출에 기여했다"><span class="caption">손흥민은 지난 시즌 프리미어리그 17골을 기록했고 팀성적 7위와 유로파 컨퍼런스 리그 진출에 기여했다</span></div>

<p>토트넘의 공격수 손흥민은 4년짜리 새로운 계약을 마무리 지었고 이로써 2025년까지 토트넘 유니폼을 입게되었습니다.</p>
<p>2015년 레버쿠젠에서 이적해온 29살 손흥민은 280경기에서 107골을 기록하고 있습니다.</p>
<p>손흥민은 지금까지 93번 대한민국 A대표팀 선수로 차출돼 27골을 기록했으며 2번의 월드컵에 참가했습니다.</p>
<p>손흥민은 인터뷰에서 “토트넘과의 재계약은 특별한 결단이 필요치 않은 아주 쉬운일이었습니다. 저는 현재 토트넘에서 너무 행복하고 조만간 팬들을 다시 볼 수 있다는 것에 너무 기쁩니다”</p>
<p>“6년 동안 이곳에서 뛰고있다것이 이미 저에겐 큰 영광입니다. 토트넘은 저에게 엄청난 존중을 보여주었고 제가 이곳에 있다는게 너무나 기쁩니다.” 라고 이야기했습니다.</p>
<p>토트넘의 풋볼디렉터인 파블로 파라티치는 이와 같이 덧붙였습니다. “우리 모두 손흥민 선수가 필드 안팎에서 토트넘에게 매우 긍정적인 영향을 끼친다는 것을 알 수 있습니다. 다가오는 시즌에 우리가 이루고자 하는 목표에 그가 함께한다는 것에 우리는 매우 기쁩니다.”</p>
<p>손흥민은 토트넘의 2019년 챔피언스 리그 결승 진출 멤버의 일원이었으며, 8강 맨체스터 시티와의 2차전에서 손흥민의 2골은 원정 다득점으로 토트넘을 4강에 진출할 수 있도록 해주었습니다.</p>
<p>손흥민은 지난 시즌 51경기에서 22골을 기록했으며 팀 동료인 해리 케인과 엄청난 골들을 합작했습니다.</p>
<p>손케 듀오는 20-21시즌 리그 14골을 합작했으며 이는 프리미어 리그 레코드였습니다. 그리고 두 선수 모두 PFA(Professional Footballers’ Association)의 올해의 팀 선수에 선정되었습니다.</p>
<p>하지만 이번 여름 클럽을 떠나고자 하는 의사를 밝힌 잉글랜드의 주장 해리 케인의 거취는 불투명하며 지난 시즌 프리미어 리그 우승팀인 맨체스터 시티가 비드에 참여할 것이라는 보도들이 나오고 있습니다.</p>
<p>토트넘은 지난 시즌 7위로 마감하며 유로파 컨퍼런스 리그에 참가할 수 있게되었습니다. 토트넘은 지난 4월 맨체스터 시티와의 카라바오 컵 결승전에서 패하기 6일 전 조세 무리뉴 감독을 경질하고 유스팀 코치인 라이언 메이슨을 감독 대행으로 선임하며 20-21 시즌을 마감했습니다.</p>
<p>지난달 울브스의 전 감독인 누누 산투를 무리뉴 다음 감독으로 선임(2년 계약)하였으며 메이슨은 기존 유스팀 코치직으로 복귀하였습니다.</p>
<br>
<br>

<span class="highlight-text yellow">번역 과정에서 발생하는 오역 및 의역에 대한 정정 댓글 격하게 환영합니다</span>😎
<p>원문 링크: <a href="https://www.bbc.co.uk/sport/football/57941327">Son Heung-min: Tottenham forward signs new four-year contract</a></p>
]]></content>
      <categories>
        <category>해축기사번역</category>
      </categories>
      <tags>
        <tag>쏘니</tag>
        <tag>손흥민 토트넘</tag>
        <tag>손흥민 재계약</tag>
      </tags>
  </entry>
  <entry>
    <title>그룹이 아닌 계층으로서의 Go 패키지</title>
    <url>/2022/12/01/translate-packages-as-layers/</url>
    <content><![CDATA[<p>이번 포스팅은 지난번 <a href="https://chelseafandev.github.io/2022/09/06/translate-standard-package-layout-in-go/">어떠한 방식으로 Go코드를 구조화해야 하는가?</a> 포스팅과 마찬가지로 Go 소스 코드의 구조화에 대한 고민의 연장선입니다.</p>
<span id="more"></span>

<p>이번에 번역해 본 글도 지난번 포스팅과 동일한 저자가 작성한 글이며 Go 소스 코드의 구조화에 관련된 글을 4년이 지난 후에 다시 한번 게시해주셨더라고요. Go 어플리케이션을 제작할 때 패키지들 간의 관계를 어떻게 바라볼 것인가에 대해 한 번 더 고민할 수 있는 시간이었습니다.</p>
<p>원문을 참고하실 분들은 <a href="https://www.gobeyond.dev/packages-as-layers/">해당 링크</a>를 확인해주시기 바랍니다.</p>
<br>

<!-- toc -->

<br>

<h1 id="그룹이-아닌-계층으로서의-Go-패키지"><a href="#그룹이-아닌-계층으로서의-Go-패키지" class="headerlink" title="그룹이 아닌 계층으로서의 Go 패키지"></a>그룹이 아닌 계층으로서의 Go 패키지</h1><p>숙련된 Go 개발자들에게도 가장 어려운 주제중 하나인 <code>package layout</code>에 대해 다루어보고자 4년전에 <a href="https://www.gobeyond.dev/standard-package-layout/">Standard Package Layout</a>이라는 글을 게시했었습니다. 하지만 대부분의 Go 개발자들은 여전히 그들의 어플리케이션과 함께 방대해져갈 소스 코드를 디렉토리 구조로 정리하는것에 대해 어려움을 겪고 있습니다.</p>
<blockquote>
<p>Four years ago, I wrote an article called <a href="https://www.gobeyond.dev/standard-package-layout/">Standard Package Layout</a> that tried to address one of the most difficult topics for even advanced Go developers: package layout. However, most developers still struggle with organizing their code into a directory structure that will grow gracefully with their application.</p>
</blockquote>
<p>거의 모든 프로그래밍 언어는 관련된 기능들을 함께 그룹화하는 메커니즘을 갖고 있습니다. Ruby는 gems, Java는 pacakages를 갖고 있습니다. 이러한 언어들은 코드를 그룹화 하는 일반적인 규약을 갖고 있지 않는데 솔직히 이것이 크게 중요하지 않기때문입니다. 코드를 그룹화하는 것은 전적으로 개인의 취향에 달려있습니다.</p>
<blockquote>
<p>Nearly all programming languages have a mechanism for grouping related functionality together. Ruby has gems, Java has packages. Those languages don’t have a standard convention for grouping code because, honestly, it doesn’t matter. It all comes down to personal preference.</p>
</blockquote>
<p>하지만 Go언어로 전환하는 개발자들은 매우 빈번하게 그들의 패키지 구조화가 그들을 다시 괴롭히게 된다는 것에 놀라게 됩니다. Go의 패키지는 다른 언어의 패키지의 개념과 왜 이렇게 다른걸까요? 그것은 바로 Go에서 패키지 개념은 그룹이 아닌 계층이기 때문입니다.</p>
<blockquote>
<p>However, developers that transition to Go are surprised by how often their package organization comes back to bite them. Why are Go packages so different from other languages? It’s because they’re not groups—they’re layers.</p>
</blockquote>
<br>

<h2 id="순환-참조-이해하기"><a href="#순환-참조-이해하기" class="headerlink" title="순환 참조 이해하기"></a>순환 참조 이해하기</h2><p>Go 언어의 패키지와 다른 언어들에서의 그룹화간의 주요한 차이는 Go 언어에서는 패키지간의 순환 의존을 허용하지 않는다는 것에 있습니다. 패키지 A가 패키지 B에 의존할 수 있지만 이와 동시에 패키지 B가 패키지 A에 의존적일 수는 없습니다.</p>
<blockquote>
<p>The primary difference between Go packages and grouping in other languages is that Go doesn’t allow for circular dependencies. Package A can depend on package B, but then package B cannot depend back on package A.</p>
</blockquote>
<div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/figure1.png" alt="Package dependencies can only go one way"><span class="caption">Package dependencies can only go one way</span></div>

<p>이러한 제약은 나중에 개발자들이 A와 B 패키지 모두에서 공통된 코드를 공유하게 하고자 할 때 문제를 야기하게 합니다. 이러한 문제에 대한 2가지 정도의 솔루션이 있습니다. 두 패키지를 단일 패키지로 합치거나 또 다른 세번째 패키지를 도입하는 것입니다.</p>
<blockquote>
<p>This restriction causes issues for developers later on when they need to have both packages share common code. There are typically two solutions: either combine both packages into a single package or introduce a third package.</p>
</blockquote>
<div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/figure2.png" alt=""></div>

<p>하지만 더 많은 패키지들로 분할해가는 것은 문제를 더 키우는 꼴입니다. 결국엔 실제 구조가 존재하지 않는 거대한 패키지들의 집합으로 귀결될 것입니다.</p>
<blockquote>
<p>However, splitting out into more and more packages only pushes the problem down the road. Eventually, you end up with a large mess of packages and no real structure.</p>
</blockquote>
<br>

<h2 id="스탠다드-라이브러리-차용하기"><a href="#스탠다드-라이브러리-차용하기" class="headerlink" title="스탠다드 라이브러리 차용하기"></a>스탠다드 라이브러리 차용하기</h2><p>Go 프로그래밍 시에 활용되는 가장 유용한 팁들 중에 하나는 여러분이 가이드가 필요할 때는 Go의 기본 라이브러리를 참고하라는 것입니다. 이 세상에 완벽한 코드라는 것은 없지만 Go의 기본 라이브러리는 해당 언어를 설계한 사람들이 이상적이라고 생각하는 내용들을 압축하고 있습니다.</p>
<blockquote>
<p>One of the most useful tips when programming Go is to look to the standard library when you need guidance. No code is perfect, but the Go standard library encapsulates many of the ideals of the creators of the language.</p>
</blockquote>
<p>예를 들어, net/http 패키지는 아래 그림과 같이 net 패키지의 추상을 기반으로 만들어지며 net 패키지는 io 레이어의 추상을 기반으로 만들어집니다. net 패키지가 net/http 패키지에 의존적일 수 있다고 가정하는 것은 다소 무의미하기 때문에 이러한 패키지 구조는 꽤 잘 동작합니다.</p>
<blockquote>
<p>For example, the net/http package builds on top of the abstractions of the net package, which, in turn, builds on the abstractions of the io layer below it. This package structure works well because it would be nonsensical to imagine the net package needing to somehow depend on net/http.</p>
</blockquote>
<div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/figure3.png" alt=""></div>

<p>Go의 기본 라이브러리에서 잘 동작하는 것과는 별개로 이것을 Go 어플리케이션 개발에 적용하는 것은 어려울 수 있습니다.</p>
<blockquote>
<p>While this works well in the standard library but can be difficult to translate to application development.</p>
</blockquote>
<br>

<h2 id="어플리케이션-개발에-계층-개념-적용하기"><a href="#어플리케이션-개발에-계층-개념-적용하기" class="headerlink" title="어플리케이션 개발에 계층 개념 적용하기"></a>어플리케이션 개발에 계층 개념 적용하기</h2><p><code>WTF Dial</code>이라는 어플리케이션을 예로 들어 살펴볼 예정이므로 이 어플리케이션에 대해 좀 더 살펴보고자 하시는 분들은 <a href="https://www.gobeyond.dev/wtf-dial/">해당 포스팅</a>을 읽어 보시면 됩니다.</p>
<blockquote>
<p>We’ll be looking at an example application called WTF Dial, so you can read the <a href="https://www.gobeyond.dev/wtf-dial/">introductory post</a> to understand more about it.</p>
</blockquote>
<p>이 어플리케이션은 2개의 논리적 계층을 가지고 있습니다:</p>
<blockquote>
<p>In this application, we have two logical layers:</p>
</blockquote>
<blockquote>
<ol>
<li>An SQLite database</li>
<li>An HTTP server</li>
</ol>
</blockquote>
<p>우리는 sqlite와 http 패키지를 각각 생성합니다. 많은 사람들이 Go의 기본 라이브러리 패키지와 동일한 형태의 패키지 이름을 사용하는 것을 꺼려할 것 입니다. 이러한 우려는 유효한 지적이고 여러분은 http 대신에 wtfhttp라고 네이밍할 수도 있을겁니다. 하지만 우리의 HTTP 패키지는 net/http 패키지를 완전히 캡슐화하기 때문에 동일한 파일 내에서 우리의 HTTP 패키지와 net/http 패키지를 함께 사용하는 경우는 결코 발생하지 않습니다. 저는 모든 패키지 이름에 접두어를 붙이는 작업은 지루하고 보기싫다라고 생각하기 때문에 그 짓은 하지 않겠습니다.</p>
<blockquote>
<p>We create a package for each of these — sqlite &amp; http. Many people will balk at naming a package the same name as a standard library package. That’s a valid criticism and you could name it wtfhttp instead, however, our HTTP package fully encapsulates the net/http package so we never use them both in the same file. I find that prefixing every package is tedious and ugly, so I don’t do it.</p>
</blockquote>
<br>

<h3 id="단순한-접근"><a href="#단순한-접근" class="headerlink" title="단순한 접근"></a>단순한 접근</h3><p>우리의 어플리케이션을 구조화하는 한가지 방법은 데이터 타입(User나 Dial과 같은)과 함수(FindUser()나 CreateDial()과 같은)를 sqlite 패키지에 포함시키는 것입니다. http 패키지는 sqlite 패키지에 직접적으로 의존할 수 있습니다:</p>
<blockquote>
<p>One way to structure our application would be to have our data types (e.g., User, Dial) and our functionality (e.g., FindUser(), CreateDial()) inside sqlite. Our http package could depend directly on it:</p>
</blockquote>
<div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/figure4.png" alt=""></div>

<p>이것은 그리 나쁜 접근 방식이 아니며 단순한 어플리케이션에서는 꽤 잘 동작합니다. 하지만 몇가지 문제들에 직면하게 될겁니다. 첫째로 데이터 타입은 sqlite.User와 sqlite.Dial로 네이밍되는데 데이터 타입이라는 것은 SQLite가 아니라 우리 어플리케이션에 속하는 것이므로 이러한 네이밍은 좀 이상해보입니다.</p>
<blockquote>
<p>This is not a bad approach, and it works for simple applications. We end up with a few issues though. First, our data types are named sqlite.User and sqlite.Dial. That sounds odd as our data types belong to our application—not SQLite.</p>
</blockquote>
<p>둘째로 위 구조상 HTTP 계층에서는 오로지 SQLite에 대한 데이터만을 제공할 수 있습니다. 만약 이 두 계층 사이에 캐싱 계층을 하나 추가한다고 하면 어떤일이 벌어질까요? 또 SQLite가 아닌 PostgreSQL 혹은 디스크에 존재하는 JSON 형식의 데이터와 같은 다른 형태의 타입들은 어떻게 지원할까요?</p>
<blockquote>
<p>Second, our HTTP layer can only serve data from SQLite now. What happens if we need to add a caching layer in between? Or how do we support other types of data storage such as Postgres or even storing as JSON on disk?</p>
</blockquote>
<p>마지막으로 SQLite를 추상화하는 계층이 존재하지 않기때문에 모든 HTTP 테스트에서 SQLite 데이터베이스를 구동해야만 합니다. </p>
<blockquote>
<p>Finally, we need to run an SQLite database for every HTTP test since there’s no abstraction layer to mock it out. I generally support doing end-to-end testing as much as you can, but there are valid use cases for introducing unit tests in your higher layers. This is especially true once you introduce cloud services that you wouldn’t want to run on every test invocation.</p>
</blockquote>
<br>

<h3 id="비즈니스-도메인-고립시키기"><a href="#비즈니스-도메인-고립시키기" class="headerlink" title="비즈니스 도메인 고립시키기"></a>비즈니스 도메인 고립시키기</h3><p>우리가 변경할 수 있는 첫번째 사항은 비즈니스 도메인을 그들 자체적인 패키지로 이동시키는 것입니다. 이러한 도메인을 “어플리케이션 도메인”이라고 칭할 수도 있습니다. 이것은 여러분의 어플리케이션에 특화된 데이터 타입입니다.</p>
<blockquote>
<p>The first thing we can change is moving our business domain to its own package. This can also be called the “application domain”. It’s the data types specific to your application—e.g., User, Dial in the case of WTF Dial.</p>
</blockquote>
<p>저는 이러한 목적으로 root 패키지(wtf)를 사용하는데, 이는 이미 제 어플리케이션 이름에 따라 편리하게 네이밍되어있고, 새로운 개발자가 코드 베이스를 열어 볼 때 가장 먼저 보는 곳이기 때문입니다. 이제 데이터 타입의 이름은 wtf.User, wtf.Dial로 위에서 나온 이름보다는 더 적절해 보입니다.</p>
<blockquote>
<p>I use the root package (wtf) for this purpose as it’s already conveniently named after my application, and it’s the first place new developers look when they open the code base. Our types are now named more appropriately as wtf.User and wtf.Dial.</p>
</blockquote>
<div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/figure5.png" alt=""></div>

<p>여러분은 아래 예시에서 wtf.Dial 타입을 볼 수 있습니다:</p>
<blockquote>
<p>You can see an example of this with the wtf.Dial type:</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Dial <span class="keyword">struct</span> {</span><br><span class="line">	ID <span class="keyword">int</span> <span class="string">`json:"id"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Owner of the dial. Only the owner may delete the dial.</span></span><br><span class="line">	UserID <span class="keyword">int</span>   <span class="string">`json:"userID"`</span></span><br><span class="line">	User   *User <span class="string">`json:"user"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Human-readable name of the dial.</span></span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Code used to share the dial with other users.</span></span><br><span class="line">	<span class="comment">// It allows the creation of a shareable link without</span></span><br><span class="line">	<span class="comment">// explicitly inviting users.</span></span><br><span class="line">	InviteCode <span class="keyword">string</span> <span class="string">`json:"inviteCode,omitempty"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Aggregate WTF level for the dial.</span></span><br><span class="line">	Value <span class="keyword">int</span> <span class="string">`json:"value"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Timestamps for dial creation &amp; last update.</span></span><br><span class="line">	CreatedAt time.Time <span class="string">`json:"createdAt"`</span></span><br><span class="line">	UpdatedAt time.Time <span class="string">`json:"updatedAt"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// List of associated members and their contributing WTF level.</span></span><br><span class="line">	<span class="comment">// This is only set when returning a single dial.</span></span><br><span class="line">	Memberships []*DialMembership <span class="string">`json:"memberships,omitempty"`</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>위 코드에서는 세부 구현에 대한 어떠한 참조도 존재하지 않습니다. 단지 Go의 내장 타입들과 time.Time만 존재합니다. JOSN 태그는 편의를 위해 추가했습니다.</p>
<blockquote>
<p>In this code, there is no reference to any implementation details—just primitive types &amp; time.Time. JSON tags are added for convenience.</p>
</blockquote>
<br>

<h3 id="추상화-서비스를-통한-의존성-제거"><a href="#추상화-서비스를-통한-의존성-제거" class="headerlink" title="추상화 서비스를 통한 의존성 제거"></a>추상화 서비스를 통한 의존성 제거</h3><p>어플리케이션의 구조가 조금은 더 나아진것 같아 보이지만 HTTP가 SQLite에 의존적이라는 것은 여전히 어색합니다. 우리의 HTTP 서버는 데이터 저장 공간이 SQLite인지 아닌지는 신경쓰지 않고 데이터를 전달하기를 원합니다.</p>
<blockquote>
<p>Our application structure is looking better, but it’s still odd that HTTP depends on SQLite. Our HTTP server wants to fetch data from an underlying data storage—it doesn’t specifically care if it’s SQLite or not.</p>
</blockquote>
<p>이 부분을 수정하기 위해, 비즈니스 도메인 내에 서비스들을 제공하기 위한 인터페이스를 생성할겁니다. 이 서비스들은 전형적인 CRUD 이지만 또 다른 동작을 수행하도록 확장할 수도 있습니다.</p>
<blockquote>
<p>To fix this, we’ll create interfaces for the services in our business domain. These services are typically Create/Read/Update/Delete (CRUD) but can extend to other operations.</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// DialService represents a service for managing dials.</span></span><br><span class="line"><span class="keyword">type</span> DialService <span class="keyword">interface</span> {</span><br><span class="line">	<span class="comment">// Retrieves a single dial by ID along with associated memberships. Only</span></span><br><span class="line">	<span class="comment">// the dial owner &amp; members can see a dial. Returns ENOTFOUND if dial does</span></span><br><span class="line">	<span class="comment">// not exist or user does not have permission to view it.</span></span><br><span class="line">	FindDialByID(ctx context.Context, id <span class="keyword">int</span>) (*Dial, error)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Retrieves a list of dials based on a filter. Only returns dials that</span></span><br><span class="line">	<span class="comment">// the user owns or is a member of. Also returns a count of total matching</span></span><br><span class="line">	<span class="comment">// dials which may different from the number of returned dials if the</span></span><br><span class="line">	<span class="comment">// "Limit" field is set.</span></span><br><span class="line">	FindDials(ctx context.Context, filter DialFilter) ([]*Dial, <span class="keyword">int</span>, error)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Creates a new dial and assigns the current user as the owner.</span></span><br><span class="line">	<span class="comment">// The owner will automatically be added as a member of the new dial.</span></span><br><span class="line">	CreateDial(ctx context.Context, dial *Dial) error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Updates an existing dial by ID. Only the dial owner can update a dial.</span></span><br><span class="line">	<span class="comment">// Returns the new dial state even if there was an error during update.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Returns ENOTFOUND if dial does not exist. Returns EUNAUTHORIZED if user</span></span><br><span class="line">	<span class="comment">// is not the dial owner.</span></span><br><span class="line">	UpdateDial(ctx context.Context, id <span class="keyword">int</span>, upd DialUpdate) (*Dial, error)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Permanently removes a dial by ID. Only the dial owner may delete a dial.</span></span><br><span class="line">	<span class="comment">// Returns ENOTFOUND if dial does not exist. Returns EUNAUTHORIZED if user</span></span><br><span class="line">	<span class="comment">// is not the dial owner.</span></span><br><span class="line">	DeleteDial(ctx context.Context, id <span class="keyword">int</span>) error</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>이제 우리의 도메인 패키지(wtf)는 데이터 구조뿐만 아니라 계층 간의 커뮤니케이션 방식을 정의한 인터페이스도 구체화되었습니다. 이것은 우리의 패키지 계층 구조를 수평적으로 만들어주었으며 이를 통해 이제 모든 패키지들은 도메인 패키지에 의존하게됩니다. 이것은 패키지간의 직접적인 의존 관계를 깰 수 있도록 해주며 mock 패키지와 같은 부가적인 구현들도 추가할 수 있게 해줍니다.</p>
<blockquote>
<p>Now our domain package (wtf) specifies not just the data structures but also the interface contracts for how our layers can communicate with one another. This flattens our package hierarchy so that all packages now depend on the domain package. This lets us break direct dependencies between packages and introduce alternate implementations such as a mock package.</p>
</blockquote>
<div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/figure6.png" alt=""></div>

<br>

<h3 id="패키지의-재패키지화"><a href="#패키지의-재패키지화" class="headerlink" title="패키지의 재패키지화"></a>패키지의 재패키지화</h3><p>패키지간의 의존성을 깨는것은 우리가 작성한 코드를 유연하게 사용할 수 있도록 해줍니다. 우리의 어플리케이션 바이너리인 wtfd에 대해선 여전히 http 패키지가 sqlite에 의존적이지만 테스트를 위해 http 패키지가 새로운 mock 패키지에 의존하도록 변경할 수 있습니다.</p>
<blockquote>
<p>Breaking the dependency between packages allows us flexibility in how we use our code. For our application binary, wtfd, we still want http to depend on sqlite (see wtf/main.go) but for our tests we can change http to depend on our new mock package (see http/server_test.go):</p>
</blockquote>
<div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/figure7.png" alt=""></div>

<p>이것은 WTF Dial과 같은 작은 웹 어플리케이션에서는 조금 지나친 작업일 수 있으나 우리가 소스 코드를 늘려 나감에 있어서는 점차 중요한 문제가 될 겁니다.</p>
<blockquote>
<p>This may be overkill for our small web application, WTF Dial, but it becomes increasingly important as we grow our codebase.</p>
</blockquote>
<br>

<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>패키지는 Go 언어에서 매우 강력한 도구입니다. 하지만 여러분이 패키지를 계층이 아닌 그룹으로 바라본다면 끝없는 혼란의 원천이기도 합니다. 여러분이 만든 어플리케이션의 논리적인 계층을 이해한 후에 데이터 타입과 비즈니스 도메인을 위한 인터페이스를 추출해낼 수 있으며 이것들을 나머지 모든 서브 패키지들이 참조할 수 있도록 하는 범용적인 도메인 언어를 제공하기 위한 루트 패키지로 옮길 수 있습니다. 도메인 언어를 정의하는 것은 시간이 지남에 따라 여러분의 어플리케이션 규모를 키워나가는데 필수적입니다.</p>
<blockquote>
<p>Packages are a powerful tool in Go but are the source of endless frustration if you view them as groups instead of layers. After understanding the logical layers of your application, you can extract data types &amp; interface contracts for your business domain and move them into your root package to serve as a common domain language for all subpackages. Defining this domain language is essential to growing your application over time.</p>
</blockquote>
<br>
<br>

<span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎

<p><strong>reference</strong></p>
<ul>
<li><a href="https://www.gobeyond.dev/packages-as-layers/">https://www.gobeyond.dev/packages-as-layers/</a></li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>golang</tag>
        <tag>package layer</tag>
        <tag>go layout</tag>
        <tag>organize go code</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake에 대해 알아보자</title>
    <url>/2022/03/05/cmake-tutorial/</url>
    <content><![CDATA[<p><em><strong>뭐하는 놈인지는 알고 쓰자</strong></em> 시리즈의 세번째 주제는 <code>CMake</code>입니다.</p>
<span id="more"></span>

<p>해당 포스팅에서는 <a href="https://cmake.org/cmake/help/v3.22/guide/tutorial/index.html">CMake 공식 홈페이지</a>의 튜토리얼 내용을 번역해보았습니다. <a href="https://github.com/Kitware/CMake">CMake 공식 github</a>에서 제공해주는 프로젝트 폴더 구성과 소스 코드를 참조하여 좀 더 상세히 CMake의 사용법에 대해 알아보는 시간을 갖도록 하겠습니다. (튜토리얼 관련 소스 코드는 <a href="https://github.com/Kitware/CMake/tree/master/Help/guide/tutorial">이곳</a>에서 확인 가능합니다.)</p>
<p>한국어로 된 CMake 관련 설명이 필요하시다면 <a href="https://gist.github.com/luncliff/6e2d4eb7ca29a0afd5b592f72b80cb5c">CMake 할때 쪼오오금 도움이 되는 문서</a>도 굉장히 잘 정리되어있으니 참고하시기 바랍니다.</p>
<br>

<!-- toc -->

<br>

<hr>
<h1 id="CMake-Tutorial"><a href="#CMake-Tutorial" class="headerlink" title="CMake Tutorial"></a>CMake Tutorial</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>CMake 튜토리얼은 일반적인 빌드 시스템 이슈를 처리하기 위한 단계별 가이드를 제공해줍니다. 예시로 제공되는 프로젝트에서 다양한 주제들이 함께 처리되는 방식을 살펴보는 것은 아주 큰 도움이 될 것입니다.</p>
<blockquote>
<p>The CMake tutorial provides a step-by-step guide that covers common build system issues that CMake helps address. Seeing how various topics all work together in an example project can be very helpful.</p>
</blockquote>
<hr>
<h2 id="Step-1-A-Basic-Starting-Point"><a href="#Step-1-A-Basic-Starting-Point" class="headerlink" title="Step 1: A Basic Starting Point"></a>Step 1: A Basic Starting Point</h2><p>가장 기본적인 프로젝트는 소스 코드로부터 빌드되는 실행 파일입니다. 이 간단한 프로젝트에서는 <code>CMakeLists.txt</code> 파일에 단 3줄만이 필요합니다. 이것이 우리의 튜토리얼 시작 지점이 될 것입니다. 아래와 같이 작성된 <code>CMakeLists.txt</code> 파일을 <code>Step1</code> 디렉토리안에 생성해봅시다.</p>
<blockquote>
<p>The most basic project is an executable built from source code files. For simple projects, a three line <code>CMakeLists.txt</code> file is all that is required. This will be the starting point for our tutorial. Create a <code>CMakeLists.txt</code> file in the <code>Step1</code> directory that looks like:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.10)</span><br><span class="line"></span><br><span class="line"># set the project name</span><br><span class="line">project(Tutorial)</span><br><span class="line"></span><br><span class="line"># add the executable</span><br><span class="line">add_executable(Tutorial tutorial.cxx)</span><br></pre></td></tr></table></figure>

<p>이 예제에서는 <code>CMakeLists.txt</code> 파일에 소문자로 이루어진 명령어를 사용한다는 것에 주목하기바랍니다. CMake에서는 대문자, 소문자 그리고 이 둘이 혼합된 명령어를 지원합니다. <code>tutorial.cxx</code>의 소스 코드는 <code>Step1</code> 디렉토리에서 확인가능하며 이 코드는 제곱근을 계산하기 위해 사용될 수 있습니다.</p>
<blockquote>
<p>Note that this example uses lower case commands in the <code>CMakeLists.txt</code> file. Upper, lower, and mixed case commands are supported by CMake. The source code for <code>tutorial.cxx</code> is provided in the <code>Step1</code> directory and can be used to compute the square root of a number.</p>
</blockquote>
<h3 id="Build-and-Run"><a href="#Build-and-Run" class="headerlink" title="Build and Run"></a>Build and Run</h3><p>이것이 필요한 모든것입니다 - 지금 당장에 우리의 프로젝트를 빌드하고 실행할 수 있습니다! 먼저, 프로젝트를 설정하기 위해 <code>cmake</code> 실행 파일 또는 <code>cmake-gui</code> 실행합니다. 그리고나서 여러분이 선택한 빌드 툴을 가지고 빌드합니다.</p>
<blockquote>
<p>That’s all that is needed - we can build and run our project now! First, run the <code>cmake</code> executable or the <code>cmake-gui</code> to configure the project and then build it with your chosen build tool.</p>
</blockquote>
<p>예를 들어, 여러분은 커맨드 라인에서 CMake 소스 코드 트리의 <code>Help/guide/tutorial</code> 경로로 이동할 수 있고 아래 명령어를 입력하여 빌드 디렉토리를 생성할 수 있습니다:</p>
<blockquote>
<p>For example, from the command line we could navigate to the <code>Help/guide/tutorial</code> directory of the CMake source code tree and create a build directory:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir Step1_build</span><br></pre></td></tr></table></figure>

<p>다음으로, 생성한 빌드 디렉토리로 이동한 뒤 프로젝트를 설정하고 네이티브 빌드 시스템을 생성하기 위해 CMake를 실행합니다:</p>
<blockquote>
<p>Next, navigate to the build directory and run CMake to configure the project and generate a native build system:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd Step1_build</span><br><span class="line">cmake ../Step1</span><br></pre></td></tr></table></figure>

<p>그리고나서 실질적으로 프로젝트를 컴파일하고 링크하기 위해 빌드 시스템을 호출합니다:</p>
<blockquote>
<p>Then call that build system to actually compile/link the project:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake --build</span><br></pre></td></tr></table></figure>

<p>마지막으로, 아래 명령어들을 통해 빌드된 <code>Tutorial</code>을 사용해봅시다:</p>
<blockquote>
<p>Finally, try to use the newly built <code>Tutorial</code> with these commands:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tutorial 4294967296</span><br><span class="line">Tutorial 10</span><br><span class="line">Tutorial</span><br></pre></td></tr></table></figure>

<h3 id="Adding-a-Version-Number-and-Configured-Header-File"><a href="#Adding-a-Version-Number-and-Configured-Header-File" class="headerlink" title="Adding a Version Number and Configured Header File"></a>Adding a Version Number and Configured Header File</h3><p>우리가 추가하게 될 첫번째 기능은 우리의 실행 파일과 프로젝트에 버전 번호를 제공하는 것입니다. 버전 번호를 소스 코드 상에 추가하는 것도 하나의 방법이지만 <code>CMakeLists.txt</code>의 사용은 이를 좀 더 유연하게 해줍니다.</p>
<blockquote>
<p>The first feature we will add is to provide our executable and project with a version number. While we could do this exclusively in the source code, using <code>CMakeLists.txt</code> provides more flexibility.</p>
</blockquote>
<p>먼저, 프로젝트의 이름과 버전 번호를 설정하기 위한 명령어인 project()를 사용하기 위해 <code>CMakeLists.txt</code> 파일을 수정합니다.</p>
<blockquote>
<p>First, modify the <code>CMakeLists.txt</code> file to use the project() command to set the project name and version number.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.10)</span><br><span class="line"></span><br><span class="line"># set the project name and version</span><br><span class="line">project(Tutorial VERSION 1.0)</span><br></pre></td></tr></table></figure>

<p>그리고나서, 버전 번호를 소스 코드로 전달하기 위해 헤더 파일을 설정합니다.</p>
<blockquote>
<p>Then, configure a header file to pass the version number to the source code:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">configure_file(TutorialConfig.h.in TutorialConfig.h)</span><br></pre></td></tr></table></figure>

<p>설정된 파일은 바이너리 트리 안에 작성될 것이기때문에 포함 파일을 찾기 위해 경로 리스트에 해당 디렉토리를 추가해주어야합니다. <code>CMakeLists.txt</code> 파일의 끝에 아래 라인을 추가해줍니다.</p>
<blockquote>
<p>Since the configured file will be written into the binary tree, we must add that directory to the list of paths to search for include files. Add the following lines to the end of the <code>CMakeLists.txt</code> file:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target_include_directories(Tutorial PUBLIC &quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;)</span><br></pre></td></tr></table></figure>

<p>여러분이 선호하는 편집기를 사용하여 아래 내용을 포함하고 있는 <code>TutorialConfig.h.in</code> 파일을 소스 디렉토리에 생성해줍시다.</p>
<blockquote>
<p>Using your favorite editor, create <code>TutorialConfig.h.in</code> in the source directory with the following contents:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// the configured options and settings for Tutorial</span><br><span class="line">#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@</span><br><span class="line">#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@</span><br></pre></td></tr></table></figure>

<p>CMake가 이 헤더 파일을 설정하는 동안 <code>@Tutorial_VERSION_MAJOR@</code>와 <code>@Tutorial_VERSION_MINOR@</code> 값은 대체될 것입니다.</p>
<blockquote>
<p>When CMake configures this header file the values for <code>@Tutorial_VERSION_MAJOR@</code> and <code>@Tutorial_VERSION_MINOR@</code> will be replaced.</p>
</blockquote>
<p>다음으로 설정된 헤더 파일인 <code>TutorialConfig.h</code>를 포함하기 위해 <code>tutorial.cxx</code> 파일을 수정합시다.</p>
<blockquote>
<p>Next modify <code>tutorial.cxx</code> to include the configured header file, <code>TutorialConfig.h</code>.</p>
</blockquote>
<p>마지막으로, 아래와 같이 <code>tutorial.cxx</code> 파일을 수정해서 실행 파일의 이름과 버전 번호를 출력해봅시다.</p>
<blockquote>
<p>Finally, let’s print out the executable name and version number by updating <code>tutorial.cxx</code> as follows:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (argc &lt; 2) &#123;</span><br><span class="line">    // report version</span><br><span class="line">    std::cout &lt;&lt; argv[0] &lt;&lt; &quot; Version &quot; &lt;&lt; Tutorial_VERSION_MAJOR &lt;&lt; &quot;.&quot;</span><br><span class="line">              &lt;&lt; Tutorial_VERSION_MINOR &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; number&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Specify-the-C-Standard"><a href="#Specify-the-C-Standard" class="headerlink" title="Specify the C++ Standard"></a>Specify the C++ Standard</h3><p>다음으로 <code>tutorial.cxx</code> 소스 내에 <code>atof</code>를 <code>std::stod</code>로 변경함으로써 C++11 기능을 우리 프로젝트에 추가해봅시다. 동시에 <code>#include &lt;cstdlib&gt;</code> 선언도 제거해줍니다.</p>
<blockquote>
<p>Next let’s add some C++11 features to our project by replacing <code>atof</code> with <code>std::stod</code> in <code>tutorial.cxx</code>. At the same time, remove <code>#include &lt;cstdlib&gt;</code>.</p>
</blockquote>
<p>우리는 올바른 플래그 값을 사용하도록 CMake 코드에 명시적으로 언급할 필요가 있을것입니다. CMake에서 특정 C++ 버전을 지원하도록 하는 가장 쉬운 방법은 CMAKE_CXX_STANDARD 변수를 사용하는 것입니다. 현재 튜토리얼에서는 <code>CMakeLists.txt</code> 파일의 CMAKE_CXX_STANDARD 변수를 <code>11</code>로 설정하고, CMAKE_CXX_STANDARD_REQUIRED 변수를 <code>True</code>로 설정해보겠습니다. <code>CMAKE_CXX_STANDARD</code>는 <code>add_executable</code> 명령어 호출 이전에 선언되어야한다는 것을 잊지말기 바랍니다.</p>
<blockquote>
<p>We will need to explicitly state in the CMake code that it should use the correct flags. The easiest way to enable support for a specific C++ standard in CMake is by using the CMAKE_CXX_STANDARD variable. For this tutorial, set the CMAKE_CXX_STANDARD variable in the <code>CMakeLists.txt</code> file to <code>11</code> and CMAKE_CXX_STANDARD_REQUIRED to <code>True</code>. Make sure to add the <code>CMAKE_CXX_STANDARD</code> declarations above the call to <code>add_executable</code>.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.10)</span><br><span class="line"></span><br><span class="line"># set the project name and version</span><br><span class="line">project(Tutorial VERSION 1.0)</span><br><span class="line"></span><br><span class="line"># specify the C++ standard</span><br><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br><span class="line">set(CMAKE_CXX_STANDARD_REQUIRED True)</span><br></pre></td></tr></table></figure>

<h3 id="Rebuild"><a href="#Rebuild" class="headerlink" title="Rebuild"></a>Rebuild</h3><p>우리의 프로젝트를 다시 빌드해봅시다. 우리는 이미 빌드 디렉토리 생성했고 CMake를 실행했기때문에 빌드 과정으로 건너뛸 수 있습니다:</p>
<blockquote>
<p>Let’s build our project again. We already created a build directory and ran CMake, so we can skip to the build step:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd Step1_build</span><br><span class="line">cmake --build .</span><br></pre></td></tr></table></figure>

<p>이제 이전과 동일한 명령어를 통해 새롭게 빌드된 <code>Tutorial</code>을 실행해볼 수 있습니다.</p>
<blockquote>
<p>Now we can try to use the newly built <code>Tutorial</code> with same commands as before:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tutorial 4294967296</span><br><span class="line">Tutorial 10</span><br><span class="line">Tutorial</span><br></pre></td></tr></table></figure>

<p>인자 없이 실행 파일을 구동 할때 버전 번호가 출력되는지 확인해보시길 바랍니다.</p>
<blockquote>
<p>Check that the version number is now reported when running the executable without any arguments.</p>
</blockquote>
<hr>
<h2 id="Step-2-Adding-a-Library"><a href="#Step-2-Adding-a-Library" class="headerlink" title="Step 2: Adding a Library"></a>Step 2: Adding a Library</h2><p>이제 우리의 프로젝트에 라이브러리를 추가해볼 것입니다. 이 라이브러리는 제곱근 계산을 직접 구현한 내용이 포함되어 있을 것입니다. 해당 라이브러리를 추가한 이후에는 실행 파일이 컴파일러가 제공하는 일반적인 제곱근 함수 대신에 이 라이브러리를 사용할 수 있게됩니다.</p>
<blockquote>
<p>Now we will add a library to our project. This library will contain our own implementation for computing the square root of a number. The executable can then use this library instead of the standard square root function provided by the compiler.</p>
</blockquote>
<p>이번 튜토리얼에서는 해당 라이브러리를 <code>MathFunctions</code>이라는 하위 디렉토리에 포함시킬 것입니다. 이 디렉토리에는 헤더 파일인 <code>MathFunctions.h</code>와 소스 파일인 <code>mysqrt.cxx</code>가 포함되어 있습니다. 소스 파일에는 컴파일러의 sqrt 함수와 유사한 기능을 제공하는 <code>mysqrt</code>라는 함수가 존재합니다.</p>
<blockquote>
<p>For this tutorial we will put the library into a subdirectory called <code>MathFunctions</code>. This directory already contains a header file, <code>MathFunctions.h</code>, and a source file <code>mysqrt.cxx</code>. The source file has one function called <code>mysqrt</code> that provides similar functionality to the compiler’s sqrt function.</p>
</blockquote>
<p><code>MathFunctions</code> 디렉토리의 <code>CMakeLists.txt</code> 파일에 아래와 같이 한 줄을 추가합니다.</p>
<blockquote>
<p>Add the following one line <code>CMakeLists.txt</code> file to the <code>MathFunctions</code> directory:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_library(MathFunctions mysqrt.cxx)</span><br></pre></td></tr></table></figure>

<p>새롭게 추가한 라이브러리를 사용하기 위해 <U>①최상위 <code>CMakeLists.txt</code> 파일에 <strong>add_subdirectory()</strong> 호출을 추가</U>할 것이며, 이 호출을 통해 라이브러리가 빌드될 것 입니다. <U>②실행 파일에 새로운 라이브러리를 추가</U>하고 <code>mysqrt.h</code> <U>③헤더 파일을 참조할 수 있도록 <code>MathFunctions</code>를 포함 디렉토리로 추가</U>합니다. 이제 최상위 <code>CMakeLists.txt</code> 파일의 마지막 몇 개의 라인은 아래와 같아야 합니다:</p>
<blockquote>
<p>To make use of the new library we will add an <strong>add_subdirectory()</strong> call in the top-level <code>CMakeLists.txt</code> file so that the library will get built. We add the new library to the executable, and add <code>MathFunctions</code> as an include directory so that the <code>mysqrt.h</code> header file can be found. The last few lines of the top-level <code>CMakeLists.txt</code> file should now look like:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ① add the MathFunctions library</span><br><span class="line">add_subdirectory(MathFunctions)</span><br><span class="line"></span><br><span class="line"># add the executable</span><br><span class="line">add_executable(Tutorial tutorial.cxx)</span><br><span class="line"></span><br><span class="line"># ② add the new library(= MathFUnction) to the executable</span><br><span class="line">target_link_libraries(Tutorial PUBLIC MathFunctions)</span><br><span class="line"></span><br><span class="line"># ③ add the binary tree to the search path for include files so that we will find TutorialConfig.h</span><br><span class="line">target_include_directories(Tutorial PUBLIC </span><br><span class="line">                           &quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span><br><span class="line">                           &quot;$&#123;PROJECT_SOURCE_DIR&#125;/MathFunctions&quot;</span><br><span class="line">                          )</span><br></pre></td></tr></table></figure>

<p>이번엔 <code>MathFunctions</code> 라이브러리를 옵션화해봅시다. 이번 튜토리얼을 진행하는데 있어서 이 작업이 반드시 필요한 것은 아니지만, 규모가 더 큰 프로젝트들에서 이러한 옵션화 작업은 일반적입니다. 가장 먼저 최상위 <code>CMakeLists.txt</code> 파일에 option을 추가합니다.</p>
<blockquote>
<p>Now let us make the <code>MathFunctions</code> library optional. While for the tutorial there really isn’t any need to do so, for larger projects this is a common occurrence. The first step is to add an option to the top-level <code>CMakeLists.txt</code> file.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">option(USE_MYMATH &quot;Use tutorial provided math implementation&quot; ON)</span><br><span class="line"></span><br><span class="line"># configure a header file to pass some of the CMake settings</span><br><span class="line"># to the source code</span><br><span class="line">configure_file(TutorialConfig.h.in TutorialConfig.h)</span><br></pre></td></tr></table></figure>

<p>이 옵션은 <strong>cmake-gui</strong>와 <strong>ccmake</strong>에서 기본 값인 <code>ON</code>으로 보여지게 될 것이며 이 값은 사용자가 변경할 수 있습니다. 이 설정은 캐시에 저장될 것이기 때문에 사용자는 빌드 디렉토리에서 CMake를 실행할 때마다 이 값을 설정할 필요가 없습니다.</p>
<blockquote>
<p>This option will be displayed in the <strong>cmake-gui</strong> and <strong>ccmake</strong> with a default value of <code>ON</code> that can be changed by the user. This setting will be stored in the cache so that the user does not need to set the value each time they run CMake on a build directory.</p>
</blockquote>
<p>다음 변화는 <code>MathFunctions</code> 라이브러리를 조건에 따라 빌드하고 링킹하도록 만드는 것입니다. 이를 위해 옵션 값을 체크하는 if 구문을 생성할 것입니다. if 블록 내부에 라이브러리를 링크하기 위해 필요한 정보를 저장하고 하위 디렉토리를 튜토리얼 타겟의 포함 디렉토리로 추가하기 위한 list 명령어와 함께  <strong>add_subdirectory()</strong> 명령어를 추가합시다.</p>
<blockquote>
<p>The next change is to make building and linking the <code>MathFunctions</code> library conditional. To do this, we will create an <code>if</code> statement which checks the value of the option. Inside the if block, put the <strong>add_subdirectory()</strong> command from above with some additional list commands to store information needed to link to the library and add the subdirectory as an include directory in the <code>Tutorial</code> target. The end of the top-level <code>CMakeLists.txt</code> file will now look like the following:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(USE_MYMATH)</span><br><span class="line">  add_subdirectory(MathFunctions)</span><br><span class="line">  list(APPEND EXTRA_LIBS MathFunctions)</span><br><span class="line">  list(APPEND EXTRA_INCLUDES &quot;$&#123;PROJECT_SOURCE_DIR&#125;/MathFunctions&quot;)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line"># add the executable</span><br><span class="line">add_executable(Tutorial tutorial.cxx)</span><br><span class="line"></span><br><span class="line">target_link_libraries(Tutorial PUBLIC $&#123;EXTRA_LIBS&#125;)</span><br><span class="line"></span><br><span class="line"># add the binary tree to the search path for include files</span><br><span class="line"># so that we will find TutorialConfig.h</span><br><span class="line">target_include_directories(Tutorial PUBLIC </span><br><span class="line">                           &quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span><br><span class="line">                           $&#123;EXTRA_INCLUDES&#125;</span><br><span class="line">                          )</span><br></pre></td></tr></table></figure>

<p>나중에 실행파일에 링크되는 옵션화된 라이브러리들을 모으기 위해 <code>EXTRA_LIBS</code> 라는 변수를 사용하는 것을 주목하기 바랍니다. <code>EXTRA_INCLUDES</code> 변수는 옵션화된 헤더 파일을 대상으로 이와 유사하게 사용됩니다. 이것은 많은 옵션 컴포넌트들을 처리하기 위한 고전적인 방식이며, 다음 단계에서 현대적인 접근 방식에 대해 살펴볼 것입니다.</p>
<blockquote>
<p>Note the use of the variable <code>EXTRA_LIBS</code> to collect up any optional libraries to later be linked into the executable. The variable <code>EXTRA_INCLUDES</code> is used similarly for optional header files. This is a classic approach when dealing with many optional components, we will cover the modern approach in the next step.</p>
</blockquote>
<p>위 작업에 따른 소스 코드 상의 변경점은 꽤 간단합니다. 먼저, 필요 시에 <code>tutorial.cxx</code>에서 <code>MathFunctions.h</code>를 포함시켜줍니다.</p>
<blockquote>
<p>The corresponding changes to the source code are fairly straightforward. First, in <code>tutorial.cxx</code>, include the <code>MathFunctions.h</code> header if we need it:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef USE_MYMATH</span><br><span class="line">#  include &quot;MathFunctions.h&quot;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>그리고 나서, <code>USE_MYMATH</code>를 제곱근 함수가 사용되는 조건으로 만들어줍니다.</p>
<blockquote>
<p>Then, in the same file, make <code>USE_MYMATH</code> control which square root function is used:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef USE_MYMATH</span><br><span class="line">  const double outputValue = mysqrt(inputValue);</span><br><span class="line">#else</span><br><span class="line">  const double outputValue = sqrt(inputValue);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>이제 소스 코드에서 <code>USE_MYMATH</code> 변수를 요구하고 있기때문에 이 값을 <code>TutorialConfig.h.in</code> 파일에 아래와 같이 추가할 수 있습니다:</p>
<blockquote>
<p>Since the source code now requires <code>USE_MYMATH</code> we can add it to <code>TutorialConfig.h.in</code> with the following line:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#cmakedefine USE_MYMATH</span><br></pre></td></tr></table></figure>

<p>프로젝트를 설정(configure)하기 위해 <strong>cmake</strong> 실행 파일 또는 <strong>cmake-gui</strong>를 실행시키고 여러분의 빌드 도구에 맞게 빌드합니다. 그리고 빌드된 Tutorial 실행 파일을 실행합니다.</p>
<blockquote>
<p>Run the <strong>cmake</strong> executable or the <strong>cmake-gui</strong> to configure the project and then build it with your chosen build tool. Then run the built Tutorial executable.</p>
</blockquote>
<p>이제 <code>USE_MYMATH</code> 값을 업데이트 해봅시다. 가장 쉬운 방법은 <strong>cmake-gui</strong>를 사용하거나 터미널 환경이라면 <strong>ccmake</strong>를 사용하는 것입니다. 또는 command-line의 옵션을 변경하기를 원한다면 아래와 같이 시도해보시기 바랍니다:</p>
<blockquote>
<p>Now let’s update the value of <code>USE_MYMATH</code>. The easiest way is to use the <strong>cmake-gui</strong> or <strong>ccmake</strong> if you’re in the terminal. Or, alternatively, if you want to change the option from the command-line, try:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake ../Step2 -DUSE_MYMATH=OFF</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Step-3-Adding-Usage-Requirements-for-a-Library"><a href="#Step-3-Adding-Usage-Requirements-for-a-Library" class="headerlink" title="Step 3: Adding Usage Requirements for a Library"></a>Step 3: Adding Usage Requirements for a Library</h2><p>사용 요구 사항을 통해 라이브러리 또는 실행 파일의 링크 및 포함 라인을 훨씬 더 잘 제어할 수 있으며 CMake 내 대상의 전이 속성을 더 많이 제어할 수 있습니다. 사용 요구 사항을 활용하는 기본 명령은 다음과 같습니다:</p>
<blockquote>
<p>Usage requirements allow for far better control over a library or executable’s link and include line while also giving more control over the transitive property of targets inside CMake. The primary commands that leverage usage requirements are:</p>
<ul>
<li>target_compile_definitions()</li>
<li>target_compile_options()</li>
<li>target_include_directories()</li>
<li>target_link_libraries()</li>
</ul>
</blockquote>
<p>사용 요구 사항의 현대적인 CMake 접근 방식을 사용하기 위해 앞선 챕터였던 <strong>Adding a Library</strong>에서 사용한 소스 코드를 리팩토링 해보겠습니다. 먼저 <code>MathFunctions</code> 라이브러리를 링킹하고자 한다면 현재 소스 디렉토리를 포함해야하지만 <code>MathFunctions</code> 자체는 포함하지 않습니다. 따라서 이것인 <code>INTERFACE</code> 사용 요구사항이 될 수 있습니다.</p>
<blockquote>
<p>Let’s refactor our code from <strong>Adding a Library</strong> to use the modern CMake approach of usage requirements. We first state that anybody linking to <code>MathFunctions</code> needs to include the current source directory, while <code>MathFunctions</code> itself doesn’t. So this can become an <code>INTERFACE</code> usage requirement.</p>
</blockquote>
<p><code>INTERFACE</code>는 소비자가 필요로 하지만 생산자는 그렇지 않다는 것을 기억하기 바랍니다. <code>MathFunctions/CMakeLists.txt</code> 파일의 끝에 아래 라인을 추가합니다.</p>
<blockquote>
<p>Remember <code>INTERFACE</code> means things that consumers require but the producer doesn’t. Add the following lines to the end of <code>MathFunctions/CMakeLists.txt</code>:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target_include_directories(MathFunctions</span><br><span class="line">          INTERFACE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span><br><span class="line">          )</span><br></pre></td></tr></table></figure>

<p>이제 <code>MathFunctions</code>에 대한 사용 요구 사항을 명시했으므로 최상위 <code>CMakeLists.txt</code>에서 <code>EXTRA_INCLUDES</code>변수 사용을 안전하게 제거할 수 있습니다:</p>
<blockquote>
<p>Now that we’ve specified usage requirements for <code>MathFunctions</code> we can safely remove our uses of the <code>EXTRA_INCLUDES</code> variable from the top-level <code>CMakeLists.txt</code>, here:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(USE_MYMATH)</span><br><span class="line">  add_subdirectory(MathFunctions)</span><br><span class="line">  list(APPEND EXTRA_LIBS MathFunctions)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>And here:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target_include_directories(Tutorial PUBLIC</span><br><span class="line">                           &quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span><br><span class="line">                           )</span><br></pre></td></tr></table></figure>

<p>위와 같이 수정을 완료하였다면 프로젝트를 설정(configure)하기 위해 <strong>cmake</strong> 실행 파일 또는 <strong>cmake-gui</strong>를 실행시키고 여러분의 빌드 도구에 맞게 빌드하거나 빌드 디렉토리에서 <code>cmake --build</code>를 사용하여 빌드합니다.</p>
<blockquote>
<p>Once this is done, run the <strong>cmake</strong> executable or the <strong>cmake-gui</strong> to configure the project and then build it with your chosen build tool or by using <code>cmake --build .</code> from the build directory.</p>
</blockquote>
<br>
<br>

<span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎

<p><strong>reference</strong></p>
<ul>
<li><a href="https://cmake.org/cmake/help/v3.22/guide/tutorial/index.html">https://cmake.org/cmake/help/v3.22/guide/tutorial/index.html</a></li>
<li><a href="https://github.com/Kitware/CMake/tree/master/Help/guide/tutorial">https://github.com/Kitware/CMake/tree/master/Help/guide/tutorial</a></li>
<li><a href="https://gist.github.com/luncliff/6e2d4eb7ca29a0afd5b592f72b80cb5c">https://gist.github.com/luncliff/6e2d4eb7ca29a0afd5b592f72b80cb5c</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>cmake</tag>
        <tag>CMakeFile.txt</tag>
        <tag>CMake tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>(BBC 스포츠) 첼시 루드 굴리트 25년이 지난 지금 그의 프리미어그리 진출을 애정어린 시선으로 되돌아 보다</title>
    <url>/2021/07/10/tr-ruud-gullit/</url>
    <content><![CDATA[<p>피파 좀 한다는 사람이라면 모두가 다 알만한 그 분, X사기캐 굴리트😬<br>커리어 막바지에 첼시에서도 잠깐 활약했었네요.<br><a href="https://www.bbc.com/sport/football/52904670">BBC Sport에 굴리트가 직접 기고한 회고록 느낌의 글</a>을 한번 번역해보았습니다.</p>
<span id="more"></span>

<br>
<br>

<p>By Ruud Gullit MOTD pundit and ex-Chelsea manager<br>04 June 2020 | <a href="https://www.bbc.com/sport/football">Football</a><br><br></p>
<div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/tr_ruud_gullit_picture_1.png" alt="셔츠와 타이위로 첼시 유니폼을 입은 루드 굴리트가 1995년 6월 잉글랜드 축구에 등장한다."><span class="caption">셔츠와 타이위로 첼시 유니폼을 입은 루드 굴리트가 1995년 6월 잉글랜드 축구에 등장한다.</span></div>

<p><strong>저는 작별의 방식에 대해서는 여전히 가슴이 아픕니다. 하지만 저의 첼시에서의 시간은 언제나 가장 행복했던 순간일 겁니다. 저에게 그곳은 천국이었습니다.</strong></p>
<p>제가 잉글랜드에 온지 25년이 흘렀다는 사실은 제가 매우 늙어버렸다는 느낌을 들게합니다. 하지만 때때로 그것은 마치 어제 일처럼 느껴집니다. 값을 매길수 없는 자유와 같은 무언가를 발견했기에 저는 런던과 곧장 사랑에 빠졌습니다. 그곳은 저의 행복한 공간이었고 첼시 선수들은 저의 ‘사랑스러운 동료들’ - 그 이유에 대해 설명하도록 노력해보겠습니다 - 이었습니다.</p>
<hr>
<p>1995년 제가 첼시에 합류했을때, 프리미어 리그는 지금과는 매우 달랐습니다. 저는 이 리그에 온 첫번째 외국인 선수가 아니었지만 세리에 A와 같이 보다 큰 리그에서 온 이름 있는 선수중에는 첫번째 였습니다.</p>
<p>되돌아 보면, 아마도 그때 여름이 프리미어 리그가 지금과 같은 경쟁 체제로 변화하는 시작점이었었고, 그래야만 했습니다. 이탈리아는 그때 당시 최고였습니다. - 최고의 선수들이 그곳에 있었습니다. 이와 비교 했을때 영국 축구는 매우 기초적인 수준이었고 그들의 리그 수준을 유럽 최고 레벨로 되돌리기 위해 타 리그에서 오는 선수들을 확보하길 원했습니다.</p>
<p>데니스 베르캄프, 다비드 지놀라, 주닝요. 그들 모두 저와 비슷한 시기에 프리미어 리그에 왔습니다. 제가 그것을 바라본 방식은 일종의 모험이었습니다. 개인적으로나 직업적으로, 저는 AC 밀란과 삼프도리아에서의 8년간의 생활 후 이탈리아를 떠날 필요가 있었고, 프리미어 리그의 도약과 함께 영국은 새로운 시작을 위해 가장 적합한 장소였으며 새로운 무언갈 하고자하는 저에게 적절한 시간이었습니다.</p>
<p>저는 32살, 거의 33살에 가까운, 이었고 오랜 기간동안 최고의 자리에 있어왔으며 많은 경기에서 승리해왔다. 몇몇 사람들은 저의 기량이 많이 떨어져 있다고 생각했고 단지 돈을 벌고 은퇴를 준비하기 위해 이곳에 왔다고 생각했습니다. 그들은 틀렸습니다.<br><br></p>
<div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/tr_ruud_gullit_picture_2.png" alt="네덜란드의 공격수 베르캄프 또한 1995년에 인터 밀란에서 아스날로 이적하며 프리미어 리그에 합류했다."><span class="caption">네덜란드의 공격수 베르캄프 또한 1995년에 인터 밀란에서 아스날로 이적하며 프리미어 리그에 합류했다.</span></div>

<p>제가 첼시를 선택한 이유에 대해 이해했던 사람은 아무도 없었습니다. 저는 제가 첼시로 갔을때 그 클럽에 대해 심지어는 지역의 일부에 대해 많이 알지 못했다라고 분명하게 이야기 할 수 있습니다. 글렌 호들이 감독으로 있었다는 사실 만으로 제가 그곳에 간 이유를 충분히 설명할 수 있었으니까요.</p>
<p>스탬포트 브릿지를 보기 위해 처음으로 방문했을때, ‘무슨 경기장이 이래?’라는 생각을 했었습니다. 저는 이전에 최고의 경기장들에서 뛰어왔지만 그곳엔 단 2개의 스탠드만이 존재했습니다. 그곳은 단지 건축 부지가 아닌 다 망가져가는 장소 같았습니다. 당신은 나무로된 널빤지 주위를 걸어야만 했을겁니다.</p>
<p>훈련 시설 또한 제가 이전에 사용하던 것들과는 많이 달랐습니다. 오늘날 첼시의 설비는 월드 클래스이지만 그 당시 그들은 할링턴의 한 학교를 기반으로한 시설을 사용했습니다. 그곳엔 아무것도 없었죠. 단지 나무 벤치와 옷걸이 뿐인  다섯개의 작은 라커룸이 있을 뿐이었죠.</p>
<p>하지만 저는 그곳을 사랑했습니다. 그러한 공간은 제가 처음으로 운동을 시작한 9살로 되돌아가는듯한 기분을 주었습니다. 환상적이었죠.</p>
<p>물론 제가 합류했을 시점의 첼시는 타이틀 경쟁이 쉽지 않다는 것을 알고있었습니다. 그당시 그들에게 챔피언스 리그는 없었죠. 그들은 유럽은 커녕 잉글랜드 리그에서 선두권에 있는 팀도 아니었습니다. 하지만 저는 그 클럽이 가고자 하는 곳, 잉글랜드 축구에 일어날 일들에 대해 알고 있었습니다. 그리고 저는 도전을 좋아합니다. 그것은 AC 밀란으로 가기 위해 네덜란드를 떠날때와 같았습니다. 1987년 AC 밀란에 왔을때, 그들은 유로피언 트로피를 14년간 들어올리지 못했습니다. 하지만 제가 그곳을 떠날올때는 2개의 유로피언 컵을 거머쥔 후 였죠.</p>
<p>글렌은 저에게 첼시와 그들의 야망을 납득시켜야 했습니다. 그는 그들 또한 여정의 시작에 있다라고 말했죠. 하지만 무엇 보다 가장 중요했던 것은 글렌이었다는 사실이었습니다. 네덜란드인의 관점에서 그는 최고의 영국 축구선수였지만 영국에서 그는 그리 환영받지 못했습니다. 네덜란드에서 우리는 다음과 같이 이야기 했다. ‘오 하느님, 그는 당신이 아닌 우리의 운명을 타고난 선수였습니다.’</p>
<p>그는 계약 하기 몇 달 전에 저와의 계약을 원한다며 전화를 했습니다. 그리고 저는 그를 스킬이 출중한 선수로서 봐왔기 때문에 그가 롱 볼을 구사하는 감독은 아닐 거라는 확신이 들었습니다. 그것이 저의 첼시로 이적 결정의 가장 중요한 요인이었습니다.</p>
<p>언론에서 저는 다양한 국가의 다양한 팀들과의 링크가 있었습니다. 바이에른 뮌헨이나 갈락타사이가 그러한 팀들이었죠. 그당시에 모나코와 페예노르트, 심지어는 일본의 팀과도 링크가 있었습니다. 하지만 그들 중 어느 팀과도 이야기 한적이 없었고, 1995년 5월 밀란에서 글렌을 만나 계약할 준비를 하였습니다. 첼시, 이곳에 제가 왔습니다.<br><br></p>
<div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/tr_ruud_gullit_picture_3.png" alt="굴리트는 1989년과 1990년에 AC 밀란에서 두번의 유로피언 컵 타이틀을 차지했다."><span class="caption">굴리트는 1989년과 1990년에 AC 밀란에서 두번의 유로피언 컵 타이틀을 차지했다.</span></div>

<p>저는 잉글랜드 리그에서의 경험이 전무했었지만 피지컬적인 능력을 요구하는 리그로서의 명성에 대해서는 잘 알고 있었습니다. 그 당시에, 경기를 뛰는 어느곳에서나, 선수들이 심판으로부터 항상 동일한 보호를 받을 수 있는 것은 아니었습니다.</p>
<p>그래서 제가 첼시 선수로 갖는 첫번째 기자 회견 이후부터 저는 만반의 준비를 위해 열심히 훈련하였습니다.</p>
<p>제가 AC 밀란에 있을때 종종 스포트라이트를 받았었고, 스포트라이트를 받게된다는건 이전보다 더 좋은 기량을 보여 주어야한다는 것을 말합니다. 만약 그렇지 못하면, 비난을 받게 되겠죠. 저는 2번의 올해의 선수상을 받았고, 가능한한 최고의 플레이를 보여주어야 한다는 것이 저의 일관된 태도였습니다. 저는 다시 한번 제 자신을 증명하기를 원했고, 그것을 몸소 실천하기 위해 포르투갈로 떠나 골프 코스 옆에 있는 집을 빌려 그 주변을 뛰며 매일 매일 열심히 훈련했습니다.</p>
<p>몇 주 후 프리 시즌 훈련을 위해 할링턴으로 돌아왔을때, 저는 좋은 폼이었습니다. 제가 처음으로 인지하고, 느꼈던 것은 첼시 선수들이 먹는 음식이었습니다. 그것은 좋은 축구를 하기위해 먹는 음식이 아니었습니다. - 그것은 그레이비와 감자칩이 곁들여진 스테이크와 소시지였고, 모든것이 일종의 튀김류였습니다. 당신은 결코 좋은 축구를 할 수 없을 겁니다.</p>
<p>음식은 이탈리아와 가장 큰 차이 중 하나였고, 또다른 차이는 축구의 스타일이었습니다. 잉글랜드의 축구는 너무 정직했습니다. 지금 현재는 내가 경고해왔던 거친 태클들이 난무하는데 이제 와서 그것에 대해 생각하는것이 참 웃긴일이지만, 그것은 여러분이 그들을 1마일 떨어진 곳에서 볼수있기때문에 문제가 아니었습니다.</p>
<p>세리에A에서의 경험이 있던 저에게는 그것은 예상할 수 있었기에 대응하기 쉬웠습니다. 이탈리에서 그들은 너무나 강하게 밀어붙이는 것 같아보일지라도 그들은 그것에 대해 더 영리하게 대처했습니다. 여러분이 그것을 기대하지 않을때는 아쉬울 것입니다.</p>
<p>물론 제가 잉글랜드로 왔을때 저는 이름이 있는 선수였고 몇몇 선수들은 그들이 저를 타겟으로 삼았을거라고 생각했습니다. 일종의 ‘프리미어리그에 온걸 환영해’ 같은거랄까요. 가장 웃긴 건 우리가 윔블던에서 경기했을때 비니 존스가 그와같이 하려고 노력 했을때입니다.</p>
<p>저는 심지어 게임 전부터 비니가 저를 압살하는 것으로 이름을 떨치길 원하는 것을 알고있었습니다. 그래서 저는 그에 대비했고, 어느 순간엔 그와 같은 상황이 발생할 수 있다는 것을 알고 있었으며, 실제로 발생했죠. 후반전이 시작했을 때, 저는 발목으로 공을 받았고, 그에게 등지고 있었습니다. 하지만 저는 그가 저에게 다가 오고있다는걸 거의 들을 수 있었습니다.</p>
<p>그래서 그가 태클을하는 순간 저는 그라운드에서 살짝 뛰어올랐습니다. 네 맞아요, 그가 저를 잡기를 원했었지만 그가 원하던 방식은 아니었죠.</p>
<p>그때 저는 그라운드에 굴렀고 그는 레드 카드를 받았습니다. - 그는 이미 예약이 되어있었습니다. - 그리고 제가 일어나 그에게 말했습니다: “비니, 이제부터 우리 축구할 수 있겠다.” 그는 쉬지 않고 저에게 욕설을 퍼부었고 다음날 신문에 기사가 났죠. 그는 제가 새끼 돼지 처럼 꽤액 소리를 질렀다라고 이야기했습니다. 하지만 저는 ‘글쎄, 거기서 나는 너를 잡았지. 내가 너를 잡았지’라고 생각했죠.<br><br></p>
<div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/tr_ruud_gullit_picture_4.png" alt="1996년 3월 셀허스트 파크에서 열린 진흙탕속 FA 6라운드 재경기에서 비니 존스가 굴리트에게 도전하고 있다."><span class="caption">1996년 3월 셀허스트 파크에서 열린 진흙탕속 FA 6라운드 재경기에서 비니 존스가 굴리트에게 도전하고 있다.</span></div>

<p>재밌는 사실은 그 이후로 우리가 친구가 되었다는 겁니다. 그리고 우리는 그 날일에 대해 대해 웃으며 이야기했습니다. 하지만 그것은 몇몇 외국 선수가 프리미어 리그로 왔을때 느낄 수 있는 장벽의 예시이며 저에게는 문제가 되지 않았습니다. 저는 이탈리에서 많은 것을 배웠고, 제가 하고자하는 원래의 계획이 꽤 들어 맞지 않더라도 그것은 저에게 다양한 방식으로 잉글랜드에서의 이점을 제공했습니다.</p>
<hr>
<p>처음으로 첼시에서 스위퍼 역할로 뛰길 제안한 사람이 글렌은 아니었습니다. - 가능하다면 이탈리아에서 처럼 공격형 미드필더가 아닌 스위퍼 역할로 뛰고 싶다라고 말한것은 저였습니다. 저는 수비쪽 포지션으로서의 저의 커리어를 시작하고자 했고, 그것은 제가 사랑한 역할이었습니다.</p>
<p>하지만 저는 프리미어 리그에서 그 포지션에서 뛰는 수많은 선수중 하나였고, 문제는 그 당시의 방식이었습니다. 페널티 박스 안에서 긴 볼이 넘어왔을때, 저는 그 볼을 제 가슴에 내려 두고나서 거기서 부터 플레이하려고 했습니다. 글렌은 다음과 같이 이야기했습니다: “루디, 아니 아니. 뭘 하려는지는 이해하겠는데 너는 우리팀 수비수들을 그와 같이 곤란한 상황에 빠지게 하고있어.”</p>
<p>요즘은 그것이 효과적으로 보입니다. - 얼마나 많은 프리미어 리그 팀들이 수비수들로부터 플레이를 시작해나가는지 보세요. 그때 당시에 수비수들은 항상 헤딩을 하거나 가능한한 멀리 볼을 클리어링했습니다. 그리고 저는 후방에서 그들 주위로 패스 하길 원했습니다. 그들은 그와 같은 패스를 원치않았고, 그래서 글렌은 아니라고 말했던 겁니다. 그리고 그는 저에게 조금 더 앞쪽으로 포지션을 이동하는 것이 어떻겠냐고 제안했습니다.</p>
<p>저는 변화가 만들어진 게임을 기억하진 않지만 나의 동료였던 가빈 피콕은 기억에 남습니다. 그는 제가 미드필더로 뛰었던 시기에 저에게 다가와 이렇게 말했습니다. “루드, 넌 어떻게 항상 공간을 만들어 내는거야?” 그것은 단지 경험에서 나오는 것이었기때문에 그에게 명확히 설명할 수 없었습니다. - 당신은 단지 특정 상황에서 볼이 어떻게 흘러 나오는지를 배우면됩니다. 그리고 당신이 특정한 곳에 머무르고 있다면 공간이 생길 것입니다. 세리에A에서 보다 영국에서 그러한 공간 창출의 기회가 더 많았던것 같습니다.</p>
<p>그리운드 밖에서 저는 더 많은 자유로움을 느꼈습니다. 이탈리에서 지냈던 시간내내 모든것이 너무나 치열했습니다. 특히 밀란에서 저를 취재하려는 수많은 기자들 떄문에 외출하는 것이 매우 어려웠습니다. 하지만 이곳에선 저를 쫓아다니거나 저에게 무언갈 원하는 사람이 없습니다. 저는 다시 한번 숨통을 틔울수 있었습니다.</p>
<p>밀란과 삼프도리아에서 저는 매 경기 이전에 트레이닝 캠프에 참여하곤했습니다. 상상이 되시나요? 지금은 대부분의 날에 하나의 훈련 세션만 있을뿐이고, 심지어 일요일은 쉬죠. 그렇기에 저는 사람들을 만나며 이곳 저곳을 돌아 다닐 수 있었습니다. 일상 생활이 있었던거죠.<br><br></p>
<div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/tr_ruud_gullit_picture_5.png" alt="첼시의 95-96시즌 동안 굴리트는 스위퍼, 미드필더 또느 공격수로 경기에 참여했다."><span class="caption">첼시의 95-96시즌 동안 굴리트는 스위퍼, 미드필더 또느 공격수로 경기에 참여했다.</span></div>

<p>처음에 저는 호텔에만 머물렀습니다. - 저는 심지어 이곳이 어딘지도 몰랐습니다. 도심내에 있는 것도 아니었고 공항 근처였습니다. 런던 중심가로 드라이브하기로 결심했던 기억이 있습니다. 런던은 운전석과 방향이 정반대였기때문에 드라이브를 한다는 것은 매우 어려운 일이었습니다. 매우 복잡하기도 했구요. 하지만 피카딜리 서커스로 드라이브를 갔을때, 제 스스로에게 이렇게 말했습니다. ‘이곳은 나를 위한 곳이다.’ 역시나 제 생각이 맞았습니다.</p>
<hr>
<p>영국 축구가 이탈리아와 다른 또 하나의 무언가가 있었고 그것은 긍정적이었습니다. - 관중, 그리고 관중석에서의 태도입니다. 저는 첼시 팬들뿐만 아니라 관중들과 다른 형태의 유대감을 느꼈습니다. 프리미어 리그에서, 그들은 선수들이 보여주는 플레이에 더욱 환호합니다. - 만약 당신이 그라운드위에서 특별한 무언가를 보여준다면, 관중들은 열광할겁니다. 물론 이탈리아에서도 관중들은 열정적이었고, 경기장은 늘 가득찼지만 그들은 대다수의 선수들이 동일한 방식으로는 결코 반응하지않는 것들을 보는것에 익숙했습니다.</p>
<p>저는 곧장 첼시팬들과 함께할 수 있었습니다. 첼시에서의 첫번째 경기에 드레드락 가발을 쓴 그들을 기억합니다. 첼시의 서포터들은 언제나 환상적이었고 심지어 제가 첼시를 떠날때에도 그러했습니다. 그들은 지금도 여전합니다. 저는 그들을 사랑하고 그들이 저와 함께한 방식을 사랑합니다. 그들은 저에게 언제나 보물과 같은 것일겁니다.</p>
<p>첼시 선수들과 친구를 만드는 일 또한 그리 오래 걸리지 않았습니다. 저는 첼시에서의 생활을 시작한 순간부터 그들을 항상 ‘사랑스런 아이들’ 이라 불렀습니다. 왜 ‘사랑스런 아이들’이라고 했을까요? 글쎄요, 저는 영국의 TV 쇼인 ‘It Ain’t Half Hot, Mum’의 광팬이었고, ‘사랑스런 아이들’이라는 단어는 그 프로에서 부대선임하사관으로 출현하는 윈져 데이비스가 그의 부대원에게 사용했던 말이었습니다.</p>
<p>제가 첼시에 합류했을때, 첼시 선수들은 제가 영국의 유머를 좋아한다는 것에 대해 놀라웠했다고 생각했습니다. - Mr Cool이 되고자 했습니다. - 하지만 저는 1907년대 네덜란드 TV에서 방영하는 이러한 프로그램들을 보며 자라왔습니다. 그래서 라커룸에서 프랭크 스펜서나 ‘Fawlty Towers’, ‘Are You Being Served’, ‘George and Mildred’ 에대해 이야기했습니다. 저는 그 모든걸 사랑했었죠.</p>
<p>그것은 제가 적응 하도록 도와주웠습니다. 네덜란드의 락커룸에서는 모두가 그를 최고라고 알고 있으며 그렇게 이야기합니다. 이탈리아에서도 마찬가지였이만 감독에게 이야기하는 것은 두려워했습니다. 그당시 영국에서는 모두가 웃기를 원했습니다.</p>
<p>하지만 그것이 저의 새로운 팀 동료들과 잘 지낼 수 있었던 유일한 이유는 아니었습니다. 제가 적응하길 원했기에 그러한 원만한 관계가 이뤄졌습니다. 지금까지도 축구의 그 부분은 변하지 않고 있습니다. - 당신이 새로운 클럽 혹은 새로운 국가로 이적할때, 무엇보다도 언어를 먼저 이해해야하며, 그리고나서 사람들과 함께 시간을 보낸다면 당신은 얼마지나지않아 서로를 이해하게 될 겁니다.</p>
<p>그래서 첼시에서 저는 그들 모두와 함께 레스토랑이나 콘서트에서 시간을 보냈고, 골프도 치곤했습니다. 아주 많이요. 저는 사실상 첼시에서의 이야기가 끝난 후에도 이와 같이 지냈습니다. 이탈리아에서 그러했던것 처럼, 잉글랜드에서의 생활을 통해 많은 걸 배웠습니다. 그곳에서의 대부분의 경험들은 긍정적이었지만, 한가지 사건은 분명히 그렇지 못했습니다.</p>
<hr>
<p>저는 첼시로 이적하고나서 1년 후 선수겸 감독이 되었습니다. 1996년 글렌 호들이 잉글랜드 국가대표 감독으로 부임하며 첼시를 떠났을때였죠. 저는 잔플랑코 졸라, 잔루카 비알리, 로베르토 디 마테오, 프랑크 르뵈프를 영입했습니다. 1997년 FA컵에서 우승을 차지했고, 1998년 2월 프리미어 리그에서 2위에 올라있었으며 유러피언 컵 위너스 컵 8강에 진출한 상태였습니다. 저는 PSV 아인트 호벤의 야프 스탐과 레인저스의 브리안 라우드루프와 협상중에 있었죠.</p>
<p>경질되기 전날, 저는 제 코치 중 한명이었던 그윈 윌리엄스와 2명의 첼시 선수 플랑코 졸라, 케빈 히치콕과 골프를 치고있었습니다. 저는 라우드루프와 접촉하기 위해 노력했으나 결국엔 성사되지 못했습니다.</p>
<p>저의 가장 가까웠던 친구이자 저를 가장 많이 도왔던 그윈은 무슨일이 일어날지 정확히 알고있었으며 그들이 저를 해고할 생각이었다는것 또한 알고있었습니다. 그는 저를 떨어뜨려놓기 위해 저와 골프를 치고있었고, 제가 라우드루프가 있는 곳에는 가지 않았다는것을 확실히 했습니다.</p>
<p>경질을 당하는 것은 끔찍한 경험이었고 그들이 그렇게 한것에 대한 이유는 없었습니다. 그들은 나의 계약 요구 사항이 지나쳤다고 했지만 그건 말도안되는 소리입니다. 그들은 저와의 어떠한 협상도 하지 않았기 때문입니다. 어찌됐든 그들은 저를 해고 할 계획이었던 거죠. 하지만 최악의 일은 그윈이 저에게 했던 짓입니다. - 저는 모든 시간을 함께한 누군가에게 그와같이 행동한다는 것을 이해하지 못했습니다. 그는 구체적인 사항에 대해서는 어떠한것도 이야기할 필요가 없었고, 무언가가 일어날 수 있기때문에 조심하라고만 이야기했습니다.</p>
<p>이 일은 저의 커리어와 삶을 통틀어 누군가가 저에게 했던 일 중 최악의 것이었습니다. 그것은 누군가가 저에게 줄 수 있는 가장 큰 실망이었으며 저는 그것에 대해서는 그를 절대 용서할 수 없습니다. 정말이지 그럴수 없습니다.</p>
<p>하지만 다른 모든 것들은 다 잊었습니다. 경질 당한것에 대해 아직까지 화가 나냐구요? 아닙니다. 저는 이미 오래전에 그것을 받아들였고, 이겨냈습니다. 잉글랜드로 온것이 기쁘냐구요? 물론이죠.</p>
<p>그것은 저를 더 나은 사람으로 만들었고, 뉴캐슬 감독으로 있었을때도 저는 같은 것을 이야기 하곤 했습니다. 제가 이곳에 왔을때 잉글랜드에서의 삶은 저의 경험을 풍부하게 하고 축구에 대한 저의 생각을 향상시킨다라고 느꼈습니다. 여전히 저는 그와 같이 느낍니다.<br><br></p>
<div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/tr_ruud_gullit_picture_6.png" alt="1997년 웸블리에서 열린 FA컵 결승에서 첼시는 미들즈브러를 상대로 2대0으로 승리했다."><span class="caption">1997년 웸블리에서 열린 FA컵 결승에서 첼시는 미들즈브러를 상대로 2대0으로 승리했다.</span></div>

<p>제가 가장 좋아하는 순간은 FA컵에서 우승했을때입니다. AC 밀란 최초로 유로피언 컵에서 우승했을때도 믿을 수 없었지만 솔직히 말하면 그때의 순간과 마찬가지로 잊을 수 없죠. 트로피를 들어올린다는 측면에서 저는 첼시라는 새로운 클럽의 새로운 감독이었습니다. 우승할 거라고는 생각지 못했지만 갑작스레 일어났고, 그것은 놀라운 시간이었습니다.</p>
<p>첼시의 시작에 제가 있었다는것이 또한 프리미어 리그가 이루어나갈 일들을 보았다는 것이 매우 자랑스럽습니다. 첼시와 프리미어 리그 모두 엄청난 발전을 이루었고, 그들은 이제 완전히 달라졌습니다. 하지만 그들은 어딘선가 시작해야 했습니다.</p>
<p>제가 왔을때 그것은 잉글랜드 축구를 위한 새로운 방향의 일부였고, 코로나 바이러스 팬더믹으로 인해 오늘날도 그때와 비슷한 상황일지 모릅니다. 이것은 사람들의 주의를 촉구하는 일이 되어야만 하고 모든 클럽들은 그들 스스로를 다른 방식으로 관리하는것에 생각해야만 합니다.</p>
<p>제가 보았을때 영국 축구의 문제는 너무나 많은 돈을 버는 선수들이 있고, 그렇게 할만큼 좋은 선수가 없다는 것입니다. 위대한 스타 선수가 큰 돈을 번다면 그것은 괜찮습니다. 하지만 저는 그것에 가까이 가지 못하는 선수들을 보고있습니다.</p>
<p>자본은 프리미어 리그를 좋은 방향으로 바꾸었지만, 경쟁에 있어 이와 같은 일시적인 문제들이 다시 발생한다면 그들이 지금과 같은 클럽 운영과 지출을 지속할 경우에  대다수의 클럽들이 파산할 것입니다. 그들은 주의를 기울여야하며 그들의 모델을 다시 한번 변화시켜야할지 모릅니다.<br><br><br><br></p>
<span class="highlight-text yellow">번역 과정에서 발생하는 오역 및 의역에 대한 정정 댓글 격하게 환영합니다</span>😎
<p>원문 링크: <a href="https://www.bbc.com/sport/football/52904670">Chelsea: Ruud Gullit looks back fondly on his Premier League arrival, 25 years on</a></p>
]]></content>
      <categories>
        <category>해축기사번역</category>
      </categories>
      <tags>
        <tag>gullit</tag>
        <tag>굴리트</tag>
        <tag>첼시 굴리트</tag>
      </tags>
  </entry>
  <entry>
    <title>UTF-8(Unicode Transformation Format - 8bit) 요약 정리</title>
    <url>/2023/01/30/unicode-encoding-utf8/</url>
    <content><![CDATA[<p><escape><span id="more"></span></escape></p>
<p>유니코드는 전 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 산업 표준이며, 현존하는 문자 인코딩 방법들을 모두 유니코드로 교체하려는 것에 목적이 있습니다.</p>
<p>유니코드 영역 목록은 아래 링크를 참조</p>
<ul>
<li><a href="https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C_%EC%98%81%EC%97%AD">https://ko.wikipedia.org/wiki/유니코드_영역</a></li>
</ul>
<p>유니코드 인코딩 방식 중 하나가 UTF-8이며, 가변 길이 문자 인코딩 방식으로 1바이트를 기준으로 인코딩합니다. (한 글자가 1~4바이트 중 하나로 인코딩됨)</p>
<p><strong>인코딩 규칙</strong></p>
<ul>
<li>UTF-8 2-byte Characters<ul>
<li>첫 번째 byte = 0xc0 ~ 0xdf</li>
<li>두 번째 byte = 0x80 ~ 0xbf</li>
</ul>
</li>
<li>UTF-8 3-byte Characters<ul>
<li>첫 번째 byte = 0xe0 ~ 0xef</li>
<li>두 번째 byte = 0x80 ~ 0xbf</li>
<li>세 번째 byte = 0x80 ~ 0xbf</li>
</ul>
</li>
<li>UTF-8 4-byte Characters<ul>
<li>첫 번째 byte = 0xf0 ~ 0xf7</li>
<li>두 번째 byte = 0x80 ~ 0xbf</li>
<li>세 번째 byte = 0x80 ~ 0xbf</li>
<li>네 번째 byte = 0x80 ~ 0xbf</li>
</ul>
</li>
</ul>
<br>

<p><strong>Reference</strong></p>
<ul>
<li><a href="https://design215.com/toolbox/ascii-utf8.php">https://design215.com/toolbox/ascii-utf8.php</a></li>
<li><a href="https://design215.com/toolbox/utf8-3byte-characters.php">https://design215.com/toolbox/utf8-3byte-characters.php</a></li>
<li><a href="https://design215.com/toolbox/utf8-4byte-characters.php">https://design215.com/toolbox/utf8-4byte-characters.php</a></li>
</ul>
]]></content>
      <categories>
        <category>인코딩</category>
      </categories>
      <tags>
        <tag>UTF8</tag>
        <tag>Unicode</tag>
      </tags>
  </entry>
  <entry>
    <title>어떠한 방식으로 Go 코드를 구조화해야 하는가?</title>
    <url>/2022/09/06/translate-standard-package-layout-in-go/</url>
    <content><![CDATA[<p>최근 회사에서 Go 언어를 활용하여 신규 프로젝트를 진행할 기회가 생겼는데 추후 코드의 유지 관리를 고려해볼 때 Go 언어의 소스 코드 구조를 어떤 식으로 해야 하는가에 대해 고민이 생겼습니다.</p>
<span id="more"></span>

<p>구글링 중에 Go 언어의 코드 구조화에 관한 좋은 글을 발견하여 실제 프로젝트에도 반영해볼 겸 해서 번역해보았습니다. 역시나 저와 같은 고민을 앞서 해주신 선구자님들이 계시더라고요😁.</p>
<p>원문의 일부 내용은 번역에서 제외했으니 원문을 참고하실 분들은 <a href="https://www.gobeyond.dev/standard-package-layout/">해당 링크</a>를 확인해주시기 바랍니다.</p>
<br>

<!-- toc -->

<br>

<h1 id="표준-패키지-레이아웃"><a href="#표준-패키지-레이아웃" class="headerlink" title="표준 패키지 레이아웃"></a>표준 패키지 레이아웃</h1><p>Vendoring. Generics. 이것들은 Go 커뮤니티 내에서 큰 이슈들로 보입니다. 하지만 좀 처럼 언급되지 않는 또 다른 이슈가 하나 있습니다 - 바로 어플리케이션 패키지 레이아웃 입니다.</p>
<blockquote>
<p>Vendoring. Generics. These are seen as big issues in the Go community but there’s another issue that’s rarely mentioned — application package layout.</p>
</blockquote>
<p>제가 지금까지 작업해왔던 모든 Go 어플리케이션은 “내 코드를 어떤 방식으로 구조화해야하는가?”라는 질문에 대한 각기 다른 대답을 가지고 있는것 처럼 보입니다. 몇몇 어플리케이션은 하나의 패키지에 모든 것을 밀어 넣기도하고 또 다른 어플리케이션은 타입이나 모듈 단위로 그룹화하기도 합니다. 여러분의 팀 전반에 걸쳐 적용할 만한 좋은 전략이 없다면, 여러분의 어플리케이션의 다양한 패키지들에 곳곳에 코드가 흩뿌려지게 되는 것을 보게 될 것입니다. 우리는 Go 어플리케이션 디자인에 적용할 수 있는 더나은 표준이 필요합니다.</p>
<blockquote>
<p>Every Go application I’ve ever worked on appears to have a different answer to the question, how should I organize my code? Some applications push everything into one package while others group by type or module. Without a good strategy applied across your team, you’ll find code scattered across various packages of your application. We need a better standard for Go application design.</p>
</blockquote>
<p>저는 더 나은 접근 방식을 제안하고자 합니다. 몇가지 단순한 규칙들을 따름으로써 우리는 코드를 분리시키고 테스트를 용이하게 만들며 프로젝트에 일관된 구조를 가지고 올 수 있게됩니다.</p>
<blockquote>
<p>I suggest a better approach. By following a few simple rules we can decouple our code, make it easier to test, and bring a consistent structure to our project.</p>
</blockquote>
<br>

<h2 id="1-기본-패키지는-도메인-타입을-위한-패키지다"><a href="#1-기본-패키지는-도메인-타입을-위한-패키지다" class="headerlink" title="#1. 기본 패키지는 도메인 타입을 위한 패키지다"></a>#1. 기본 패키지는 도메인 타입을 위한 패키지다</h2><p>여러분의 어플리케이션은 데이터와 프로세스들이 어떠한 방식으로 상호작용하는지를 기술하는 논리적이고 고수준(사람이 이해하기 쉽게 작성된 프로그래밍 언어를 의미함)인 언어를 가지고 있습니다. 만약 여러분이 e커머스 어플리케이션을 개발 중이라면 여러분의 도메인은 고객, 계정, 신용카드 결제, 재고 관리와 같은 것들을 포함하고 있을것입니다. 만약 여러분이 페이스북을 개발하고 있다면 여러분의 도메인은 사용자, 좋아요, &amp; relationships(?)이 될것 입니다. 이러한 도메인은 여러분의 근본적인 기술과는 독립적인 개념입니다.</p>
<blockquote>
<p>Your application has a logical, high-level language that describes how data and processes interact. This is your domain. If you have an e-commerce application your domain involves things like customers, accounts, charging credit cards, and handling inventory. If you’re Facebook then your domain is users, likes, &amp; relationships. It’s the stuff that doesn’t depend on your underlying technology.</p>
</blockquote>
<p>저는 도메인 타입을 프로젝트의 기본(root) 패키지에 위치시킵니다. 기본 패키지는 사용자 정보를 저장하는 User 구조체나 사용자 정보를 가지고 오거나 저장하기 위해서 사용하는 UserService 인터페이스와 같은 단순한 데이터 타입들만을 포함하고 있습니다.</p>
<blockquote>
<p>I place my domain types in my root package. This package only contains simple data types like a User struct for holding user data or a UserService interface for fetching or saving user data.</p>
</blockquote>
<p>기본 패키지는 아래와 같은 구조를 보일 수 있을겁니다:</p>
<blockquote>
<p>It may look something like:</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> myapp</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">	ID      <span class="keyword">int</span></span><br><span class="line">	Name    <span class="keyword">string</span></span><br><span class="line">	Address Address</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserService <span class="keyword">interface</span> {</span><br><span class="line">	User(id <span class="keyword">int</span>) (*User, error)</span><br><span class="line">	Users() ([]*User, error)</span><br><span class="line">	CreateUser(u *User) error</span><br><span class="line">	DeleteUser(id <span class="keyword">int</span>) error</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>이것은 여러분의 기본 패키지를 매우 단순하게 만들어 줍니다. 또한 여러분은 다른 도메인 타입에 의존하는 경우에만 동작을 수행하도록 하는 타입들을 포함할 수도 있습니다. 예를 들어, 여러분이 UserService를 주기적으로 폴링(polling)하는 특정 타입을 포함시켜야할 수 있습니다. 그러나 외부 서비스를 호출하거나 데이터베이스에 저장해서는 안됩니다. 그것은 세부적인 구현 사항입니다.</p>
<blockquote>
<p>This makes your root package extremely simple. You may also include types that perform actions but only if they solely depend on other domain types. For example, you could have a type that polls your UserService periodically. However, it should not call out to external services or save to a database. That is an implementation detail.</p>
</blockquote>
<p><em>기본 패키지는 여러분의 어플리케이션에 존재하는 어떠한 다른 패키지에도 의존적이어선 안됩니다!</em></p>
<blockquote>
<p><em>The root package should not depend on any other package in your application!</em></p>
</blockquote>
<br>

<h2 id="2-의존성에-따라-하위패키지를-그룹화하라"><a href="#2-의존성에-따라-하위패키지를-그룹화하라" class="headerlink" title="#2. 의존성에 따라 하위패키지를 그룹화하라"></a>#2. 의존성에 따라 하위패키지를 그룹화하라</h2><p>만약 기본 패키지가 외부 의존성을 허용하지 않는다면 이러한 의존성들을 하위패키지에 추가해주어야 합니다. 이러한 접근 방식에서는 하위패키지가 도메인과 구현(implementation)사이의 어댑터로서 존재하게 됩니다.</p>
<blockquote>
<p>If your root package is not allowed to have external dependencies then we must push those dependencies to subpackages. In this approach to package layout, subpackages exist as an adapter between your domain and your implementation.</p>
</blockquote>
<p>예를 들어, 여러분의 UserService가 PostgreSQL을 지원해야할 수 있습니다. 이때 여러분은 postgres.UserService에 대한 세부 구현을 제공하는 postgres 하위패키지를 추가할 수 있습니다:</p>
<blockquote>
<p>For example, your UserService might be backed by PostgreSQL. You can introduce a postgres subpackage in your application that provides a postgres.UserService implementation:</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> postgres</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"database/sql"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/benbjohnson/myapp"</span></span><br><span class="line">	_ <span class="string">"github.com/lib/pq"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserService represents a PostgreSQL implementation of myapp.UserService.</span></span><br><span class="line"><span class="keyword">type</span> UserService <span class="keyword">struct</span> {</span><br><span class="line">	DB *sql.DB</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// User returns a user for a given id.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *UserService)</span> <span class="title">User</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="params">(*myapp.User, error)</span></span> {</span><br><span class="line">	<span class="keyword">var</span> u myapp.User</span><br><span class="line">	row := db.QueryRow(<span class="string">`SELECT id, name FROM users WHERE id = $1`</span>, id)</span><br><span class="line">	<span class="keyword">if</span> row.Scan(&amp;u.ID, &amp;u.Name); err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> &amp;u, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// implement remaining myapp.UserService interface...</span></span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>이것은 PostgreSQL 의존성을 분리하게되는데 이러한 의존성의 분리는 테스트 과정을 단순화시켜주고 추후 또 다른 데이터베이스로 마이그레이션하기 위한 쉬운 방식을 제공합니다. 여러분이 BoltDB와 같은 또 다른 데이터베이스에 대한 세부 구현을 지원하기로 결정했다면 이것은 플러그형 구조로 사용될 수 있습니다.</p>
<blockquote>
<p>This isolates our PostgreSQL dependency which simplifies testing and provides an easy way to migrate to another database in the future. It can be used as a pluggable architecture if you decide to support other database implementations such as BoltDB.</p>
</blockquote>
<p>이것은 또한 구현을 계층화하는 방법을 제공합니다. 아마도 여러분은 PostgreSQL 앞에 LRU 캐시를 두어 데이터를 메모상에 보관하기를 원할 것입니다. 이를 위해 PostgreSQL 세부 구현을 래핑(wrapping)할 수 있는 UserService를 구현하는 UserCache를 추가할 수 있습니다.</p>
<blockquote>
<p>It also gives you a way to layer implementations. Perhaps you want to hold an in-memory, LRU cache in front of PostgreSQL. You can add a UserCache that implements UserService which can wrap your PostgreSQL implementation:</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> myapp</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserCache wraps a UserService to provide an in-memory cache.</span></span><br><span class="line"><span class="keyword">type</span> UserCache <span class="keyword">struct</span> {</span><br><span class="line">		cache   <span class="keyword">map</span>[<span class="keyword">int</span>]*User</span><br><span class="line">		service UserService</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewUserCache returns a new read-through cache for service.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUserCache</span><span class="params">(service UserService)</span> *<span class="title">UserCache</span></span> {</span><br><span class="line">		<span class="keyword">return</span> &amp;UserCache{</span><br><span class="line">				cache: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*User),</span><br><span class="line">				service: service,</span><br><span class="line">		}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// User returns a user for a given id.</span></span><br><span class="line"><span class="comment">// Returns the cached instance if available.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *UserCache)</span> <span class="title">User</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="params">(*User, error)</span></span> {</span><br><span class="line">	<span class="comment">// Check the local cache first.</span></span><br><span class="line">		<span class="keyword">if</span> u := c.cache[id]; u != <span class="literal">nil</span> {</span><br><span class="line">				<span class="keyword">return</span> u, <span class="literal">nil</span></span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Otherwise fetch from the underlying service.</span></span><br><span class="line">		u, err := c.service.User(id)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		} <span class="keyword">else</span> <span class="keyword">if</span> u != <span class="literal">nil</span> {</span><br><span class="line">			c.cache[id] = u</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> u, err</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>Golang의 기본 라이브러리들에서도 이러한 접근 방식을 살펴볼 수 있습니다. io.Reader는 바이트를 읽어들이기 위한 도메인 타입이고 그것의 세부 구현들은 의존성에 의해 그룹화되어 있습니다 - tar.Reader, gzip.Reader, multipart.Reader. 이것들 또한 계층화될 수 있습니다. os.File은 bufio.Reader에 의해 래핑되어있고 이 bufio.Reader는 gzip.Reader에 의해 래핑되어있으며 gzip.Reader는 tar.Reader에 의해 래핑되어있는 이러한 모습들은 흔히 보이는 계층 구조들입니다.</p>
<blockquote>
<p>We see this approach in the standard library too. The io.Reader is a domain type for reading bytes and its implementations are grouped by dependency — tar.Reader, gzip.Reader, multipart.Reader. These can be layered as well. It’s common to see an os.File wrapped by a bufio.Reader which is wrapped by a gzip.Reader which is wrapped by a tar.Reader.</p>
</blockquote>
<br>

<h3 id="의존성-간의-의존성"><a href="#의존성-간의-의존성" class="headerlink" title="의존성 간의 의존성"></a>의존성 간의 의존성</h3><p>여러분의 의존성은 홀로 고립된 채로 살아갈 수 없습니다. User 데이터는 PostgreSQL에 저장을 하고 재무와 관련된 트랜잭션 데이터는 Stripe와 같은 3rd party 서비스에 저장해야하는 경우가 생길 수 있습니다. 이러한 경우에는 Stripe가 논리적인 도메인 타입과 함께 묶이게 됩니다 - 이것을 TranscationService라고 부르기로 하겠습니다.</p>
<blockquote>
<p>Your dependencies don’t live in isolation. You may store User data in PostgreSQL but your financial transaction data exists in a third party service like Stripe. In this case we wrap our Stripe dependency with a logical domain type — let’s call it TransactionService.</p>
</blockquote>
<p>UserService에 TransactionService를 추가함으로써 우리는 이 두가지 의존성을 분리할 수 있습니다.</p>
<blockquote>
<p>By adding our TransactionService to our UserService we decouple our two dependencies:</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserService <span class="keyword">struct</span> {</span><br><span class="line">	DB                 *sql.DB</span><br><span class="line">	TransactionService myapp.TransactionService</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>이제 우리의 의존성들은 오직 공통된 도메인 언어를 통해서만 소통하게 됩니다. 이것은 우리가 다른 의존성들에 영향을 주지 않고 PostgreSQL을 MySQL로 Stripe를 또 다른 지불 프로세서로 변경할 수 있음을 의미합니다.</p>
<blockquote>
<p>Now our dependencies communicate solely through our common domain language. This means that we could swap out PostgreSQL for MySQL or switch Stripe for another payment processor without affecting other dependencies.</p>
</blockquote>
<br>

<h3 id="이러한-접근-방식을-3rd-party-의존성에만-국한-시키지마라"><a href="#이러한-접근-방식을-3rd-party-의존성에만-국한-시키지마라" class="headerlink" title="이러한 접근 방식을 3rd party 의존성에만 국한 시키지마라"></a>이러한 접근 방식을 3rd party 의존성에만 국한 시키지마라</h3><p>3rd party 의존성에만 국한 시키지말라는 말이 이상하게 들릴 수 있지만 이와 동일한 방식으로 Golang에서 제공하는 기본 라이브러리를 고립시킬 수 있습니다. 예를 들어, net/http 패키지는 단지 또 다른 의존성입니다. 우리가 만든 어플리케이션에 존재하는 http 라는 하위패키지에 이 net/http 패키지를  추가함으로써 고립된 환경을 구성할 수 있습니다.</p>
<blockquote>
<p>This may sound odd but I also isolate my standard library dependencies with this same method. For instance, the net/http package is just another dependency. We can isolate it as well by including an http subpackage in our application.</p>
</blockquote>
<p>해당 패키지의 이름이 그것이 감싸고 있는 의존성과 동일한 이름을 갖는다는 것이 이상할 수 있지만 이것은 의도된 것입니다. 여러분이 만든 어플리케이션의 다른 어떠한 모듈들에서도 net/http 패키지를 사용하는 곳이 없다면 패키지 이름 충돌이 발생할 일은 없습니다. 이름을 중복시킴으로 얻을 수 있는 이점은 이를 통해 여러분이 HTTP와 관련된 모든 코드들은 새롭게 만든 http 패키지에 포함되도록 한다는 것입니다.</p>
<blockquote>
<p>It might seem odd to have a package with the same name as the dependency it wraps, however, this is intentional. There are no package name conflicts in your application unless you allow net/http to be used in other parts of your application. The benefit to duplicating the name is that it requires you to isolate all HTTP code to your http package.</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> http</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">		<span class="string">"net/http"</span></span><br><span class="line">		</span><br><span class="line">		<span class="string">"github.com/benbjohnson/myapp"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> {</span><br><span class="line">		UserService myapp.UserService</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">		<span class="comment">// handle request</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>이제 우리가 만든 http.Handler는 도메인과 HTTP 프로토콜 간 어댑터로서의 역할을 수행하게 됩니다.</p>
<blockquote>
<p>Now your http.Handler acts as an adapter between your domain and the HTTP protocol.</p>
</blockquote>
<br>

<h2 id="3-공유된-mock-하위패키지를-사용하라"><a href="#3-공유된-mock-하위패키지를-사용하라" class="headerlink" title="#3. 공유된 mock 하위패키지를 사용하라"></a>#3. 공유된 mock 하위패키지를 사용하라</h2><p>우리의 의존성들은 도메인 인터페이스를 통해 다른 의존성들과 분리되어 있기떄문에 우리는 mock 구현을 주입하기 위해 이러한 연결 지점들을 사용할 수 있습니다.</p>
<blockquote>
<p>Because our dependencies are isolated from other dependencies by our domain interfaces, we can use these connection points to inject mock implementations.</p>
</blockquote>
<p>여러분에게 mock를 생성해주는 GoMock과 같은 mocking 라이브러리들이 몇가지 있지만 저는 개인적으로 그것들을 직접 작성하는것을 선호합니다. 대부분의 mocking 도구들은 너무 복잡하게 되어있습니다.</p>
<blockquote>
<p>There are several mocking libraries such as GoMock that will generate mocks for you but I personally prefer to just write them myself. I find many of the mocking tools to be overly complicated.</p>
</blockquote>
<p>제가 사용하는 mocks는 매우 간단합니다. 예를 들어, UserService를 위한 mock은 아래와 같습니다:</p>
<blockquote>
<p>The mocks I use are very simple. For example, a mock for the UserService looks like:</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mock</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/benbjohnson/myapp"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// UserService represents a mock implementation of myapp.UserService.</span></span><br><span class="line"><span class="keyword">type</span> UserService <span class="keyword">struct</span> {</span><br><span class="line">		UserFn      <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="params">(*myapp.User, error)</span></span></span><br><span class="line">		UserInvoked <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">		UsersFn     <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">([]*myapp.User, error)</span></span></span><br><span class="line">		UsersInvoked <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// additional function implementations...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// User invokes the mock implementation and marks the function as invoked.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *UserService)</span> <span class="title">User</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="params">(*myapp.User, error)</span></span> {</span><br><span class="line">		s.UserInvoked = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">return</span> s.UserFn(id)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// additional functions: Users(), CreateUser(), DeleteUser()</span></span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>이 mock은 인자들의 유효성을 검사하거나 기대된 데이터가 반환되는지를 확인하거나 실패하는 케이스를 주입해보기 위해 myapp.UserService 인터페이스를 사용하기만 한다면 어느 곳이든 함수들을 주입해볼 수 있습니다.</p>
<blockquote>
<p>This mock lets me inject functions into anything that uses the myapp.UserService interface to validate arguments, return expected data, or inject failures.</p>
</blockquote>
<p>예를 들어 위에서 만들어 본 http.Handler를 테스트하기 원한다고 해봅시다:</p>
<blockquote>
<p>Let’s say we want to test our http.Handler that we built above:</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> http_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"testing"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"net/http/httptest"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/benbjohnson/myapp/mock"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHandler</span><span class="params">(t *testing.T)</span></span> {</span><br><span class="line">	<span class="comment">// Inject our mock into our handler.</span></span><br><span class="line">	<span class="keyword">var</span> us mock.UserService</span><br><span class="line">	<span class="keyword">var</span> h Handler</span><br><span class="line">	h.UserService = &amp;us</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Mock our User() call.</span></span><br><span class="line">	us.UserFn = <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="params">(*myapp.User, error)</span></span> {</span><br><span class="line">		<span class="keyword">if</span> id != <span class="number">100</span> {</span><br><span class="line">			t.Fatalf(<span class="string">"unexpected id: %d"</span>, id)</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> &amp;myapp.User{ID: <span class="number">100</span>, Name: <span class="string">"susy"</span>}, <span class="literal">nil</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Invoke the handler.</span></span><br><span class="line">	w := httptest.NewRecorder()</span><br><span class="line">	r, _ := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"/users/100"</span>, <span class="literal">nil</span>)</span><br><span class="line">	h.ServeHTTP(w, r)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Validate mock.</span></span><br><span class="line">	<span class="keyword">if</span> !us.UserInvoked {</span><br><span class="line">		t.Fatal(<span class="string">"expected User() to be invoked"</span>)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>mock는 유닛 테스트와 HTTP 프로토콜의 처리부분이 완전히 분리될 수 있도록 해줍니다.</p>
<blockquote>
<p>Our mock lets us completely isolate our unit test to only the handling of the HTTP protocol.</p>
</blockquote>
<br>

<h2 id="4-메인-패키지는-의존성들을-하나로-엮는다"><a href="#4-메인-패키지는-의존성들을-하나로-엮는다" class="headerlink" title="#4. 메인 패키지는 의존성들을 하나로 엮는다"></a>#4. 메인 패키지는 의존성들을 하나로 엮는다</h2><p>이러한 모든 의존성 패키지들이 고립된 채로 떠다니게 된다면 이들을 어떻게 하나로 결합할 수 있을지 궁금할 수 있습니다. 이 역할을 하는 것이 메인 패키지 입니다.</p>
<blockquote>
<p>With all these dependency packages floating around in isolation, you may wonder how they all come together. That’s the job of the main package.</p>
</blockquote>
<br>

<h3 id="메인-패키지-레이아웃"><a href="#메인-패키지-레이아웃" class="headerlink" title="메인 패키지 레이아웃"></a>메인 패키지 레이아웃</h3><p>어플리케이션은 2개 이상의 바이너리 파일을 생성할 수도 있는데 이를 위해 메인 패키지를 cmd 패키지의 하위 디렉토리로 두는 Go 언어의 관습(convention)을 사용할 것입니다. 예를 들어, 우리 프로젝트가 myapp 이라는 서버 바이너리뿐만 아니라 터미널을 통해 서버를 관리할 수 있도록 하는 myappctl 이라는 클라이언트 바이너리도 갖고있다고 해봅시다. 우리의 메인 패키지를 아래와 같이 구성하게 될 것입니다:</p>
<blockquote>
<p>An application may produce multiple binaries so we’ll use the Go convention of placing our main package as a subdirectory of the cmd package. For example, our project may have a myapp server binary but also a myappctl client binary for managing the server from the terminal. We’ll layout our main packages like this:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myapp/</span><br><span class="line">    cmd/</span><br><span class="line">        myapp/</span><br><span class="line">            main.go</span><br><span class="line">        myappctl/</span><br><span class="line">            main.go</span><br></pre></td></tr></table></figure>

<br>

<h3 id="컴파일-타임에-의존성-주입"><a href="#컴파일-타임에-의존성-주입" class="headerlink" title="컴파일 타임에 의존성 주입"></a>컴파일 타임에 의존성 주입</h3><p>“의존성 주입”이라는 용어는 나쁜 평판을 받아왔습니다. 이것은 장황한 Spring XML 파일에 대한 생각을 불러일으 킵니다. 하지만 그 용어의 실제 의미는 우리는 객체에게 스스로 빌드하거나 의존성을 직접 찾아가는 것을 요구하는 대신에 객체에게 의존성을 직접 전달해줄 것이다라는 것이 전부입니다.</p>
<blockquote>
<p>The term “dependency injection” has gotten a bad rap. It conjures up thoughts of verbose Spring XML files. However, all the term really means is that we’re going to pass dependencies to our objects instead of requiring that the object build or find the dependency itself.</p>
</blockquote>
<p>메인 패키지는 어떤 의존성을 어떤 객체에게 주입할 것인지를 선택하는 역할을 합니다. 메인 패키지는 단순히 이러한 조각들을 이어 붙이는 역할만을 수행하기 때문에 코드의 규모가 작고 사소한 경향이 있습니다:</p>
<blockquote>
<p>The main package is what gets to choose which dependencies to inject into which objects. Because the main package simply wires up the pieces, it tends to be fairly small and trivial code:</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	</span><br><span class="line">	<span class="string">"github.com/benbjohnson/myapp"</span></span><br><span class="line">	<span class="string">"github.com/benbjohnson/myapp/postgres"</span></span><br><span class="line">	<span class="string">"github.com/benbjohnson/myapp/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// Connect to database.</span></span><br><span class="line">	db, err := postgres.Open(os.Getenv(<span class="string">"DB"</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create services.</span></span><br><span class="line">	us := &amp;postgres.UserService{DB: db}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Attach to HTTP handler.</span></span><br><span class="line">	<span class="keyword">var</span> h http.Handler</span><br><span class="line">	h.UserService = us</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// start http server...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>여러분의 메인 패키지 또한 어댑터의 역할을 한다는 것도 중요한 점입니다. 메인 패키지는 터미널과 여러분의 도메인을 연결해줍니다.</p>
<blockquote>
<p>It’s also important to note that your main package is also an adapter. It connects the terminal to your domain.</p>
</blockquote>
<br>

<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>어플리케이션 디자인은 매우 어려운 문제입니다. 너무나 많은 디자인 결정들이 존재하고 여러분에게 가이드해줄 견고한 이론들의 부재는 문제를 더욱 심각하게 만들 수 있습니다. 우리는 Go 어플리케이션에서 현재 사용되는 몇가지 접근 방식을 살펴보았고 그것들의 많은 결함들을 확인했습니다.</p>
<blockquote>
<p>Application design is a hard problem. There are so many design decisions to make and without a set of solid principles to guide you the problem is made even worse. We’ve looked at several current approaches to Go application design and we’ve seen many of their flaws.</p>
</blockquote>
<p>저는 의존성의 관점을 통해 디자인에 접근하는 방식이 코드 구성을 더 단순하고 쉽게 추론할 수 있도록 만들어 준다고 생각합니다. 먼저 우리는 도메인 언어를 디자인 합니다. 그리고나서 의존성들을 분리합니다. 다음으로 테스트 환경을 분리하기 위해 mocks를 도입합니다. 마지막으로 메인 패키지 안에서 이 모든 것들을 하나로 엮습니다.</p>
<blockquote>
<p>I believe approaching design from the standpoint of dependencies makes code organization simpler and easier to reason about. First we design our domain language. Then we isolate our dependencies. Next we introduce mocks to isolate our tests. Finally, we tie everything together within our main package.</p>
</blockquote>
<p>여러분이 디자인할 다음 어플리케이션에 이러한 이론들을 고려해보시기 바랍니다. 질문이 있으시거나 디자인에 대한 토론을 원하신다면 @benbjohnson 트위터를 통해 연락주시거나 Gopher 슬랙에서 benbjohnson을 찾아주세요.</p>
<blockquote>
<p>Consider these principles in the next application you design. If you have any questions or want to discuss design, contact me at @benbjohnson on Twitter or find me as benbjohnson on the Gopher slack.</p>
</blockquote>
<br>
<br>

<span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎

<p><strong>Reference</strong></p>
<ul>
<li><a href="https://www.gobeyond.dev/standard-package-layout/">https://www.gobeyond.dev/standard-package-layout/</a></li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>golang</tag>
        <tag>go layout</tag>
        <tag>organize go code</tag>
        <tag>package layout</tag>
      </tags>
  </entry>
  <entry>
    <title>기본적인 Go 프로젝트 레이아웃</title>
    <url>/2024/07/28/my-golang-layout/</url>
    <content><![CDATA[<p>제가 사용하는 기본적인 Go 프로젝트 레이아웃에 대해 간략히 소개하기 위해 해당 포스팅을 작성하게 되었습니다.</p>
<span id="more"></span>

<br>

<!-- toc -->

<br>


<h1 id="프로젝트-레이아웃이-필요한-이유는"><a href="#프로젝트-레이아웃이-필요한-이유는" class="headerlink" title="프로젝트 레이아웃이 필요한 이유는?"></a>프로젝트 레이아웃이 필요한 이유는?</h1><p>최초 프로젝트 설계자가 아닌 또 다른 누군가가 유지보수를 담당하게되는 경우(대부분의 소프트웨어 개발 회사의 상황일 것으로 생각됨) 프로젝트 레이아웃이 명확하지 않은 경우에는 전체 구조를 파악하기가 어려울 뿐만아니라 의도치 않은 방향으로 소스 코드가 추가될 수 있습니다.</p>
<br>

<h1 id="Go-코드를-어떻게-작성해야하는가"><a href="#Go-코드를-어떻게-작성해야하는가" class="headerlink" title="Go 코드를 어떻게 작성해야하는가?"></a>Go 코드를 어떻게 작성해야하는가?</h1><p>먼저 Golang 공식 홈페이지에서 제공하고 있는 Go 코드 작성 가이드를 통해 패키지(package)와 모듈(module)에 대한 개념을 먼저 잡아보도록 하겠습니다. (<a href="https://go.dev/doc/code">해당 링크</a>를 통해 원문을 확인하실 수 있습니다.)</p>
<h2 id="Code-organization"><a href="#Code-organization" class="headerlink" title="Code organization"></a>Code organization</h2><p>Go 프로그램은 패키지들로 구성됩니다. 여기서 *패키지(package)*란 함께 컴파일되는 동일 디렉토리 내의 소스 파일들의 집합입니다. 패키지 내 하나의 소스 파일 안에 정의된 함수, 타입, 변수 그리고 상수들은 동일한 패키지 내에 있는 다른 모든 소스 파일들에서 접근이 가능합니다.</p>
<blockquote>
<p>Go programs are organized into packages. A package is a collection of source files in the same directory that are compiled together. Functions, types, variables, and constants defined in one source file are visible to all other source files within the same package.</p>
</blockquote>
<p>하나의 저장소는 한 개 이상의 모듈들을 포함하고 있습니다. 여기서 *모듈(module)*이란 함께 배포되는 연관된 Go 패키지들의 집합입니다. Go 저장소는 일반적으로 하나의 모듈만을 포함하며 이 모듈은 저장소의 root 경로에 존재합니다. 저장소의 root 경로에 go.mod 라는 이름의 파일에서는 모듈 경로를 선언해주는데 이 경로는 모듈 내에 존재하는 모든 패키지들의 임포트 경로의 접두사(prefix)로 사용됩니다. 모듈은 go.mod 파일이 포함된 디렉토리에 존재하는 패키지들뿐만아니라 그 디렉토리들의 하위 디렉토리에 존재하는 패키지들까지 포함합니다.(만약 go.mod 파일이 두 개 이상 존재하는 경우라면 또 다른 go.mod 파일이 존재하는 다음 하위 디렉토리 전까지를 포함함)</p>
<blockquote>
<p>A repository contains one or more modules. A module is a collection of related Go packages that are released together. A Go repository typically contains only one module, located at the root of the repository. A file named go.mod there declares the module path: the import path prefix for all packages within the module. The module contains the packages in the directory containing its go.mod file as well as subdirectories of that directory, up to the next subdirectory containing another go.mod file (if any).</p>
</blockquote>
<p>여러분의 소스 코드를 빌드하기 전에 이것을 원격 저장소에 배포할 필요는 없습니다. 모듈은 원격 저장소에서 관리되지 않더라도 로컬에서 정의될 수 있습니다. 하지만 미래의 배포 가능성을 열어두고 여러분의 소스 코드를 조직화하는 것은 좋은 습관입니다.</p>
<blockquote>
<p>Note that you don’t need to publish your code to a remote repository before you can build it. A module can be defined locally without belonging to a repository. However, it’s a good habit to organize your code as if you will publish it someday.</p>
</blockquote>
<p>각 모듈의 경로 정보는 해당 모듈에 포함된 패키지들의 임포트 경로의 접두사(prefix)를 제공할 뿐만 아니라, go 명령어가 해당 모듈을 다운로드하기 위해 바라봐야할 위치를 가리킵니다. 예를 들어, golang.org/x/tools 라는 모듈을 다운로드 하기위해서는 go 명령어가 <a href="https://golang.org/x/tools%EA%B0%80">https://golang.org/x/tools가</a> 가리키는 저장소를 참고할 것입니다.</p>
<blockquote>
<p>Each module’s path not only serves as an import path prefix for its packages, but also indicates where the go command should look to download it. For example, in order to download the module golang.org/x/tools, the go command would consult the repository indicated by <a href="https://golang.org/x/tools">https://golang.org/x/tools</a> (described more here).</p>
</blockquote>
<p>임포트 경로는 패키지를 임포트하기 위해 사용됩니다. 패키지의 임포트 경로는 해당 패키지의 모듈 경로와 모듈 내에 존재하는 연결된 하위 디렉토리 경로입니다. 에를 들어, github.com/google/go-cmp 모듈은 cmp/ 디렉토리 안의 패키지를 포함합니다. 그 패키지의 임포트 경로는 github.com/google/go-cmp/cmp 입니다. 스탠다드 라이브러리 내의 패키지들은 모듈 경로 접두사를 가지고 있지 않습니다.</p>
<blockquote>
<p>An import path is a string used to import a package. A package’s import path is its module path joined with its subdirectory within the module. For example, the module github.com/google/go-cmp contains a package in the directory cmp/. That package’s import path is github.com/google/go-cmp/cmp. Packages in the standard library do not have a module path prefix.</p>
</blockquote>
<h2 id="Your-first-program"><a href="#Your-first-program" class="headerlink" title="Your first program"></a>Your first program</h2><p>단순한 프로그램을 컴파일하고 실행하기 위해 먼저 모듈 경로(example/user/hello라는 경로를 사용할 예정)를 선택하고, 그 경로를 선언하고 있는 go.mod 파일을 생성합니다.  </p>
<blockquote>
<p>To compile and run a simple program, first choose a module path (we’ll use example/user/hello) and create a go.mod file that declares it:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ mkdir hello # Alternatively, clone it <span class="keyword">if</span> it already exists in version control.</span><br><span class="line">$ cd hello</span><br><span class="line">$ <span class="keyword">go</span> mod init example/user/hello</span><br><span class="line"><span class="keyword">go</span>: creating <span class="built_in">new</span> <span class="keyword">go</span>.mod: module example/user/hello</span><br><span class="line">$ cat <span class="keyword">go</span>.mod</span><br><span class="line">module example/user/hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.16</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>Go 소스 파일의 첫번째 문장으로는 패키지 이름이 작성돼야합니다. 실행 가능한 명령어는 항상 main 패키지를 사용해야 합니다.</p>
<blockquote>
<p>The first statement in a Go source file must be package name. Executable commands must always use package main.</p>
</blockquote>
<p>다음으로 해당 디렉토리 내에 아래 Go 코드를 포함하는 hello.go 파일을 생성합니다.</p>
<blockquote>
<p>Next, create a file named hello.go inside that directory containing the following Go code:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, world.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제 여러분은 go tool을 사용해서 프로그램을 빌드하고 설치할 수 있습니다.</p>
<blockquote>
<p>Now you can build and install that program with the go tool:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> install example/user/hello</span><br></pre></td></tr></table></figure>

<p>이 명령어는 hello 명령어를 빌드하고, 실행가능한 바이너리를 생성합니다. 그리고나서 그 바이너리 파일을 $HOME/go/bin/hello 경로에 설치합니다.</p>
<blockquote>
<p>This command builds the hello command, producing an executable binary. It then installs that binary as $HOME/go/bin/hello.</p>
</blockquote>
<p>설치 경로는 GOPATH와 GOBIN 환경 변수를 통해 조절할 수 있습니다. 만약 GOBIN 환경 변수가 설정이되었다면, 바이너리 파일은 그 경로에 설치될것입니다. 만약 GOPATH가 설정되었다면, 바이너리 파일은 GOPATH 리스트의 첫번째 디렉토리의 bin 이라는 하위 디렉토리에 설치될 것 입니다. 두 환경 변수 모두 설정되지 않은 경우라면, 바이너리 파일은 기본 GOPATH 경로($HOME/go)에 설치될 것 입니다.</p>
<blockquote>
<p>The install directory is controlled by the GOPATH and GOBIN environment variables. If GOBIN is set, binaries are installed to that directory. If GOPATH is set, binaries are installed to the bin subdirectory of the first directory in the GOPATH list. Otherwise, binaries are installed to the bin subdirectory of the default GOPATH ($HOME/go).</p>
</blockquote>
<p>여러분은 추후에 사용될 go 커맨드가 참조할 수 있는 환경 변수의 기본 값을 go env 명령어를 통해 설정할 수 있습니다.</p>
<blockquote>
<p>You can use the go env command to portably set the default value for an environment variable for future go commands:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> env -w GOBIN=/somewhere/<span class="keyword">else</span>/bin</span><br></pre></td></tr></table></figure>

<p>go env -w를 통해 이전에 설정한 값을 해제하고 싶은 경우에는 go env -u를 사용하면 됩니다.</p>
<blockquote>
<p>To unset a variable previously set by go env -w, use go env -u:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> env -u GOBIN</span><br></pre></td></tr></table></figure>

<p>go install과 같은 명령어는 현재 작업 경로를 포함하고 있는 모듈의 컨텍스트 내에 적용됩니다. 만약 작업 경로가 example/user/hello 모듈 내부가 아니라면, go insall 명령어는 실패할 것 입니다.</p>
<blockquote>
<p>Commands like go install apply within the context of the module containing the current working directory. If the working directory is not within the example/user/hello module, go install may fail.</p>
</blockquote>
<p>편리성을 위해 go 명령어는 작업 경로에 상대적인 경로를 허용하고, 다른 경로가 주언진 경우가 아니라면 현재 작업 경로의 패키지를 기본으로 사용합니다. 그래서 현재 우리의 작업 경로에서는, 아래 명령어들이 모두 동일한 결과를 갖습니다.</p>
<blockquote>
<p>For convenience, go commands accept paths relative to the working directory, and default to the package in the current working directory if no other path is given. So in our working directory, the following commands are all equivalent:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> install example/user/hello</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> install .</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> install</span><br></pre></td></tr></table></figure>

<p>다음으로 정상적으로 동작하는지 확인해보기 위해 프로그램을 실행해봅시다. 바이너리를 쉽게 실행하기 위해 PATH 환경 변수에 설치 경로를 추가할 것 입니다.</p>
<blockquote>
<p>Next, let’s run the program to ensure it works. For added convenience, we’ll add the install directory to our PATH to make running binaries easy:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"># Windows users should consult /wiki/SettingGOPATH</span><br><span class="line"># <span class="keyword">for</span> setting %PATH%.</span><br><span class="line">$ export PATH=$PATH:$(dirname $(<span class="keyword">go</span> list -f <span class="string">&#x27;&#123;&#123;.Target&#125;&#125;&#x27;</span> .))</span><br><span class="line">$ hello</span><br><span class="line">Hello, world.</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<h2 id="Importing-packages-from-your-module"><a href="#Importing-packages-from-your-module" class="headerlink" title="Importing packages from your module"></a>Importing packages from your module</h2><p>morestrings 패키지를 작성하고 그 패키지를 hello 프로그램에서 사용하도록 해봅시다. 먼저 해당 패키지를 저장할 $HOME/hello/morestrings 디렉토리를 생성해줍니다. 그리고나서 아래 내용을 포함하는 reverse.go 라는 파일을 그 디렉토리 내에서 생성해줍시다.</p>
<blockquote>
<p>Let’s write a morestrings package and use it from the hello program. First, create a directory for the package named $HOME/hello/morestrings, and then a file named reverse.go in that directory with the following contents:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Package morestrings implements additional functions to manipulate UTF-8</span></span><br><span class="line"><span class="comment">// encoded strings, beyond what is provided in the standard &quot;strings&quot; package.</span></span><br><span class="line"><span class="keyword">package</span> morestrings</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReverseRunes returns its argument string reversed rune-wise left to right.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReverseRunes</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    r := []<span class="keyword">rune</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(r)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(r)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        r[i], r[j] = r[j], r[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReverseRunes() 함수는 대문자로 시작하기 때문에 morestring 패키지를 임포트한 또 다른 패키지들에서 해당 함수를 사용할 수 있습니다.</p>
<blockquote>
<p>Because our ReverseRunes function begins with an upper-case letter, it is exported, and can be used in other packages that import our morestrings package.</p>
</blockquote>
<p>go build로 morestrings 패키지를 컴파일 해봅시다.</p>
<blockquote>
<p>Let’s test that the package compiles with go build:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ cd $HOME/hello/morestrings</span><br><span class="line">$ <span class="keyword">go</span> build</span><br></pre></td></tr></table></figure>

<p>위 명령어로는 어떠한 결과 파일이 생성되지는 않을 것입니다. 대신에 그것은 로컬 빌드 캐시에 컴파일된 패키지를 저장합니다.</p>
<blockquote>
<p>This won’t produce an output file. Instead it saves the compiled package in the local build cache.</p>
</blockquote>
<p>morestrings 패키지 빌드 이후에, hello 프로그램에서 이것을 사용해봅시다. 이를 위해 $HOME/hello/hello.go 코드에서 morestrings 패키지를 사용할 수 있도록 수정해봅시다.</p>
<blockquote>
<p>After confirming that the morestrings package builds, let’s use it from the hello program. To do so, modify your original $HOME/hello/hello.go to use the morestrings package:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;example/user/hello/morestrings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(morestrings.ReverseRunes(<span class="string">&quot;!oG ,olleH&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hello 프로그램을 설치하고</p>
<blockquote>
<p>Install the hello program:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> install example/user/hello</span><br></pre></td></tr></table></figure>

<p>새로운 버전의 hello 프로그램을 실행해보면 여러분은 뒤집힌 메시지를 볼 수 있을겁니다.</p>
<blockquote>
<p>Running the new version of the program, you should see a new, reversed message:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ hello</span><br><span class="line">Hello, Go!</span><br></pre></td></tr></table></figure>

<h2 id="Importing-packages-from-remote-modules"><a href="#Importing-packages-from-remote-modules" class="headerlink" title="Importing packages from remote modules"></a>Importing packages from remote modules</h2><p>임포트 경로는 버전 관리 시스템인 Git 이나 Mercurial을 사용하는 패키지 소스 코드를 어떻게 받아오는지를 설명할 수 있습니다. go tool은 원격 저장소에 있는 패키지들을 자동으로 가져오기 위해 이러한 특성을 사용합니다.</p>
<blockquote>
<p>An import path can describe how to obtain the package source code using a revision control system such as Git or Mercurial. The go tool uses this property to automatically fetch packages from remote repositories. For instance, to use github.com/google/go-cmp/cmp in your program:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;example/user/hello/morestrings&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/google/go-cmp/cmp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(morestrings.ReverseRunes(<span class="string">&quot;!oG ,olleH&quot;</span>))</span><br><span class="line">    fmt.Println(cmp.Diff(<span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;Hello Go&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제 여러분은 외부 모듈에 대한 의존성을 가지게 되었고, 그러한 모듈을 다운로드하고 그것의 버전 정보를 go.mode 파일 내에 기록할 필요가 있습니다. go mod tidy 명령어는 임포트 패키지들에 대한 누락된 모듈 요구사항들을 추가해주고 더이상 사용하지 않는 모듈들에 대한 요구사항들을 제거해줍니다. </p>
<blockquote>
<p>Now that you have a dependency on an external module, you need to download that module and record its version in your go.mod file. The go mod tidy command adds missing module requirements for imported packages and removes requirements on modules that aren’t used anymore.</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> mod tidy</span><br><span class="line"><span class="keyword">go</span>: finding module <span class="keyword">for</span> <span class="keyword">package</span> github.com/google/<span class="keyword">go</span>-cmp/cmp</span><br><span class="line"><span class="keyword">go</span>: found github.com/google/<span class="keyword">go</span>-cmp/cmp in github.com/google/<span class="keyword">go</span>-cmp v0<span class="number">.5</span><span class="number">.4</span></span><br><span class="line">$ <span class="keyword">go</span> install example/user/hello</span><br><span class="line">$ hello</span><br><span class="line">Hello, Go!</span><br><span class="line">  <span class="keyword">string</span>(</span><br><span class="line">-     <span class="string">&quot;Hello World&quot;</span>,</span><br><span class="line">+     <span class="string">&quot;Hello Go&quot;</span>,</span><br><span class="line">  )</span><br><span class="line">$ cat <span class="keyword">go</span>.mod</span><br><span class="line">module example/user/hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.16</span></span><br><span class="line"></span><br><span class="line">require github.com/google/<span class="keyword">go</span>-cmp v0<span class="number">.5</span><span class="number">.4</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>모듈 의존성은 GOPATH 환경 변수가 가리키는 경로의 하위 경로인 pkg/mod에 자동으로 다운로드 됩니다. 다운로드된 모듈의 버전 정보들은 해당 버전을 필요로 하는 다른 모든 모듈들에게 공유됩니다. 그래서 go 명령어는 이러한 파일과 디렉토리를 read-only로 표시합니다. 다운로드 받은 모든 모듈들을 삭제하기 위해서는 go clean 명령어에 -modcache 플래그를 전달해주면 됩니다. </p>
<blockquote>
<p>Module dependencies are automatically downloaded to the pkg/mod subdirectory of the directory indicated by the GOPATH environment variable. The downloaded contents for a given version of a module are shared among all other modules that require that version, so the go command marks those files and directories as read-only. To remove all downloaded modules, you can pass the -modcache flag to go clean:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> clean -modcache</span><br></pre></td></tr></table></figure>

<br>

<h1 id="내가-사용하는-Go-프로젝트-레이아웃"><a href="#내가-사용하는-Go-프로젝트-레이아웃" class="headerlink" title="내가 사용하는 Go 프로젝트 레이아웃"></a>내가 사용하는 Go 프로젝트 레이아웃</h1><p>다양한 프로젝트 레이아웃들을 비교해본 끝에 <a href="https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html">Package Oriented Design</a>라는 포스팅을 참조하여 프로젝트 레이아웃을 구성해보기로 결정했고, 실제 현업에서 개발 중인 서비스를 이 구조에 맞춰서 구현해나갔습니다.</p>
<h2 id="bin"><a href="#bin" class="headerlink" title="bin/"></a>bin/</h2><ul>
<li>실행가능한 바이너리 파일이 생성되는 경로</li>
<li>바이너리 실행을 위해 필요한 설정 값이 저장되는 config 파일도 포함됨</li>
</ul>
<h2 id="cmd"><a href="#cmd" class="headerlink" title="cmd/"></a>cmd/</h2><ul>
<li>main 패키지를 포함하는 go 파일이 저장되는 경로</li>
</ul>
<h2 id="internal"><a href="#internal" class="headerlink" title="internal/"></a>internal/</h2><ul>
<li>main 패키지에서 임포트하는 패키지들의 집합이며, 제공하는 서비스 별로 패키지들을 구분함(ex. internal/gateway) </li>
</ul>
<p>동일 프로젝트 내에 존재하는 2개 이상의 프로그램들에서 임포트될 필요성이 있는 패키지들이 internal/ 폴더 내에 속해있습니다. internal/ 이라는 명칭의 사용이 가져다 주는 한가지 이점은 프로젝트가 컴파일러로부터 추가적인 보호 레벨을 얻어낼 수 있다는 점입니다. internal/ 폴더 내에 존재하는 패키지들을 해당 프로젝트의 외부에 있는 패키지에서 임포트할 수 없습니다. 그러므로 이러한 패키지들은 오로지 해당 프로젝트 내에 귀속됩니다.</p>
<blockquote>
<p>Packages that need to be imported by multiple programs within the project belong inside the internal/ folder. One benefit of using the name internal/ is that the project gets an extra level of protection from the compiler. No package outside of this project can import packages from inside of internal/. These packages are therefore internal to this project only.</p>
</blockquote>
<h2 id="internal-platform"><a href="#internal-platform" class="headerlink" title="internal/platform/"></a>internal/platform/</h2><ul>
<li>internal에 포함된 패키지들에서 공통적으로 사용할 수 있는 기능을 제공하는 패키지들의 집합</li>
</ul>
<p>기반이되는 그러나 프로젝트에 특정되는 패키지들이 internal/platform 폴더 내에 속해있습니다. 이러한 패키지들은 데이터베이스나 인증 또는 marshaling과 같은 기능들을 제공하곤 합니다.</p>
<blockquote>
<p>Packages that are foundational but specific to the project belong in the internal/platform/ folder. These would be packages that provide support for things like databases, authentication or even marshaling.</p>
</blockquote>
<br>

<h1 id="프로젝트-예시"><a href="#프로젝트-예시" class="headerlink" title="프로젝트 예시"></a>프로젝트 예시</h1><p>현재 토이 프로젝트로 진행중인 go 서비스에서도 위 프로젝트 레이아웃을 사용 중에 있습니다. <a href="https://github.com/chelseafandev/wavynote/tree/main">해당 링크</a>를 통해 확인 가능하십니다.</p>
<br>
<br>

<span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎

<p><strong>Reference</strong></p>
<ul>
<li><a href="https://go.dev/doc/code">https://go.dev/doc/code</a></li>
<li><a href="https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html">https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>go project layout</tag>
        <tag>golang layout</tag>
        <tag>how to write go code</tag>
      </tags>
  </entry>
  <entry>
    <title>boost strand를 사용하는 이유</title>
    <url>/2023/09/12/what-is-strand/</url>
    <content><![CDATA[<p>이번 포스팅에서는 boost에서 제공하는 strand에 대해 알아보는 시간을 갖도록 하겠습니다.</p>
<span id="more"></span>

<p>strand에 대한 설명은 <a href="https://www.crazygaze.com/blog/2016/03/17/how-strands-work-and-why-you-should-use-them/">How strands work and why you should use them</a> 내용을 바탕으로 작성되었으니 참고부탁드리며, 글 하단에는 strand 동작을 검증하기 위한 예제 코드를 첨부하였으니 직접 테스트 해보시며 strand의 사용법과 필요성에 대해 다시 한번 정리하는 시간을 갖으면 좋을것같네요😁</p>
<br>

<!-- toc -->

<br>

<h2 id="How-strands-work-and-why-you-should-use-them"><a href="#How-strands-work-and-why-you-should-use-them" class="headerlink" title="How strands work and why you should use them"></a>How strands work and why you should use them</h2><p>만약 여러분이 Boost Asio를 사용해본적이 있다면, 틀림없이 <a href="https://www.boost.org/doc/libs/1_83_0/doc/html/boost_asio/overview/core/strands.html">strands</a> 라는 것을 사용해봤거나 최소한 마주치기라도 해봤을 것입니다.</p>
<blockquote>
<p>If you ever used Boost Asio, certainly you used or at least looked at <a href="https://www.boost.org/doc/libs/1_83_0/doc/html/boost_asio/overview/core/strands.html">strands</a>.</p>
</blockquote>
<p>strands 사용을 통해 얻을 수 있는 주요한 이점은 여러분의 소스 코드를 단순화해준다는 것입니다. 이러한 단순화는 strand를 통해 실행되는 핸들러에 대해서는 명시적인 동기화가 필요하지 않기때문에 가능합니다. strand는 2개의 핸들러가 동시에 실행되지않음을 보장합니다.</p>
<blockquote>
<p>The main benefit of using strands is to simplify your code, since handlers that go through a strand don’t need explicit synchronization. A strand guarantees that no two handlers execute concurrently.</p>
</blockquote>
<p>만약 여러분이 단지 하나의 I/O 쓰레드(boost 라이브러리 측면에서 설명하자면 io_context::run()을 호출하는 쓰레드가 오직 하나인 경우를 의미함)를 사용한다면, 동기화를 걱정할 필요가 전혀 없습니다. 그것이 이미 암묵적인 strand입니다. 하지만 여러분이 더 많은 I/O 쓰레드를 사용해야하는 순간이 온다면 I/O 쓰레드에서 실행되는 핸들러에 대해 명시적인 동기화 처리를 하거나 strands를 사용해야합니다.</p>
<blockquote>
<p>If you use just one I/O thread (or in Boost terms, just one thread calling io_context::run), then you don’t need synchronization anyway. That is already an implicit strand. But the moment you want to ramp up and have more I/O threads, you need to either deal with explicit synchronization for your handlers, or use strands.</p>
</blockquote>
<p>여러분이 정의한 핸들러를 명시적으로 동기화하는 것은 명백히 가능한 일이지만 이것은 불필요하게 여러분의 소스 코드에 복잡성을 부여하여 버그를 발생시킬 수도 있습니다. 핸들러의 명시적 동기화가 갖는 또 다른 영향도 중 하나는 여러분이 정말 신중하게 고려하지 않는 이상 불필요한 블록 구간의 발생이 불가피하다는 점입니다.</p>
<blockquote>
<p>Explicitly synchronizing your handlers is certainly possible, but you will be unnecessarily introducing complexity to your code which will certainly lead to bugs. One other effect of explicit handler synchronization is that unless you think really hard, you’ll very likely introduce unnecessary blocking.</p>
</blockquote>
<p>strands는 여러분의 소스 코드와 핸들러의 실행 사이에 또 다른 계층을 하나 둠으로써 동작합니다. 여러분의 핸들러를 직접적으로 실행하는 worker 쓰레드들을 갖는 대신에, 이러한 핸들러들이 strand 내의 큐에 저장됩니다. 그리고나서 strand는 모든 조건이 충족되었을 때에만 핸들러를 실행하도록 하는 제어 권한을 갖게됩니다.</p>
<blockquote>
<p>Strands work by introducing another layer between your application code and the handler execution. Instead of having the worker threads directly execute your handlers, those handlers are queued in a strand. The strand then has control over when executing the handlers so that all guarantees can be met.</p>
</blockquote>
<p>이것에 대해 생각해볼 수 있는 한가지 방법은 아래 그림과 같습니다.</p>
<blockquote>
<p>One way you can think about is like this:</p>
</blockquote>
<div class="figure " style="width:;"><img class="fig-img" src="/assets/images/what-is-strand-figure-1.png" alt=""></div>

<h3 id="Possible-scenario"><a href="#Possible-scenario" class="headerlink" title="Possible scenario"></a>Possible scenario</h3><p>I/O 쓰레드와 핸들러에 어떤 일이 발생하는지를 시각적으로 보여주기 위해 <a href="https://github.com/Celtoys/Remotery">Remotry</a>를 사용했습니다.</p>
<blockquote>
<p>To visually demonstrate what happens with the I/O threads and handlers, I’ve used <a href="https://github.com/Celtoys/Remotery">Remotery</a>.</p>
</blockquote>
<p>사용되는 코드는 4개의 worker 쓰레드와 8개의 connection을 에뮬레이트합니다. 5ms ~ 15ms 사이의 임의의 작업량을 갖는 핸들러(일종의 작업 항목)는 worker 큐에 놓이게됩니다. 실제로 여러분이 이러한 커넥션별 쓰레드비율 또는 핸들러 작업량을 갖지않더라도 해당 수치들은 문제를 보여주기에 용이합니다. 또한 저는 Boost Asio 라이브러리를 사용하지 않았고, 해당 글의 주제를 논의해나가기 위해 자체적으로 strand를 구현해보았습니다.</p>
<blockquote>
<p>The code used emulates 4 worker threads, and 8 connections. Handlers (aka work items) with a random workload of [5ms,15ms] for a random connection are placed in the worker queue. In practice, you would not have this threads/connections ratio or handler workload, but it makes it easier to demonstrate the problem. Also, I’m not using Boost Asio at all. It’s a custom strand implementation to explore the topic.</p>
</blockquote>
<p>아래 그림은 worker 쓰레드들의 상태를 보여줍니다:</p>
<blockquote>
<p>So, a view into the worker threads:</p>
</blockquote>
<div class="figure " style="width:;"><img class="fig-img" src="/assets/images/what-is-strand-figure-2.png" alt=""></div>

<p><code>Conn N</code>은 커넥션 객체를 의미합니다(또는 worker 쓰레드 상에서 작업을 수행하는 어떠한 객체). 각각의 커넥션 객체는 서로 다른 색상을 갖고있습니다. 보시다시피 겉보기에는 괜찮아 보입니다. 이제 각각의 Conn 객체의 실직적인 상태를 시분할 단위로 살펴보도록 하겠습니다.</p>
<blockquote>
<p>Conn N are our connection objects (or any object doing work in our worker threads for that matter). Each has a distinct colour. All good on the surface as you can see. Now lets look at what each Conn object is actually doing with its time slice.</p>
</blockquote>
<div class="figure " style="width:;"><img class="fig-img" src="/assets/images/what-is-strand-figure-3.png" alt=""></div>

<p>worker 큐와 쓰레드는 핸들러가 수행하는 작업을 인지하지 못하기때문에서 worker 쓰레드는 처리할 커넥션 객체가 들어오는 순간 기꺼이 큐에서 꺼내려 할 것입니다. 하나의 쓰레드에서 또 다른 worker 쓰레드에서 이미 사용되고 있는 커넥션 객체를 실행하려고 할 때, 그것은 block 상태에 놓이게될 것입니다. 현재의 시나리오에서는 전체 시간의 약 19% 정도가 block 상태 또는 또 다른 오버 헤드로 인해 낭비되고 있습니다. 다시 말해, 실질적으로 worker 쓰레드가 작업에 할당하는 시간이 전체의 약 81% 뿐이라는 것입니다:</p>
<blockquote>
<p>What is happening is the worker queue and worker threads are oblivious to what its handlers do (as expected), so the worker threads will happily dequeue work as it comes. One thread tries to execute work for a given Conn object which is already being used in another worker thread, so it has to block. In this scenario, ~19% of total time is wasted with blocking or other overhead. In other words, only ~81% of the worker thread’s time is spent doing actual work:</p>
</blockquote>
<div class="figure " style="width:;"><img class="fig-img" src="/assets/images/what-is-strand-figure-4.png" alt=""></div>

<p>오버 헤드는 worker 쓰레드 전체 시간에서 실제 작업 시간을 뺀 값으로 측정됩니다. 그렇기 때문에 핸들러 내의 명시적인 동기화 그리고 worker 큐/쓰레드 내부적으로 수행된 모든 동기화 작업들이 이 오버 헤드에 포함됩니다.</p>
<blockquote>
<p>NOTE: The overhead was measured by subtracting actual work time from the total worker thread’s time. So it accounts for explicit synchronization in the handlers and any work/synchronization done internally by the worker queue/threads.</p>
</blockquote>
<p>이제 커넥션 객체의 작업을 동기화하기 위해 strands를 사용하는 경우의 상태 값을 살펴봅시다.</p>
<blockquote>
<p>Lets see how it looks like if we use strands to serialize work for our Conn objects:</p>
</blockquote>
<div class="figure " style="width:;"><img class="fig-img" src="/assets/images/what-is-strand-figure-5.png" alt=""></div>

<div class="figure " style="width:;"><img class="fig-img" src="/assets/images/what-is-strand-figure-6.png" alt=""></div>

<p>내부 작업 또는 동기화에 낭비되는 시간이 매우 작다는것을 알 수 있습니다.</p>
<blockquote>
<p>Very little time is wasted with internal work or synchronization.</p>
</blockquote>
<br>

<h3 id="Cache-locality"><a href="#Cache-locality" class="headerlink" title="Cache locality"></a>Cache locality</h3><p>strands를 사용하는 경우에 얻을 수 있는 또 하나의 작은 이점은 더 나은 CPU 캐시 활용입니다. worker 쓰레드는 또 다른 커넥션 객체를 가지고 오기 전에 현재 주어진 커넥션 객체의 핸들러를 더 많이 실행하려는 경향이 있습니다.</p>
<blockquote>
<p>Another possible small benefit with this scenario is better CPU cache utilization. Worker threads will tend to execute a few handlers for a given Conn object before grabbing another Conn object.</p>
</blockquote>
<p>Zoomed out, without strands</p>
<div class="figure " style="width:;"><img class="fig-img" src="/assets/images/what-is-strand-figure-7.png" alt=""></div>

<p>Zoomed out, with strands<br>(각각의 쓰레드에 따라 동일한 번호의 커넥션 객체의 작업 수행이 밀집되어 있는 것을 볼 수 있음)</p>
<div class="figure " style="width:;"><img class="fig-img" src="/assets/images/what-is-strand-figure-8.png" alt=""></div>

<br>

<h2 id="예제-코드"><a href="#예제-코드" class="headerlink" title="예제 코드"></a>예제 코드</h2><p>실제 예제 코드를 통해서 strand의 사용법을 알아보도록 하겠습니다. 아래 예제는 N개(1, 2, 4, 8, 16)의 쓰레드에서 각각 전역 변수인 sum에 2씩 더하는 연산을 수행하며, sum의 누적 합이 1억이 출력되는지를 확인하고자 하는 코드입니다.<br>쓰레드가 1개(N=1)인 상황에서 sum이 1억이 되기위해서는 2씩 더하는 연산이 총 50000000번 반복돼야하며 쓰레드를 16개(N=16)까지 늘린다면 해당 연산은 3125000번 반복되면 됩니다.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread/detail/thread_group.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">thread_func</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">thread_func</span>(<span class="keyword">int</span> idx, boost::asio::io_context&amp; ctx) : <span class="built_in">idx_</span>(idx), <span class="built_in">ctx_</span>(ctx)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::ostringstream oss;</span><br><span class="line">        oss &lt;&lt; std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;io_context::run #%d thread [%s]\n&quot;</span>, idx_, oss.<span class="built_in">str</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        ctx_.<span class="built_in">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> idx_;</span><br><span class="line">    boost::asio::io_context&amp; ctx_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_sum_to_100_million_without_strand</span><span class="params">(<span class="keyword">int</span> thread_count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    boost::asio::io_context ctx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> loop_count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (thread_count)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        loop_count = <span class="number">50000000</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        loop_count = <span class="number">25000000</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        loop_count = <span class="number">12500000</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        loop_count = <span class="number">6250000</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">        loop_count = <span class="number">3125000</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no strand</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; thread_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        boost::asio::<span class="built_in">post</span>(ctx, [&amp;]()&#123;</span><br><span class="line">            std::ostringstream oss;</span><br><span class="line">            oss &lt;&lt; std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hello boost::asio::post in io_context [%s]\n&quot;</span>, oss.<span class="built_in">str</span>().<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loop_count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    boost::thread_group tg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; thread_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tg.<span class="built_in">create_thread</span>(<span class="built_in">thread_func</span>(i+<span class="number">1</span>, ctx));</span><br><span class="line">    &#125;</span><br><span class="line">    tg.<span class="built_in">join_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[make_sum_to_100_million_without_strand, %d thread] sum : %d\n&quot;</span>, thread_count, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thread_count = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">make_sum_to_100_million_without_strand</span>(thread_count)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>실행결과</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[make_sum_to_100_million_without_strand, 2 thread] sum : 50614948</span><br></pre></td></tr></table></figure>
<p>(위 예시의 경우에는 2개의 쓰레드에서)핸들러 동기화를 수행하지 않는 경우에는 1억이 정상적으로 출력되지 않음을 볼 수 있습니다. 여러 쓰레드에서 동시에 접근하는 변수에 대한 명시적인 동기화 처리를 해주지 않았기 때문에 당연한 결과입니다.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread/detail/thread_group.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">thread_func</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">thread_func</span>(<span class="keyword">int</span> idx, boost::asio::io_context&amp; ctx) : <span class="built_in">idx_</span>(idx), <span class="built_in">ctx_</span>(ctx)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::ostringstream oss;</span><br><span class="line">        oss &lt;&lt; std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;io_context::run #%d thread [%s]\n&quot;</span>, idx_, oss.<span class="built_in">str</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        ctx_.<span class="built_in">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> idx_;</span><br><span class="line">    boost::asio::io_context&amp; ctx_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_sum_to_100_million_with_strand</span><span class="params">(<span class="keyword">int</span> thread_count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    boost::asio::io_context ctx;</span><br><span class="line">    boost::asio::<span class="function">io_context::strand <span class="title">strand</span><span class="params">(ctx)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> loop_count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (thread_count)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        loop_count = <span class="number">50000000</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        loop_count = <span class="number">25000000</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        loop_count = <span class="number">12500000</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        loop_count = <span class="number">6250000</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">        loop_count = <span class="number">3125000</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// strand</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; thread_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        boost::asio::<span class="built_in">post</span>(strand.<span class="built_in">wrap</span>([&amp;]()&#123;</span><br><span class="line">            std::ostringstream oss;</span><br><span class="line">            oss &lt;&lt; std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hello boost::asio::post in io_context [%s]\n&quot;</span>, oss.<span class="built_in">str</span>().<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loop_count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    boost::thread_group tg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; thread_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tg.<span class="built_in">create_thread</span>(<span class="built_in">thread_func</span>(i+<span class="number">1</span>, ctx));</span><br><span class="line">    &#125;</span><br><span class="line">    tg.<span class="built_in">join_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[make_sum_to_100_million_with_strand, %d thread] sum : %d\n&quot;</span>, thread_count, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thread_count = <span class="number">16</span>;</span><br><span class="line">    <span class="built_in">make_sum_to_100_million_with_strand</span>(thread_count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>실행결과</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[make_sum_to_100_million_with_strand, 16 thread] sum : 100000000</span><br></pre></td></tr></table></figure>
<p>(위 예시의 경우에는 16개의 쓰레드에서) boost strand를 사용하여 핸들러 동기화를 수행(전역 변수인 sum에 접근하는 핸들러가 동시에 실행되지 않음을 보장)하였기때문에 1억이 정상적으로 출력됨을 확인할 수 있습니다.</p>
<br>

<h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><ul>
<li>I/O thread가 1개인 경우(즉, io_context::run() 함수가 호출되는 쓰레드가 1개인 경우)에는 오직 하나의 쓰레드에서만 핸들러가 호출되므로 동기화라는게 필요없음.</li>
<li>2개 이상의 I/O thread(즉, io_context::run() 함수가 호출되는 쓰레드가 2개 이상인 경우)를 사용하는 경우에는 핸들러를 동기화하기 위해 명시적인 Lock이 필요함.</li>
<li>이때 사용할 수 있는게 boost::asio::strand! 핸들러 내부에서 동기화를 위한 작업을 따로 해줄필요가 없다!</li>
</ul>
<br>
<br>

<span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎

<p><strong>Reference</strong></p>
<ul>
<li><a href="https://www.crazygaze.com/blog/2016/03/17/how-strands-work-and-why-you-should-use-them/">https://www.crazygaze.com/blog/2016/03/17/how-strands-work-and-why-you-should-use-them/</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>strands</tag>
        <tag>boost strand</tag>
        <tag>synchronization</tag>
        <tag>handler sync</tag>
      </tags>
  </entry>
  <entry>
    <title>자주 사용하진 않는데 필요할 때마다 매번 검색해서 찾아봐야하는 git 명령어</title>
    <url>/2024/10/27/tip-for-git-command/</url>
    <content><![CDATA[<p><escape><span id="more"></span></escape></p>
<!-- toc -->
<br>

<h3 id="1-다른-브랜치에-있는-커밋-내용을-가져오기"><a href="#1-다른-브랜치에-있는-커밋-내용을-가져오기" class="headerlink" title="1. 다른 브랜치에 있는 커밋 내용을 가져오기"></a>1. 다른 브랜치에 있는 커밋 내용을 가져오기</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout &#123;커밋 내용을 추가할 브랜치&#125;</span><br><span class="line">$ git cherry-pick &#123;커밋번호&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="2-Git-원격-저장소-주소-변경"><a href="#2-Git-원격-저장소-주소-변경" class="headerlink" title="2. Git 원격 저장소 주소 변경"></a>2. Git 원격 저장소 주소 변경</h3><ul>
<li><p>아래 커맨드를 통해 현재 remote 주소 정보를 확인할 수 있음</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure></li>
<li><p>원격 저장소 주소를 변경하는 커맨드는 아래와 같음</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote set-url origin &#123;변경할repo주소&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<h3 id="3-코드-수정-내역-확인하기"><a href="#3-코드-수정-내역-확인하기" class="headerlink" title="3. 코드 수정 내역 확인하기"></a>3. 코드 수정 내역 확인하기</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git blame &#123;파일명&#125;</span><br><span class="line">$ git blame -L 시작라인번호,종료라인번호 &#123;파일명&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>아래 커맨드를 통해 특정 커밋의 세부 변경 사항을 확인할 수 있음<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git show &#123;커밋번호&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<h3 id="4-commit없이-변경-사항-임시-저장하기"><a href="#4-commit없이-변경-사항-임시-저장하기" class="headerlink" title="4. commit없이 변경 사항 임시 저장하기"></a>4. commit없이 변경 사항 임시 저장하기</h3><ul>
<li><p>아래 커맨드를 통해 현재 브랜치의 변경 사항을 임시 저장할 수 있음</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git stash</span><br></pre></td></tr></table></figure></li>
<li><p>아래 커맨드를 통해 현재 stash 목록을 확인할 수 있음</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on feature/add_wkloggerimpl: 917106b1 Merge branch &#x27;fix/edlpinterface_segfault&#x27; into &#x27;dist&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p>아래 커맨드를 통해 임시 저장된 변경 사항을 브랜치에 다시 반영할 수 있음</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git stash pop stash@&#123;0&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<p><strong>Reference</strong></p>
<ul>
<li><a href="https://git-scm.com/docs">https://git-scm.com/docs</a></li>
</ul>
]]></content>
      <categories>
        <category>유용한 팁</category>
      </categories>
      <tags>
        <tag>git command</tag>
        <tag>git stash</tag>
        <tag>git cherry-pick</tag>
        <tag>git blame</tag>
        <tag>git remote</tag>
      </tags>
  </entry>
</search>
