
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta name="google-site-verification" content="Ojz5tvI9WuN6pn2n6i1E_mOkMyRiSSOp4KXuYSyaUjs">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="첼시팬 개발자 작업 공간">
    <title>boost::io_context 실행 모델에 대해 알아보자 - 첼시팬 개발자 작업 공간</title>
    <meta name="author" content="첼시팬개발자">
    
    
        <link rel="icon" href="https://chelseafandev.github.io/assets/images/chelsea_favicon.png">
    
    
        
            <link rel="alternate" type="application/rss+xml" title="RSS" href="/rss2.xml">
        
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"첼시팬개발자","sameAs":[],"image":"profile_github.jpeg"},"articleBody":"뭐하는 놈인지는 알고 쓰자 시리즈의 네번째 주제는 boost io_context 실행 모델입니다.\n\n\nexecution model where you launch N threads for the same io_context class instance.와 execution model where you create N pairs of “1 io_context + 1 thread”에 포스팅된 내용을 바탕으로 작성되었으니 참고부탁드립니다.\n\n\n\n\n\n\nN개의 쓰레드에서 1개의 io_context를 사용하는 실행 모델멀티 쓰레드 접근 방식에 뛰어들기 위한 가장 간단한 방법은 각각의 쓰레드들에서 동일한 io_context 객체에 대해서 io_context::run 멤버 함수를 실행하는 것입니다.\n\nThe simplest way to jump into a multithreaded approach is to run io_context::run member function on multiple threads with the same io_context object.\n\ncpp123456789101112131415161718192021222324#define BOOST_ASIO_NO_DEPRECATED#include &lt;boost/asio.hpp&gt;// ...io::io_context io_context;// Prepare thingsstd::vector&lt;std::thread&gt; threads;auto count = std::thread::hardware_concurrency() * 2;for(int n = 0; n &lt; count; ++n){    threads.emplace_back([&amp;]    {        io_context.run();    });}for(auto&amp; thread : threads){    if(thread.joinable())    {        thread.join();    }}\n\n이 경우에 io_context는 클래식한 쓰레드 풀과 같이 동작합니다. 비동기 작업들은 OS 측면의 어딘가에서 수행되지만 완료 핸들러는 io_context::run 함수가 실행중인 쓰레드들에서 발생하게 됩니다. 좀 더 정확히 말하자면: 모든 완료 핸들러는 io_context::run 함수가 실행 중인 최초의 유휴 상태 쓰레드에서 발생합니다.\n\nIn that case io_context operates like a classic thread pool. Asynchronous tasks are performed somewhere on the OS side, however completion handlers are invoked on those threads where io_context::run function is running. To be more precise: every completion handler is invoked on a first free thread which io_context::run function is running on.\n\n이것은 완료 핸들러가 병렬적으로 실행될 수 있다는 것을 의미합니다. 그리고 이것은 우리가 동기화가 필요한 지점에 도달했다는 것을 의미하기도 합니다.\n\nIt means that completion handlers could run in parallel. And this is, in turn, mean that we’ve reached a point where we need some synchronization.\n\n멀티쓰레드 환경에서 여러분이 동기화에 대해 신경써야하는 부분들을 줄일 수록 더 좋을 것입니다. 좋은 소식은 Boost.Asio를 활용한 멀티쓰레드 환경에서는 동기화를 위해 뮤텍스 또는 세마포어와 같은 엣지 로우 레벨 동기화 툴들이 필요하지 않다는 것입니다.\n\nThe less you have to care about synchronization in a multithreaded environment — the better. The good news is that we don’t need such edgy low-level synchronization tools like mutexes or semaphores to get things synchronized in the Boost.Asio multithreaded environment.\n\n여러분의 완료 핸들러를 적절하게 동기화하기 위해 필요한 것은 io_context::strand 클래스 인스턴스뿐입니다. 그것은 꽤 단순하게 동작합니다: 동일한 io_context::strand에 할당된 완료 핸들러는 순차적으로 실행될 것입니다. 그것들은 서로 다른 쓰레드들에서 실행되지만, 그것들의 실행은 순차적이게 될 것입니다. 이것은 그것들이 병렬적으로 처리되지 않을것이며 여러분이 동기화 처리를 해줄 필요가 없다는 것을 의미합니다.\n\nThe only thing you need to get your completion handlers synchronized properly is io_context::strand class instance. It works pretty simple: completion handlers attached to the same io_context::strand will be invoked serially. They could be invoked from different threads, however those invocations will be serialized. This means that things won’t go in parallel and you don’t have to deal with synchronization.\n\n따라서 여러분이 해야 할 일은 공유 데이터에서 작동하는 완료 핸들러와 동일한 io_context::strand에 연결되어야 하는 완료 핸들러, 그리고 이들 중 어느 것이 독립적이고 병렬적으로 처리할 수 있는지를 결정하는 것입니다. 여러분은 완료 핸들러를 strand로 감싸기위해 boost::asio::bind_executor 함수를 사용해야합니다. 예제를 살펴봅시다. 우리의 io_context::run 함수가 멀티 쓰레드 환경에서 실행중이라고 가정해보겠습니다.\n\nSo, everything you need to do is to decide which completion handlers operate on a shared data and should be attached to the same io_context::strand, and which of them are independent and can go in parallel. You should use boost::asio::bind_executor function to wrap a completion handler into a strand. Let’s look at the example. Assume that our io_context::run is running on multiple threads:\n\ncpp123456789101112131415161718192021222324252627282930313233343536373839class session{    session(io::io_context&amp; io_context)    : socket(io_context)    , read  (io_context)    , write (io_context)    {    }    void async_read()    {        io::async_read(socket, read_buffer, io::bind_executor(read, [&amp;] (error_code error, std::size_t bytes_transferred)        {            if(!error)            {                // ...                async_read();            }        }));    }    void async_write()    {        io::async_read(socket, write_buffer, io::bind_executor(write, [&amp;] (error_code error, std::size_t bytes_transferred)        {            if(!error)            {                // ...                async_write();            }        }));    }private:    tcp::socket socket;    io::io_context::strand read;    io::io_context::strand write;}\n\n위의 예제에서 우리는 2개의 strand를 사용했는데 하나는 read 연산을 다른 하나는 write 연산을 처리하기 위함입니다. 이것은 read 완료 핸들러와 write 완료 핸들러가 서로 다른 strand에서 직렬화 될 것이라는 것을 의미합니다. 또한 이것은 동일한 타입(여기서는 read냐 write냐)의 완료 핸들러들은 순차적으로 진행되나 read와 write 핸들러는 각각 병렬적으로 진행될 것이라는 의미이기도 합니다. 이것이 여러분이 제어 흐름을 동기적으로 유지하기 위해 해야할 전부입니다. 너무 간단하지 않은가요! 여러분이 strand를 적절하게 할당해주는 한 교착상태에 빠지거나 다른 일반적인 멀티쓰레딩 이슈가 발생할 수 없습니다.\n\nIn the example above we used two strands, one for reading and one for writing operations. This means that read completion handlers will be serialized with one strand and write handlers will be serialized with another strand. Which means that completion handlers of the same type will go serially, however read and write handlers will go in parallel to each other. And that’s all you need to keep your control flow synchronized, so simple! Note that you can’t get deadlocked here or run into other common multithreading issues. As long as you designate your strands properly.\n\n여러분은 주어진 strand안에서 여러분의 functor를 실행하기 위해 boost::asio::post 함수를 사용할 수도 있습니다.\n\nYou can also use boost::asio::post function with io_context::strand to execute your functors within a given strand:\n\ncpp1234io::post(read, []{    std::cout &lt;&lt; \"We're inside a read sequence, it's safe to access a read-related data here!\\n\";});\n\n\n\n1개의 io_context와 1개의 쓰레드 쌍을 N개 생성하는 실행 모델이전 강의에서 N개의 쓰레드를 하나의 io_context 클래스 객체에서 동작하도록 하는 실행 모델을 배워보았습니다. 이 경우에 io_context는 여러분을 위해 자체적으로 로드 밸런싱을 수행하며, 여러분은 다음 핸들러를 실행하기 위해 어떤 쓰레드를 사용해야하는지에 대해 신경 쓸 필요가 없습니다.\n\nIn the previous lesson we’ve learned an execution model where you launch N threads for the same io_context class instance. In that case io_context do load balancing for you, and you don’t need to care which thread should be used for the next handler to execute on.\n\n1개의 io_context와 1개의 쓰레드 쌍을 N개 생성하는 또 다른 실행 모델이 있습니다. 이 경우에 모든 쓰레드는 각자의 io_context 클래스 객체를 갖게됩니다. 아래 예제를 살펴봅시다. io_context group wrapper는 요청된 io_context, work guard 그리고 쓰레드 클래스 객체의 카운트 값을 생성합니다. 우리는 아래 예제를 통해 이 실행 모델에 대해 논의할 예정입니다.\n\nThere is another execution model where you create N pairs of “1 io_context + 1 thread” instead. In that case every thread has its own io_context class instance. Look at the example below. It’s io_context group wrapper which creates requested count of io_context, work guard and thread class instances. We will discuss this execution model below the example.\n\ncpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#define BOOST_ASIO_NO_DEPRECATED#include &lt;boost/asio.hpp&gt;#include &lt;thread&gt;namespace io = boost::asio;using tcp = io::ip::tcp;using work_guard_type = io::executor_work_guard&lt;io::io_context::executor_type&gt;;using error_code = boost::system::error_code;class io_context_group{public:    io_context_group(std::size_t size)    {        // Create io_context and work guard pairs        for(std::size_t n = 0; n &lt; size; ++n)        {            contexts.emplace_back(std::make_shared&lt;io::io_context&gt;());            guards.emplace_back(std::make_shared&lt;work_guard_type&gt;(contexts.back()-&gt;get_executor()));        }    }    void run()    {        // Create threads        for(auto&amp; io_context : contexts)        {            threads.emplace_back([&amp;]            {                io_context-&gt;run();            });        }        // Join threads        for(auto&amp; thread : threads)        {            thread.join();        }    }    // Round-robin io_context&amp; query    io::io_context&amp; query()    {        return *contexts[index++ % contexts.size()];    }private:    template &lt;typename T&gt;    using vector_ptr = std::vector&lt;std::shared_ptr&lt;T&gt;&gt;;    vector_ptr&lt;io::io_context&gt; contexts;    vector_ptr&lt;work_guard_type&gt; guards;    std::vector&lt;std::thread&gt; threads;    std::atomic&lt;std::size_t&gt; index = 0;};int main(){    io_context_group group(std::thread::hardware_concurrency() * 2);    tcp::socket socket(group.query());    // Schedule some tasks    group.run();    return 0;}\n\n여러분이 이 실행 모델에 관해 알아야하는 내용들:\n\nThings you should know about this execution model:\n\n여러분은 strands 또는 다른 어떤 동기화 도구들로 스트레스 받을 필요가 없습니다: 모든 io_context가 단일 쓰레드 내에서 실행되기때문에 동기화가 필요한 데이터가 없습니다. 물론 동일한 io_context 핸들러에서 동일한 데이터에 접근하는것에 한해서 입니다. 이러한 점은 플러스 요인으로 보입니다.\n\n💡 You don’t need to mess with strands or any other synchronization tools: since every io_context runs within a single thread, no data requires synchronization. As long as you access the same data from the same io_context handlers only. That looks like a plus.\n\nio_context에서 동작하는 socket이나 acceptor 등과 같은 객체들은 io_context 객체에 한 번만 바인딩됩니다. 여러분은 이러한 객체들의 생명주기 내에서는 또 다른 io_context에 다시 바인딩할 수 없습니다. 이 말은 곧 동일한 io_context에 바인딩된 모든 객체들은 단일 쓰레드 내에서 실행될 것이라는 것을 의미합니다. 이것이 그들이 모든 시간 동안에 동일한 CPU 코어에 바인딩된다는 의미는 아닙니다 - OS는 가장 적합한 코어라고 생각되는 곳에서 쓰레드를 실행하며 쓰레드의 생명주기 내에서 쓰레드의 코어가 변경될 수 있습니다. 하지만 쓰레드가 실행되는 코어가 어디냐에 관계없이 모든 io_context 객체들은 항상 (현재의)단일 코어 내에서 실행될 것입니다. 그래서 여러분은 하나의 코어가 100% 사용률을 보이는 반면 다른 코어들은 놀고 있는 상태인 상황을 직면할 수도 있습니다. 언뜻보기에 이것은 마이너스 요인처럼 보입니다.\n\n💡 Objects working on io_context, such as sockets, acceptors, etc, are bound to io_context object once. You can’t rebind any of them to another io_context within their lifetime. Which means that all objects bound to the same io_context will run within a single thread. This doesn’t mean that they’re bound to the same hardware CPU core all the time — an operating system runs a thread on the most suitable core and may change a thread’s core within a thread’s lifetime. However wherever that thread is running, all io_context objects will always run within a single (current) core. So you may face a situation when one core runs at 100% load while the others are idle. At a first glance that’s look like a minus.\n\n진짜 마이너스 요인은 이러한 사실 자체(하나의 코어가 100% 사용률을 보이는 반면 다른 코어들은 놀고 있는 상태)라기 보다는 선택한 밸런싱 알고리즘 또는 특정한 이용 사례에 대한 실행 모델의 부적절한 사용의 결과라고 볼 수 있습니다. 이전에 살펴본 1:N 실행 모델의 경우에는 자체적으로 여러분에게 밸런싱을 제공해주는 반면, 이 모델은 어플리케이션(또는 라이브러리) 개발자에 의해 구현되는 밸런싱 알고리즘을 요구하게 됩니다.\n\n💡 Well, it’s not really a minus of the execution model itself, but a minus of a balancing algorithm chosen or a result of improper usage of the execution model for a specific use-case. While the execution model from the previous lesson do balancing for you, this lesson’s model requires balancing algorithm to be implemented by the application (or a library) developer.\n\n이전 강의에서 살펴본 1:N 실행 모델은 범용적으로 사용되는 모델입니다. 여러분이 선택해야하는 밸런싱 알고리즘이 무엇인지 모르겠는 상황이라면 이 모델을 선택하시면 됩니다. 위에서 살펴본 1:1 실행 모델은 더 빠르게 동작할 수 있습니다. 하지만 이것은 특별한 케이스에 대해서만 알맞은 선택입니다: 여러분의 어플리케이션이 또 다른 어플리케이션과 몇가지 특별한 방식으로 상호작용하는 경우에. 그리고 이 특별한 방식은 적절한 밸런싱 알고리즘을 요구합니다. 위에서 본 예제에서는 라운드로빈 알고리즘을 사용했고, 일반적으로 그 알고리즘이 나쁘다 혹은 좋다라고 말할 수는 없습니다 - 이 알고리즘이 적절한지에 대한 판단은 다른 어플리케이션과의 상호작용 방식이 무엇이냐에 따라 달라집니다. 예를 들어, 우리의 어플리케이션이 많은 랜덤한 가벼운 작업들을 처리하는 경우라면 자동화된 밸런서보다 더 나은 해결책일 수 있습니다. 하지만 이러한 판단을 명확히 하는것은 쉽지 않습니다. 커스텀 밸런서의 다른 이용 사례나 디자인 패턴들은 이번 강의의 범위를 벗어나는 내용입니다. 이것들에 대해서는 나중에 다루어보도록 하겠습니다. 다시 한번: 여러분이 어떠한 타입의 실행 모델을 사용해야할지 확신이 서지 않는다면 이전 강의에서 살펴본 1:N 실행 모델을 선택하는것이 바람직합니다.\n\n💡 The execution model from the previous lesson is a universal one. Pick it if you don’t really know what balancing algorithm you should choose. The execution model from the current lesson may work faster though. However it best fit for special cases only: when your application interacts with other applications in some of special ways. And those special ways require a proper balancing algorithms. In the example above we used a round-robin algorithm, and we can’t really say if that algorithm is bad or good in general — that depends on a way of interaction of our application with other applications. For example, if our application handles a lot of random lightweight tasks then it could be a better solution than the automatic balancer. However things could be not as obvious as they’re appear to be at a first glance. Different use-cases and design patterns of a custom balancer is out of scope of this lesson. We will discuss them some later. Once again: if you’re not sure what type of execution model you should choose then pick an automatic one from the previous lesson.\n\n\n\n마치며지금까지 boost::io_context의 실행 모델(execution model)에 대해 알아보았습니다. 아래와 같이 정리해보며 해당 포스팅은 여기서 마치도록 하겠습니다.\n\nboost::io_context의 실행 모델이란 하나의 어플리케이션에서 특정한 작업을 수행하는 thread와 그 쓰레드를 구동하는 공간인 io_context간의 관계를 규정해놓은 것이다.\nboost::io_context의 실행 모델에는 1:N 방식과 1:1 방식이 있다. (io_context:thread)\n1:N 실행 모델의 경우에는 N개의 쓰레드를 하나의 io_context에서 처리하는 구조이다.\n1:1 실행 모델의 경우에는 모든 쓰레드가 각자의 io_context를 갖는 구조이다.\n1:N 실행 모델은 N개의 쓰레드들에 대해서 자체적인 로드 밸런싱을 제공하지만, 1:1 실행 모델의 경우에는 그렇지 않다(적절한 밸런싱 알고리즘을 개발자가 선택해서 적용해야함).\n어떠한 타입의 실행 모델을 사용해야할지 확신이 서지 않는다면 1:N 모델을 택하라.\n\n\n\n\n해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다😎\n\nReference\n\nhttps://dens.website/tutorials/cpp-asio/multithreading\nhttps://dens.website/tutorials/cpp-asio/multithreading-2\n\n","dateCreated":"2023-05-19T11:32:32+09:00","dateModified":"2023-07-02T22:23:21+09:00","datePublished":"2023-05-19T11:32:32+09:00","description":"뭐하는 놈인지는 알고 쓰자 시리즈의 네번째 주제는 boost io_context 실행 모델입니다.","headline":"boost::io_context 실행 모델에 대해 알아보자","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://chelseafandev.github.io/2023/05/19/multithreaded-execution/"},"publisher":{"@type":"Organization","name":"첼시팬개발자","sameAs":[],"image":"profile_github.jpeg","logo":{"@type":"ImageObject","url":"profile_github.jpeg"}},"url":"https://chelseafandev.github.io/2023/05/19/multithreaded-execution/","keywords":"boost asio, io_context, thread, execution model"}</script>
    <meta name="description" content="뭐하는 놈인지는 알고 쓰자 시리즈의 네번째 주제는 boost io_context 실행 모델입니다.">
<meta property="og:type" content="blog">
<meta property="og:title" content="boost::io_context 실행 모델에 대해 알아보자">
<meta property="og:url" content="https://chelseafandev.github.io/2023/05/19/multithreaded-execution/index.html">
<meta property="og:site_name" content="첼시팬 개발자 작업 공간">
<meta property="og:description" content="뭐하는 놈인지는 알고 쓰자 시리즈의 네번째 주제는 boost io_context 실행 모델입니다.">
<meta property="og:locale" content="ko_KR">
<meta property="article:published_time" content="2023-05-19T02:32:32.000Z">
<meta property="article:modified_time" content="2023-07-02T13:23:21.669Z">
<meta property="article:author" content="첼시팬개발자">
<meta property="article:tag" content="boost asio">
<meta property="article:tag" content="io_context">
<meta property="article:tag" content="thread">
<meta property="article:tag" content="execution model">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://chelseafandev.github.io/assets/images/profile_github.jpeg">
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/all.css">

    
<link rel="stylesheet" href="/assets/css/jquery.fancybox.css">

    
<link rel="stylesheet" href="/assets/css/thumbs.css">

    
<link rel="stylesheet" href="/assets/css/tranquilpeak.css">

    <!--STYLES END-->
    

    

    
        
    
    <link rel="canonical" href="https://chelseafandev.github.io/2023/05/19/multithreaded-execution/">
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/" aria-label>
            첼시팬 개발자 작업 공간
        </a>
    </div>
    
        
            <a class="header-right-picture " href="#about" aria-label="링크 열기: /#about">
        
        
            <img class="header-picture" src="/assets/images/profile_github.jpeg" alt="저자 이미지">
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4" style="border-top-width: 100px;padding-top: 150px;">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about" aria-label="저자에 대해 더 알아보기">
                    <img class="sidebar-profile-picture" src="/assets/images/profile_github.jpeg" alt="저자 이미지">
                </a>
                <h4 class="sidebar-profile-name">첼시팬개발자</h4>
                
                    <h5 class="sidebar-profile-bio"><p>조금 더디더라도 꾸준히</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/" rel="noopener" title="전체글">
                        <i class="sidebar-button-icon fas fa-list-ul" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">전체글</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-categories" rel="noopener" title="카테고리">
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">카테고리</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-tags" rel="noopener" title="태그">
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">태그</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-archives" rel="noopener" title="아카이브">
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">아카이브</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://github.com/chelseafandev" target="_blank" rel="external nofollow noopener noreferrer" title="GitHub">
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/rss2.xml" rel="noopener" title="RSS">
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4" class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            boost::io_context 실행 모델에 대해 알아보자
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2023-05-19T11:32:32+09:00">
	
		    2023/05/19 11:32:32
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/%EA%B8%B0%EC%88%A0%EB%AC%B8%EC%84%9C-%EB%B2%88%EC%97%AD/">기술문서 번역</a>


    
    
        -
        <span class="reading-time">⏱</span>
        
            읽는데 13 분 정도 소요 예상
        
        
    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p><em><strong>뭐하는 놈인지는 알고 쓰자</strong></em> 시리즈의 네번째 주제는 <code>boost io_context 실행 모델</code>입니다.</p>
<span id="more"></span>

<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://dens.website/tutorials/cpp-asio/multithreading">execution model where you launch N threads for the same io_context class instance.</a>와 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://dens.website/tutorials/cpp-asio/multithreading-2">execution model where you create N pairs of “1 io_context + 1 thread”</a>에 포스팅된 내용을 바탕으로 작성되었으니 참고부탁드립니다.</p>
<br>

<h1 id="table-of-contents">목차</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#N%EA%B0%9C%EC%9D%98-%EC%93%B0%EB%A0%88%EB%93%9C%EC%97%90%EC%84%9C-1%EA%B0%9C%EC%9D%98-io-context%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%8B%A4%ED%96%89-%EB%AA%A8%EB%8D%B8"><span class="toc-number">1.</span> <span class="toc-text">N개의 쓰레드에서 1개의 io_context를 사용하는 실행 모델</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EA%B0%9C%EC%9D%98-io-context%EC%99%80-1%EA%B0%9C%EC%9D%98-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%8C%8D%EC%9D%84-N%EA%B0%9C-%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94-%EC%8B%A4%ED%96%89-%EB%AA%A8%EB%8D%B8"><span class="toc-number">2.</span> <span class="toc-text">1개의 io_context와 1개의 쓰레드 쌍을 N개 생성하는 실행 모델</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%A7%88%EC%B9%98%EB%A9%B0"><span class="toc-number">3.</span> <span class="toc-text">마치며</span></a></li></ol>

<br>

<h2 id="N개의-쓰레드에서-1개의-io-context를-사용하는-실행-모델"><a href="#N개의-쓰레드에서-1개의-io-context를-사용하는-실행-모델" class="headerlink" title="N개의 쓰레드에서 1개의 io_context를 사용하는 실행 모델"></a>N개의 쓰레드에서 1개의 io_context를 사용하는 실행 모델</h2><p>멀티 쓰레드 접근 방식에 뛰어들기 위한 가장 간단한 방법은 각각의 쓰레드들에서 동일한 io_context 객체에 대해서 io_context::run 멤버 함수를 실행하는 것입니다.</p>
<blockquote>
<p>The simplest way to jump into a multithreaded approach is to run io_context::run member function on multiple threads with the same io_context object.</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOOST_ASIO_NO_DEPRECATED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">io::io_context io_context;</span><br><span class="line"><span class="comment">// Prepare things</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line"><span class="keyword">auto</span> count = <span class="built_in">std</span>::thread::hardware_concurrency() * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; count; ++n)</span><br><span class="line">{</span><br><span class="line">    threads.emplace_back([&amp;]</span><br><span class="line">    {</span><br><span class="line">        io_context.run();</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; thread : threads)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(thread.joinable())</span><br><span class="line">    {</span><br><span class="line">        thread.join();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>이 경우에 io_context는 클래식한 쓰레드 풀과 같이 동작합니다. 비동기 작업들은 OS 측면의 어딘가에서 수행되지만 완료 핸들러는 io_context::run 함수가 실행중인 쓰레드들에서 발생하게 됩니다. 좀 더 정확히 말하자면: 모든 완료 핸들러는 io_context::run 함수가 실행 중인 최초의 유휴 상태 쓰레드에서 발생합니다.</p>
<blockquote>
<p>In that case io_context operates like a classic thread pool. Asynchronous tasks are performed somewhere on the OS side, however completion handlers are invoked on those threads where io_context::run function is running. To be more precise: every completion handler is invoked on a first free thread which io_context::run function is running on.</p>
</blockquote>
<p>이것은 완료 핸들러가 병렬적으로 실행될 수 있다는 것을 의미합니다. 그리고 이것은 우리가 동기화가 필요한 지점에 도달했다는 것을 의미하기도 합니다.</p>
<blockquote>
<p>It means that completion handlers could run in parallel. And this is, in turn, mean that we’ve reached a point where we need some synchronization.</p>
</blockquote>
<p>멀티쓰레드 환경에서 여러분이 동기화에 대해 신경써야하는 부분들을 줄일 수록 더 좋을 것입니다. 좋은 소식은 Boost.Asio를 활용한 멀티쓰레드 환경에서는 동기화를 위해 뮤텍스 또는 세마포어와 같은 엣지 로우 레벨 동기화 툴들이 필요하지 않다는 것입니다.</p>
<blockquote>
<p>The less you have to care about synchronization in a multithreaded environment — the better. The good news is that we don’t need such edgy low-level synchronization tools like mutexes or semaphores to get things synchronized in the Boost.Asio multithreaded environment.</p>
</blockquote>
<p>여러분의 완료 핸들러를 적절하게 동기화하기 위해 필요한 것은 io_context::strand 클래스 인스턴스뿐입니다. 그것은 꽤 단순하게 동작합니다: 동일한 io_context::strand에 할당된 완료 핸들러는 순차적으로 실행될 것입니다. 그것들은 서로 다른 쓰레드들에서 실행되지만, 그것들의 실행은 순차적이게 될 것입니다. 이것은 그것들이 병렬적으로 처리되지 않을것이며 여러분이 동기화 처리를 해줄 필요가 없다는 것을 의미합니다.</p>
<blockquote>
<p>The only thing you need to get your completion handlers synchronized properly is io_context::strand class instance. It works pretty simple: completion handlers attached to the same io_context::strand will be invoked serially. They could be invoked from different threads, however those invocations will be serialized. This means that things won’t go in parallel and you don’t have to deal with synchronization.</p>
</blockquote>
<p>따라서 여러분이 해야 할 일은 공유 데이터에서 작동하는 완료 핸들러와 동일한 io_context::strand에 연결되어야 하는 완료 핸들러, 그리고 이들 중 어느 것이 독립적이고 병렬적으로 처리할 수 있는지를 결정하는 것입니다. 여러분은 완료 핸들러를 strand로 감싸기위해 boost::asio::bind_executor 함수를 사용해야합니다. 예제를 살펴봅시다. 우리의 io_context::run 함수가 멀티 쓰레드 환경에서 실행중이라고 가정해보겠습니다.</p>
<blockquote>
<p>So, everything you need to do is to decide which completion handlers operate on a shared data and should be attached to the same io_context::strand, and which of them are independent and can go in parallel. You should use boost::asio::bind_executor function to wrap a completion handler into a strand. Let’s look at the example. Assume that our io_context::run is running on multiple threads:</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">session</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    session(io::io_context&amp; io_context)</span><br><span class="line">    : socket(io_context)</span><br><span class="line">    , read  (io_context)</span><br><span class="line">    , write (io_context)</span><br><span class="line">    {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">async_read</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        io::async_read(socket, read_buffer, io::bind_executor(read, [&amp;] (error_code error, <span class="built_in">std</span>::<span class="keyword">size_t</span> bytes_transferred)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(!error)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                async_read();</span><br><span class="line">            }</span><br><span class="line">        }));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">async_write</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        io::async_read(socket, write_buffer, io::bind_executor(write, [&amp;] (error_code error, <span class="built_in">std</span>::<span class="keyword">size_t</span> bytes_transferred)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(!error)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                async_write();</span><br><span class="line">            }</span><br><span class="line">        }));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    tcp::socket socket;</span><br><span class="line">    io::io_context::strand read;</span><br><span class="line">    io::io_context::strand write;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>위의 예제에서 우리는 2개의 strand를 사용했는데 하나는 read 연산을 다른 하나는 write 연산을 처리하기 위함입니다. 이것은 read 완료 핸들러와 write 완료 핸들러가 서로 다른 strand에서 직렬화 될 것이라는 것을 의미합니다. 또한 이것은 동일한 타입(여기서는 read냐 write냐)의 완료 핸들러들은 순차적으로 진행되나 read와 write 핸들러는 각각 병렬적으로 진행될 것이라는 의미이기도 합니다. 이것이 여러분이 제어 흐름을 동기적으로 유지하기 위해 해야할 전부입니다. 너무 간단하지 않은가요! 여러분이 strand를 적절하게 할당해주는 한 교착상태에 빠지거나 다른 일반적인 멀티쓰레딩 이슈가 발생할 수 없습니다.</p>
<blockquote>
<p>In the example above we used two strands, one for reading and one for writing operations. This means that read completion handlers will be serialized with one strand and write handlers will be serialized with another strand. Which means that completion handlers of the same type will go serially, however read and write handlers will go in parallel to each other. And that’s all you need to keep your control flow synchronized, so simple! Note that you can’t get deadlocked here or run into other common multithreading issues. As long as you designate your strands properly.</p>
</blockquote>
<p>여러분은 주어진 strand안에서 여러분의 functor를 실행하기 위해 boost::asio::post 함수를 사용할 수도 있습니다.</p>
<blockquote>
<p>You can also use boost::asio::post function with io_context::strand to execute your functors within a given strand:</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">io::post(read, []</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"We're inside a read sequence, it's safe to access a read-related data here!\n"</span>;</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure></div></figure>

<br>

<h2 id="1개의-io-context와-1개의-쓰레드-쌍을-N개-생성하는-실행-모델"><a href="#1개의-io-context와-1개의-쓰레드-쌍을-N개-생성하는-실행-모델" class="headerlink" title="1개의 io_context와 1개의 쓰레드 쌍을 N개 생성하는 실행 모델"></a>1개의 io_context와 1개의 쓰레드 쌍을 N개 생성하는 실행 모델</h2><p>이전 강의에서 N개의 쓰레드를 하나의 io_context 클래스 객체에서 동작하도록 하는 실행 모델을 배워보았습니다. 이 경우에 io_context는 여러분을 위해 자체적으로 로드 밸런싱을 수행하며, 여러분은 다음 핸들러를 실행하기 위해 어떤 쓰레드를 사용해야하는지에 대해 신경 쓸 필요가 없습니다.</p>
<blockquote>
<p>In the previous lesson we’ve learned an execution model where you launch N threads for the same io_context class instance. In that case io_context do load balancing for you, and you don’t need to care which thread should be used for the next handler to execute on.</p>
</blockquote>
<p>1개의 io_context와 1개의 쓰레드 쌍을 N개 생성하는 또 다른 실행 모델이 있습니다. 이 경우에 모든 쓰레드는 각자의 io_context 클래스 객체를 갖게됩니다. 아래 예제를 살펴봅시다. io_context group wrapper는 요청된 io_context, work guard 그리고 쓰레드 클래스 객체의 카운트 값을 생성합니다. 우리는 아래 예제를 통해 이 실행 모델에 대해 논의할 예정입니다.</p>
<blockquote>
<p>There is another execution model where you create N pairs of “1 io_context + 1 thread” instead. In that case every thread has its own io_context class instance. Look at the example below. It’s io_context group wrapper which creates requested count of io_context, work guard and thread class instances. We will discuss this execution model below the example.</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOOST_ASIO_NO_DEPRECATED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> io = boost::asio;</span><br><span class="line"><span class="keyword">using</span> tcp = io::ip::tcp;</span><br><span class="line"><span class="keyword">using</span> work_guard_type = io::executor_work_guard&lt;io::io_context::executor_type&gt;;</span><br><span class="line"><span class="keyword">using</span> error_code = boost::system::error_code;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">io_context_group</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    io_context_group(<span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Create io_context and work guard pairs</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="keyword">size_t</span> n = <span class="number">0</span>; n &lt; size; ++n)</span><br><span class="line">        {</span><br><span class="line">            contexts.emplace_back(<span class="built_in">std</span>::make_shared&lt;io::io_context&gt;());</span><br><span class="line">            guards.emplace_back(<span class="built_in">std</span>::make_shared&lt;work_guard_type&gt;(contexts.back()-&gt;get_executor()));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// Create threads</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; io_context : contexts)</span><br><span class="line">        {</span><br><span class="line">            threads.emplace_back([&amp;]</span><br><span class="line">            {</span><br><span class="line">                io_context-&gt;run();</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Join threads</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; thread : threads)</span><br><span class="line">        {</span><br><span class="line">            thread.join();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Round-robin io_context&amp; query</span></span><br><span class="line">    <span class="function">io::io_context&amp; <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> *contexts[index++ % contexts.size()];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">using</span> vector_ptr = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    vector_ptr&lt;io::io_context&gt; contexts;</span><br><span class="line">    vector_ptr&lt;work_guard_type&gt; guards;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt; index = <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">io_context_group <span class="title">group</span><span class="params">(<span class="built_in">std</span>::thread::hardware_concurrency() * <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">tcp::socket <span class="title">socket</span><span class="params">(group.query())</span></span>;</span><br><span class="line">    <span class="comment">// Schedule some tasks</span></span><br><span class="line">    group.run();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>여러분이 이 실행 모델에 관해 알아야하는 내용들:</p>
<blockquote>
<p>Things you should know about this execution model:</p>
</blockquote>
<p>여러분은 strands 또는 다른 어떤 동기화 도구들로 스트레스 받을 필요가 없습니다: 모든 io_context가 단일 쓰레드 내에서 실행되기때문에 동기화가 필요한 데이터가 없습니다. 물론 동일한 io_context 핸들러에서 동일한 데이터에 접근하는것에 한해서 입니다. 이러한 점은 플러스 요인으로 보입니다.</p>
<blockquote>
<p>💡 You don’t need to mess with strands or any other synchronization tools: since every io_context runs within a single thread, no data requires synchronization. As long as you access the same data from the same io_context handlers only. That looks like a plus.</p>
</blockquote>
<p>io_context에서 동작하는 socket이나 acceptor 등과 같은 객체들은 io_context 객체에 한 번만 바인딩됩니다. 여러분은 이러한 객체들의 생명주기 내에서는 또 다른 io_context에 다시 바인딩할 수 없습니다. 이 말은 곧 동일한 io_context에 바인딩된 모든 객체들은 단일 쓰레드 내에서 실행될 것이라는 것을 의미합니다. 이것이 그들이 모든 시간 동안에 동일한 CPU 코어에 바인딩된다는 의미는 아닙니다 - OS는 가장 적합한 코어라고 생각되는 곳에서 쓰레드를 실행하며 쓰레드의 생명주기 내에서 쓰레드의 코어가 변경될 수 있습니다. 하지만 쓰레드가 실행되는 코어가 어디냐에 관계없이 모든 io_context 객체들은 항상 (현재의)단일 코어 내에서 실행될 것입니다. 그래서 여러분은 하나의 코어가 100% 사용률을 보이는 반면 다른 코어들은 놀고 있는 상태인 상황을 직면할 수도 있습니다. 언뜻보기에 이것은 마이너스 요인처럼 보입니다.</p>
<blockquote>
<p>💡 Objects working on io_context, such as sockets, acceptors, etc, are bound to io_context object once. You can’t rebind any of them to another io_context within their lifetime. Which means that all objects bound to the same io_context will run within a single thread. This doesn’t mean that they’re bound to the same hardware CPU core all the time — an operating system runs a thread on the most suitable core and may change a thread’s core within a thread’s lifetime. However wherever that thread is running, all io_context objects will always run within a single (current) core. So you may face a situation when one core runs at 100% load while the others are idle. At a first glance that’s look like a minus.</p>
</blockquote>
<p>진짜 마이너스 요인은 이러한 사실 자체(하나의 코어가 100% 사용률을 보이는 반면 다른 코어들은 놀고 있는 상태)라기 보다는 선택한 밸런싱 알고리즘 또는 특정한 이용 사례에 대한 실행 모델의 부적절한 사용의 결과라고 볼 수 있습니다. 이전에 살펴본 1:N 실행 모델의 경우에는 자체적으로 여러분에게 밸런싱을 제공해주는 반면, 이 모델은 어플리케이션(또는 라이브러리) 개발자에 의해 구현되는 밸런싱 알고리즘을 요구하게 됩니다.</p>
<blockquote>
<p>💡 Well, it’s not really a minus of the execution model itself, but a minus of a balancing algorithm chosen or a result of improper usage of the execution model for a specific use-case. While the execution model from the previous lesson do balancing for you, this lesson’s model requires balancing algorithm to be implemented by the application (or a library) developer.</p>
</blockquote>
<p>이전 강의에서 살펴본 1:N 실행 모델은 범용적으로 사용되는 모델입니다. 여러분이 선택해야하는 밸런싱 알고리즘이 무엇인지 모르겠는 상황이라면 이 모델을 선택하시면 됩니다. 위에서 살펴본 1:1 실행 모델은 더 빠르게 동작할 수 있습니다. 하지만 이것은 특별한 케이스에 대해서만 알맞은 선택입니다: 여러분의 어플리케이션이 또 다른 어플리케이션과 몇가지 특별한 방식으로 상호작용하는 경우에. 그리고 이 특별한 방식은 적절한 밸런싱 알고리즘을 요구합니다. 위에서 본 예제에서는 라운드로빈 알고리즘을 사용했고, 일반적으로 그 알고리즘이 나쁘다 혹은 좋다라고 말할 수는 없습니다 - 이 알고리즘이 적절한지에 대한 판단은 다른 어플리케이션과의 상호작용 방식이 무엇이냐에 따라 달라집니다. 예를 들어, 우리의 어플리케이션이 많은 랜덤한 가벼운 작업들을 처리하는 경우라면 자동화된 밸런서보다 더 나은 해결책일 수 있습니다. 하지만 이러한 판단을 명확히 하는것은 쉽지 않습니다. 커스텀 밸런서의 다른 이용 사례나 디자인 패턴들은 이번 강의의 범위를 벗어나는 내용입니다. 이것들에 대해서는 나중에 다루어보도록 하겠습니다. 다시 한번: 여러분이 어떠한 타입의 실행 모델을 사용해야할지 확신이 서지 않는다면 이전 강의에서 살펴본 1:N 실행 모델을 선택하는것이 바람직합니다.</p>
<blockquote>
<p>💡 The execution model from the previous lesson is a universal one. Pick it if you don’t really know what balancing algorithm you should choose. The execution model from the current lesson may work faster though. However it best fit for special cases only: when your application interacts with other applications in some of special ways. And those special ways require a proper balancing algorithms. In the example above we used a round-robin algorithm, and we can’t really say if that algorithm is bad or good in general — that depends on a way of interaction of our application with other applications. For example, if our application handles a lot of random lightweight tasks then it could be a better solution than the automatic balancer. However things could be not as obvious as they’re appear to be at a first glance. Different use-cases and design patterns of a custom balancer is out of scope of this lesson. We will discuss them some later. Once again: if you’re not sure what type of execution model you should choose then pick an automatic one from the previous lesson.</p>
</blockquote>
<br>

<h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>지금까지 boost::io_context의 실행 모델(execution model)에 대해 알아보았습니다. 아래와 같이 정리해보며 해당 포스팅은 여기서 마치도록 하겠습니다.<br><br></p>
<ul>
<li>boost::io_context의 실행 모델이란 하나의 어플리케이션에서 특정한 작업을 수행하는 <em><strong>thread</strong></em>와 그 쓰레드를 구동하는 공간인 <em><strong>io_context</strong></em>간의 관계를 규정해놓은 것이다.</li>
<li>boost::io_context의 실행 모델에는 1:N 방식과 1:1 방식이 있다. (io_context:thread)</li>
<li>1:N 실행 모델의 경우에는 N개의 쓰레드를 하나의 io_context에서 처리하는 구조이다.</li>
<li>1:1 실행 모델의 경우에는 모든 쓰레드가 각자의 io_context를 갖는 구조이다.</li>
<li>1:N 실행 모델은 N개의 쓰레드들에 대해서 자체적인 로드 밸런싱을 제공하지만, 1:1 실행 모델의 경우에는 그렇지 않다(적절한 밸런싱 알고리즘을 개발자가 선택해서 적용해야함).</li>
<li>어떠한 타입의 실행 모델을 사용해야할지 확신이 서지 않는다면 1:N 모델을 택하라.</li>
</ul>
<br>
<br>

<span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎

<p><strong>Reference</strong></p>
<ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://dens.website/tutorials/cpp-asio/multithreading">https://dens.website/tutorials/cpp-asio/multithreading</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://dens.website/tutorials/cpp-asio/multithreading-2">https://dens.website/tutorials/cpp-asio/multithreading-2</a></li>
</ul>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">태그</span><br>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/boost-asio/" rel="tag">boost asio</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/execution-model/" rel="tag">execution model</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/io-context/" rel="tag">io_context</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/thread/" rel="tag">thread</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a class="post-action-btn btn btn--default tooltip--top" href="/2023/09/12/what-is-strand/" data-tooltip="boost strand를 사용하는 이유" aria-label="이전: boost strand를 사용하는 이유">
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a class="post-action-btn btn btn--default tooltip--top" href="/2023/05/12/impl-big-integer-in-cpp/" data-tooltip="boost::multiprecision을 활용하여 Java의 BigInteger 흉내내기" aria-label="다음: boost::multiprecision을 활용하여 Java의 BigInteger 흉내내기">
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="이 포스트 공유하기">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://chelseafandev.github.io/2023/05/19/multithreaded-execution/" title="Facebook에 공유하기" aria-label="Facebook에 공유하기" rel="external nofollow noopener noreferrer">
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="_blank" href="https://twitter.com/intent/tweet?text=https://chelseafandev.github.io/2023/05/19/multithreaded-execution/" title="Twitter에 공유하기" aria-label="Twitter에 공유하기" rel="external nofollow noopener noreferrer">
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="_blank" href="https://plus.google.com/share?url=https://chelseafandev.github.io/2023/05/19/multithreaded-execution/" title="Google+에 공유하기" aria-label="Google+에 공유하기" rel="external nofollow noopener noreferrer">
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="목차">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



<!-- Comment -->
<!--  utteranc comment -->

<script src="https://utteranc.es/client.js" repo="chelseafandev/blog-comment" issue-term="title" label="Comment" theme="github-light" crossorigin="anonymous" async>
</script>

                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2024 첼시팬개발자. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a class="post-action-btn btn btn--default tooltip--top" href="/2023/09/12/what-is-strand/" data-tooltip="boost strand를 사용하는 이유" aria-label="이전: boost strand를 사용하는 이유">
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a class="post-action-btn btn btn--default tooltip--top" href="/2023/05/12/impl-big-integer-in-cpp/" data-tooltip="boost::multiprecision을 활용하여 Java의 BigInteger 흉내내기" aria-label="다음: boost::multiprecision을 활용하여 Java의 BigInteger 흉내내기">
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="이 포스트 공유하기">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://chelseafandev.github.io/2023/05/19/multithreaded-execution/" title="Facebook에 공유하기" aria-label="Facebook에 공유하기" rel="external nofollow noopener noreferrer">
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="_blank" href="https://twitter.com/intent/tweet?text=https://chelseafandev.github.io/2023/05/19/multithreaded-execution/" title="Twitter에 공유하기" aria-label="Twitter에 공유하기" rel="external nofollow noopener noreferrer">
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="_blank" href="https://plus.google.com/share?url=https://chelseafandev.github.io/2023/05/19/multithreaded-execution/" title="Google+에 공유하기" aria-label="Google+에 공유하기" rel="external nofollow noopener noreferrer">
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="목차">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a class="share-option-btn" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://chelseafandev.github.io/2023/05/19/multithreaded-execution/" aria-label="Facebook에 공유하기" rel="external nofollow noopener noreferrer">
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Facebook에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a class="share-option-btn" target="_blank" href="https://twitter.com/intent/tweet?text=https://chelseafandev.github.io/2023/05/19/multithreaded-execution/" aria-label="Twitter에 공유하기" rel="external nofollow noopener noreferrer">
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Twitter에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a class="share-option-btn" target="_blank" href="https://plus.google.com/share?url=https://chelseafandev.github.io/2023/05/19/multithreaded-execution/" aria-label="Google+에 공유하기" rel="external nofollow noopener noreferrer">
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Google+에 공유하기</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/profile_github.jpeg" alt="저자 이미지">
        
            <h4 id="about-card-name">첼시팬개발자</h4>
        
            <div id="about-card-bio"><p>조금 더디더라도 꾸준히</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>개발자</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br>
                서울, 대한민국
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="external nofollow noopener noreferrer" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="/assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search" class="form-control input--large search-input" placeholder="Search ">
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">포스트가 없습니다.</div>
            <div class="results">
                
                <div class="media">
                    <!--  -->
                    <div class="media-body">
                        <a class="link-unstyled" href="https://chelseafandev.github.io/2021/07/08/hello-hexo/" aria-label=": Hexo Tranquilpeak 테마의 Markdown syntax">
                            <h3 class="media-heading">Hexo Tranquilpeak 테마의 Markdown syntax</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2021년 7월 8일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-nanumsquareround"><p>Hexo 테마 중 하나인 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak/blob/master/DOCUMENTATION.md">Tranquilpeak의 공식 문서</a>를 참조하여 Post시에 활용할 수 있는 다양한 Markdown syntax들을 사용해보았습니다.</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    <!-- 
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="https://chelseafandev.github.io/2021/07/10/tr-ruud-gullit/"
                            aria-label=": (BBC 스포츠) 첼시 루드 굴리트 25년이 지난 지금 그의 프리미어그리 진출을 애정어린 시선으로 되돌아 보다"
                        >
                            <img class="media-image" src="https://chelseafandev.github.io/2021/07/10/tr-ruud-gullit/tr_ruud_gullit_picture_1.png" width="90" height="90"/>
                        </a>
                    </div>
                     -->
                    <div class="media-body">
                        <a class="link-unstyled" href="https://chelseafandev.github.io/2021/07/10/tr-ruud-gullit/" aria-label=": (BBC 스포츠) 첼시 루드 굴리트 25년이 지난 지금 그의 프리미어그리 진출을 애정어린 시선으로 되돌아 보다">
                            <h3 class="media-heading">(BBC 스포츠) 첼시 루드 굴리트 25년이 지난 지금 그의 프리미어그리 진출을 애정어린 시선으로 되돌아 보다</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2021년 7월 10일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-nanumsquareround"><p>피파 좀 한다는 사람이라면 모두가 다 알만한 그 분, X사기캐 굴리트😬<br>커리어 막바지에 첼시에서도 잠깐 활약했었네요.<br><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.bbc.com/sport/football/52904670">BBC Sport에 굴리트가 직접 기고한 회고록 느낌의 글</a>을 한번 번역해보았습니다.</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    <!--  -->
                    <div class="media-body">
                        <a class="link-unstyled" href="https://chelseafandev.github.io/2021/07/13/os-io-system/" aria-label=": I/O는 어떻게 처리될까?">
                            <h3 class="media-heading">I/O는 어떻게 처리될까?</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2021년 7월 13일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-nanumsquareround"><p>운영 체제의 바이블 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.wiley.com/en-us/Operating+System+Concepts%2C+10th+Edition-p-9781119320913">Operating System Concepts</a>(흔히 공룡책🦕이라고들 하죠)을 바탕으로 I/O 시스템에 대해 정리해보았습니다.</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    <!--  -->
                    <div class="media-body">
                        <a class="link-unstyled" href="https://chelseafandev.github.io/2021/07/22/tip-how-to-use-tmux-md/" aria-label=": 강력한 터미널 멀티플렉서 tmux를 활용해보자">
                            <h3 class="media-heading">강력한 터미널 멀티플렉서 tmux를 활용해보자</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2021년 7월 22일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-nanumsquareround"><p>이번엔 익숙해지면 정말 강력한 터미널 멀티플렉서인 tmux에 대해 소개해보려고 합니다.</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    <!--  -->
                    <div class="media-body">
                        <a class="link-unstyled" href="https://chelseafandev.github.io/2021/08/02/os-sync-async-block-nonblock/" aria-label=": Blocking, Nonblocking, Sync, Async">
                            <h3 class="media-heading">Blocking, Nonblocking, Sync, Async</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2021년 8월 2일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-nanumsquareround"><p>오늘은 공룡책🦕에 언급된 Blocking과 Nonblocking, Synchronous와 Asynchronous에 대해서 정리해보고자 합니다. Synchronous와 Asynchronous의 개념은 <strong>쓰레드</strong>와 <strong>I/O</strong>에서 등장하게 되는데요, 각각이 어떠한 의미로 사용되는지도 구분해서 살펴보도록 하겠습니다.</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    <!-- 
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="https://chelseafandev.github.io/2021/08/05/tr-lukaku-want-to-chelsea/"
                            aria-label=": (BBC 스포츠) 첼시의 물망에 오른 루카쿠 적절한 오퍼가 온다면 인터 밀란을 떠나기 원해"
                        >
                            <img class="media-image" src="https://chelseafandev.github.io/2021/08/05/tr-lukaku-want-to-chelsea/tr-lukaku-want-to-chelsea.jpg" width="90" height="90"/>
                        </a>
                    </div>
                     -->
                    <div class="media-body">
                        <a class="link-unstyled" href="https://chelseafandev.github.io/2021/08/05/tr-lukaku-want-to-chelsea/" aria-label=": (BBC 스포츠) 첼시의 물망에 오른 루카쿠 적절한 오퍼가 온다면 인터 밀란을 떠나기 원해">
                            <h3 class="media-heading">(BBC 스포츠) 첼시의 물망에 오른 루카쿠 적절한 오퍼가 온다면 인터 밀란을 떠나기 원해</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2021년 8월 5일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-nanumsquareround"><p>오늘은 첼시 이적설이 가까워져가고 있는 루카쿠 관련 기사를 가져왔습니다. 베르너의 결정력이 너무나도 아쉬웠던 지난 시즌 첼시를 생각하면 꼭 필요한 영입이라고 생각되네요😁</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    <!-- 
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="https://chelseafandev.github.io/2021/08/12/tr-son-new-contract/"
                            aria-label=": (BBC 스포츠) 토트넘 공격수 손흥민 4년 재계약 성사"
                        >
                            <img class="media-image" src="https://chelseafandev.github.io/2021/08/12/tr-son-new-contract/tr-son-new-contract-figure1.jpg" width="90" height="90"/>
                        </a>
                    </div>
                     -->
                    <div class="media-body">
                        <a class="link-unstyled" href="https://chelseafandev.github.io/2021/08/12/tr-son-new-contract/" aria-label=": (BBC 스포츠) 토트넘 공격수 손흥민 4년 재계약 성사">
                            <h3 class="media-heading">(BBC 스포츠) 토트넘 공격수 손흥민 4년 재계약 성사</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2021년 8월 12일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-nanumsquareround"><p>오늘은 현재 프리미어리그 토트넘 핫스퍼에서 활약 중인 손흥민 선수의 재계약 관련 기사를 가져왔습니다. 다음 시즌 누누감독이 이끌게 되는 토트넘, 쌉월클👍 손흥민선수와 함께 좋은 성적 거뒀으면 좋겠습니다.</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    <!--  -->
                    <div class="media-body">
                        <a class="link-unstyled" href="https://chelseafandev.github.io/2021/09/24/hyperscan-phase1/" aria-label=": 인텔 Hyperscan 레퍼런스 가이드 번역">
                            <h3 class="media-heading">인텔 Hyperscan 레퍼런스 가이드 번역</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2021년 9월 24일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-nanumsquareround"><p>이번 포스팅에서는 인텔 Hyperscan의 <a target="_blank" rel="external nofollow noopener noreferrer" href="http://intel.github.io/hyperscan/dev-reference/index.html">공식 문서</a>를 통해 컴파일(compile)이나 스캔(scan)과 같은 Hyperscan의 기본적인 개념들에 대해 알아보도록 하겠습니다. 추후에는 Hyperscan API를 직접 사용하여 정규 표현식 패턴 매칭을 수행하는 샘플 코드도 업로드할 예정입니다.</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    <!--  -->
                    <div class="media-body">
                        <a class="link-unstyled" href="https://chelseafandev.github.io/2021/10/12/hyperscan-phase2/" aria-label=": 인텔 Hyperscan API 테스트 코드 작성">
                            <h3 class="media-heading">인텔 Hyperscan API 테스트 코드 작성</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2021년 10월 12일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-nanumsquareround"><p>이번 포스팅에서는 <a href="https://chelseafandev.github.io/2021/09/24/hyperscan-phase1/">인텔 Hyperscan 레퍼런스 가이드 번역</a>에 이어서 Hyperscan API를 직접 사용하여 정규 표현식 패턴 매칭을 수행하는 샘플 코드를 작성하고 테스트 해보는 시간을 갖겠습니다.</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    <!--  -->
                    <div class="media-body">
                        <a class="link-unstyled" href="https://chelseafandev.github.io/2021/11/09/gdb-chapter4-program-crash/" aria-label=": Seg Fault는 왜 발생하는가?">
                            <h3 class="media-heading">Seg Fault는 왜 발생하는가?</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2021년 11월 9일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-nanumsquareround"><p>이번 포스팅에서는 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://nostarch.com/debugging.htm">The Art of Debugging with GDB, DDD and Eclipse</a>의 <strong>Chatper 4 WHEN A PROGRAM CRASHES</strong> 내용을 번역해보았습니다. 해당 챕터의 앞부분에서는 가상 주소 공간에서의 페이지(page)에 대한 개념을 소개하고 seg fault가 발생하는 원인을 페이지(page)와 연관지어 잘 설명해주고 있습니다.</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium" data-message-zero="포스트가 없습니다." data-message-one="1 개의 포스트가 있습니다." data-message-other="{n} 개의 포스트가 있습니다.">
                28 개의 포스트가 있습니다.
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/chelsea_cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/jquery.js"></script>


<script src="/assets/js/jquery.fancybox.js"></script>


<script src="/assets/js/thumbs.js"></script>


<script src="/assets/js/tranquilpeak.js"></script>

<!--SCRIPTS END-->


    



    
<script src="/assets/js/moment-with-locales.js"></script>

    
<script src="/assets/js/algoliasearch.js"></script>

    <script>
      var algoliaClient = algoliasearch('FDTOJ7KLS8', '935491408ac4c43d728c68858e4ea147');
      var algoliaIndex = algoliaClient.initIndex('chelseafandev');
    </script>


    </body>
</html>
