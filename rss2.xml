<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>첼시팬 개발자 작업 공간</title>
    <link>https://chelseafandev.github.io/</link>
    
    <atom:link href="https://chelseafandev.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>더디더라도 꾸준히</description>
    <pubDate>Sun, 27 Oct 2024 06:39:57 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>자주 사용하진 않는데 필요할 때마다 매번 검색해서 찾아봐야하는 git 명령어</title>
      <link>https://chelseafandev.github.io/2024/10/27/tip-for-git-command/</link>
      <guid>https://chelseafandev.github.io/2024/10/27/tip-for-git-command/</guid>
      <pubDate>Sun, 27 Oct 2024 06:39:57 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;escape&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><escape><span id="more"></span></escape></p><!-- toc --><br><h3 id="1-다른-브랜치에-있는-커밋-내용을-가져오기"><a href="#1-다른-브랜치에-있는-커밋-내용을-가져오기" class="headerlink" title="1. 다른 브랜치에 있는 커밋 내용을 가져오기"></a>1. 다른 브랜치에 있는 커밋 내용을 가져오기</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout &#123;커밋 내용을 추가할 브랜치&#125;</span><br><span class="line">$ git cherry-pick &#123;커밋번호&#125;</span><br></pre></td></tr></table></figure><br><h3 id="2-Git-원격-저장소-주소-변경"><a href="#2-Git-원격-저장소-주소-변경" class="headerlink" title="2. Git 원격 저장소 주소 변경"></a>2. Git 원격 저장소 주소 변경</h3><ul><li><p>아래 커맨드를 통해 현재 remote 주소 정보를 확인할 수 있음</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure></li><li><p>원격 저장소 주소를 변경하는 커맨드는 아래와 같음</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote set-url origin &#123;변경할repo주소&#125;</span><br></pre></td></tr></table></figure></li></ul><br><h3 id="3-코드-수정-내역-확인하기"><a href="#3-코드-수정-내역-확인하기" class="headerlink" title="3. 코드 수정 내역 확인하기"></a>3. 코드 수정 내역 확인하기</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &#123;파일명&#125;</span><br><span class="line">$ git blame -L 시작라인번호,종료라인번호 &#123;파일명&#125;</span><br></pre></td></tr></table></figure><ul><li>아래 커맨드를 통해 특정 커밋의 세부 변경 사항을 확인할 수 있음<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git show &#123;커밋번호&#125;</span><br></pre></td></tr></table></figure></li></ul><br><h3 id="4-commit없이-변경-사항-임시-저장하기"><a href="#4-commit없이-변경-사항-임시-저장하기" class="headerlink" title="4. commit없이 변경 사항 임시 저장하기"></a>4. commit없이 변경 사항 임시 저장하기</h3><ul><li><p>아래 커맨드를 통해 현재 브랜치의 변경 사항을 임시 저장할 수 있음</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br></pre></td></tr></table></figure></li><li><p>아래 커맨드를 통해 현재 stash 목록을 확인할 수 있음</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on feature/add_wkloggerimpl: 917106b1 Merge branch &#x27;fix/edlpinterface_segfault&#x27; into &#x27;dist&#x27;</span><br></pre></td></tr></table></figure></li><li><p>아래 커맨드를 통해 임시 저장된 변경 사항을 브랜치에 다시 반영할 수 있음</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop stash@&#123;0&#125;</span><br></pre></td></tr></table></figure></li></ul><br><p><strong>Reference</strong></p><ul><li><a href="https://git-scm.com/docs">https://git-scm.com/docs</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://chelseafandev.github.io/categories/%EC%9C%A0%EC%9A%A9%ED%95%9C-%ED%8C%81/">유용한 팁</category>
      
      
      <category domain="https://chelseafandev.github.io/tags/git-command/">git command</category>
      
      <category domain="https://chelseafandev.github.io/tags/git-stash/">git stash</category>
      
      <category domain="https://chelseafandev.github.io/tags/git-cherry-pick/">git cherry-pick</category>
      
      <category domain="https://chelseafandev.github.io/tags/git-blame/">git blame</category>
      
      <category domain="https://chelseafandev.github.io/tags/git-remote/">git remote</category>
      
      
      <comments>https://chelseafandev.github.io/2024/10/27/tip-for-git-command/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>기본적인 Go 프로젝트 레이아웃</title>
      <link>https://chelseafandev.github.io/2024/07/28/my-golang-layout/</link>
      <guid>https://chelseafandev.github.io/2024/07/28/my-golang-layout/</guid>
      <pubDate>Sun, 28 Jul 2024 07:04:34 GMT</pubDate>
      
      <description>&lt;p&gt;제가 사용하는 기본적인 Go 프로젝트 레이아웃에 대해 간략히 소개하기 위해 해당 포스팅을 작성하게 되었습니다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>제가 사용하는 기본적인 Go 프로젝트 레이아웃에 대해 간략히 소개하기 위해 해당 포스팅을 작성하게 되었습니다.</p><span id="more"></span><br><!-- toc --><br><h1 id="프로젝트-레이아웃이-필요한-이유는"><a href="#프로젝트-레이아웃이-필요한-이유는" class="headerlink" title="프로젝트 레이아웃이 필요한 이유는?"></a>프로젝트 레이아웃이 필요한 이유는?</h1><p>최초 프로젝트 설계자가 아닌 또 다른 누군가가 유지보수를 담당하게되는 경우(대부분의 소프트웨어 개발 회사의 상황일 것으로 생각됨) 프로젝트 레이아웃이 명확하지 않은 경우에는 전체 구조를 파악하기가 어려울 뿐만아니라 의도치 않은 방향으로 소스 코드가 추가될 수 있습니다.</p><br><h1 id="Go-코드를-어떻게-작성해야하는가"><a href="#Go-코드를-어떻게-작성해야하는가" class="headerlink" title="Go 코드를 어떻게 작성해야하는가?"></a>Go 코드를 어떻게 작성해야하는가?</h1><p>먼저 Golang 공식 홈페이지에서 제공하고 있는 Go 코드 작성 가이드를 통해 패키지(package)와 모듈(module)에 대한 개념을 먼저 잡아보도록 하겠습니다. (<a href="https://go.dev/doc/code">해당 링크</a>를 통해 원문을 확인하실 수 있습니다.)</p><h2 id="Code-organization"><a href="#Code-organization" class="headerlink" title="Code organization"></a>Code organization</h2><p>Go 프로그램은 패키지들로 구성됩니다. 여기서 *패키지(package)*란 함께 컴파일되는 동일 디렉토리 내의 소스 파일들의 집합입니다. 패키지 내 하나의 소스 파일 안에 정의된 함수, 타입, 변수 그리고 상수들은 동일한 패키지 내에 있는 다른 모든 소스 파일들에서 접근이 가능합니다.</p><blockquote><p>Go programs are organized into packages. A package is a collection of source files in the same directory that are compiled together. Functions, types, variables, and constants defined in one source file are visible to all other source files within the same package.</p></blockquote><p>하나의 저장소는 한 개 이상의 모듈들을 포함하고 있습니다. 여기서 *모듈(module)*이란 함께 배포되는 연관된 Go 패키지들의 집합입니다. Go 저장소는 일반적으로 하나의 모듈만을 포함하며 이 모듈은 저장소의 root 경로에 존재합니다. 저장소의 root 경로에 go.mod 라는 이름의 파일에서는 모듈 경로를 선언해주는데 이 경로는 모듈 내에 존재하는 모든 패키지들의 임포트 경로의 접두사(prefix)로 사용됩니다. 모듈은 go.mod 파일이 포함된 디렉토리에 존재하는 패키지들뿐만아니라 그 디렉토리들의 하위 디렉토리에 존재하는 패키지들까지 포함합니다.(만약 go.mod 파일이 두 개 이상 존재하는 경우라면 또 다른 go.mod 파일이 존재하는 다음 하위 디렉토리 전까지를 포함함)</p><blockquote><p>A repository contains one or more modules. A module is a collection of related Go packages that are released together. A Go repository typically contains only one module, located at the root of the repository. A file named go.mod there declares the module path: the import path prefix for all packages within the module. The module contains the packages in the directory containing its go.mod file as well as subdirectories of that directory, up to the next subdirectory containing another go.mod file (if any).</p></blockquote><p>여러분의 소스 코드를 빌드하기 전에 이것을 원격 저장소에 배포할 필요는 없습니다. 모듈은 원격 저장소에서 관리되지 않더라도 로컬에서 정의될 수 있습니다. 하지만 미래의 배포 가능성을 열어두고 여러분의 소스 코드를 조직화하는 것은 좋은 습관입니다.</p><blockquote><p>Note that you don’t need to publish your code to a remote repository before you can build it. A module can be defined locally without belonging to a repository. However, it’s a good habit to organize your code as if you will publish it someday.</p></blockquote><p>각 모듈의 경로 정보는 해당 모듈에 포함된 패키지들의 임포트 경로의 접두사(prefix)를 제공할 뿐만 아니라, go 명령어가 해당 모듈을 다운로드하기 위해 바라봐야할 위치를 가리킵니다. 예를 들어, golang.org/x/tools 라는 모듈을 다운로드 하기위해서는 go 명령어가 <a href="https://golang.org/x/tools%EA%B0%80">https://golang.org/x/tools가</a> 가리키는 저장소를 참고할 것입니다.</p><blockquote><p>Each module’s path not only serves as an import path prefix for its packages, but also indicates where the go command should look to download it. For example, in order to download the module golang.org/x/tools, the go command would consult the repository indicated by <a href="https://golang.org/x/tools">https://golang.org/x/tools</a> (described more here).</p></blockquote><p>임포트 경로는 패키지를 임포트하기 위해 사용됩니다. 패키지의 임포트 경로는 해당 패키지의 모듈 경로와 모듈 내에 존재하는 연결된 하위 디렉토리 경로입니다. 에를 들어, github.com/google/go-cmp 모듈은 cmp/ 디렉토리 안의 패키지를 포함합니다. 그 패키지의 임포트 경로는 github.com/google/go-cmp/cmp 입니다. 스탠다드 라이브러리 내의 패키지들은 모듈 경로 접두사를 가지고 있지 않습니다.</p><blockquote><p>An import path is a string used to import a package. A package’s import path is its module path joined with its subdirectory within the module. For example, the module github.com/google/go-cmp contains a package in the directory cmp/. That package’s import path is github.com/google/go-cmp/cmp. Packages in the standard library do not have a module path prefix.</p></blockquote><h2 id="Your-first-program"><a href="#Your-first-program" class="headerlink" title="Your first program"></a>Your first program</h2><p>단순한 프로그램을 컴파일하고 실행하기 위해 먼저 모듈 경로(example/user/hello라는 경로를 사용할 예정)를 선택하고, 그 경로를 선언하고 있는 go.mod 파일을 생성합니다.  </p><blockquote><p>To compile and run a simple program, first choose a module path (we’ll use example/user/hello) and create a go.mod file that declares it:</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir hello # Alternatively, clone it <span class="keyword">if</span> it already exists in version control.</span><br><span class="line">$ cd hello</span><br><span class="line">$ <span class="keyword">go</span> mod init example/user/hello</span><br><span class="line"><span class="keyword">go</span>: creating <span class="built_in">new</span> <span class="keyword">go</span>.mod: module example/user/hello</span><br><span class="line">$ cat <span class="keyword">go</span>.mod</span><br><span class="line">module example/user/hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.16</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>Go 소스 파일의 첫번째 문장으로는 패키지 이름이 작성돼야합니다. 실행 가능한 명령어는 항상 main 패키지를 사용해야 합니다.</p><blockquote><p>The first statement in a Go source file must be package name. Executable commands must always use package main.</p></blockquote><p>다음으로 해당 디렉토리 내에 아래 Go 코드를 포함하는 hello.go 파일을 생성합니다.</p><blockquote><p>Next, create a file named hello.go inside that directory containing the following Go code:</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, world.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 여러분은 go tool을 사용해서 프로그램을 빌드하고 설치할 수 있습니다.</p><blockquote><p>Now you can build and install that program with the go tool:</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> install example/user/hello</span><br></pre></td></tr></table></figure><p>이 명령어는 hello 명령어를 빌드하고, 실행가능한 바이너리를 생성합니다. 그리고나서 그 바이너리 파일을 $HOME/go/bin/hello 경로에 설치합니다.</p><blockquote><p>This command builds the hello command, producing an executable binary. It then installs that binary as $HOME/go/bin/hello.</p></blockquote><p>설치 경로는 GOPATH와 GOBIN 환경 변수를 통해 조절할 수 있습니다. 만약 GOBIN 환경 변수가 설정이되었다면, 바이너리 파일은 그 경로에 설치될것입니다. 만약 GOPATH가 설정되었다면, 바이너리 파일은 GOPATH 리스트의 첫번째 디렉토리의 bin 이라는 하위 디렉토리에 설치될 것 입니다. 두 환경 변수 모두 설정되지 않은 경우라면, 바이너리 파일은 기본 GOPATH 경로($HOME/go)에 설치될 것 입니다.</p><blockquote><p>The install directory is controlled by the GOPATH and GOBIN environment variables. If GOBIN is set, binaries are installed to that directory. If GOPATH is set, binaries are installed to the bin subdirectory of the first directory in the GOPATH list. Otherwise, binaries are installed to the bin subdirectory of the default GOPATH ($HOME/go).</p></blockquote><p>여러분은 추후에 사용될 go 커맨드가 참조할 수 있는 환경 변수의 기본 값을 go env 명령어를 통해 설정할 수 있습니다.</p><blockquote><p>You can use the go env command to portably set the default value for an environment variable for future go commands:</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> env -w GOBIN=/somewhere/<span class="keyword">else</span>/bin</span><br></pre></td></tr></table></figure><p>go env -w를 통해 이전에 설정한 값을 해제하고 싶은 경우에는 go env -u를 사용하면 됩니다.</p><blockquote><p>To unset a variable previously set by go env -w, use go env -u:</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> env -u GOBIN</span><br></pre></td></tr></table></figure><p>go install과 같은 명령어는 현재 작업 경로를 포함하고 있는 모듈의 컨텍스트 내에 적용됩니다. 만약 작업 경로가 example/user/hello 모듈 내부가 아니라면, go insall 명령어는 실패할 것 입니다.</p><blockquote><p>Commands like go install apply within the context of the module containing the current working directory. If the working directory is not within the example/user/hello module, go install may fail.</p></blockquote><p>편리성을 위해 go 명령어는 작업 경로에 상대적인 경로를 허용하고, 다른 경로가 주언진 경우가 아니라면 현재 작업 경로의 패키지를 기본으로 사용합니다. 그래서 현재 우리의 작업 경로에서는, 아래 명령어들이 모두 동일한 결과를 갖습니다.</p><blockquote><p>For convenience, go commands accept paths relative to the working directory, and default to the package in the current working directory if no other path is given. So in our working directory, the following commands are all equivalent:</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> install example/user/hello</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> install .</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> install</span><br></pre></td></tr></table></figure><p>다음으로 정상적으로 동작하는지 확인해보기 위해 프로그램을 실행해봅시다. 바이너리를 쉽게 실행하기 위해 PATH 환경 변수에 설치 경로를 추가할 것 입니다.</p><blockquote><p>Next, let’s run the program to ensure it works. For added convenience, we’ll add the install directory to our PATH to make running binaries easy:</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Windows users should consult /wiki/SettingGOPATH</span><br><span class="line"># <span class="keyword">for</span> setting %PATH%.</span><br><span class="line">$ export PATH=$PATH:$(dirname $(<span class="keyword">go</span> list -f <span class="string">&#x27;&#123;&#123;.Target&#125;&#125;&#x27;</span> .))</span><br><span class="line">$ hello</span><br><span class="line">Hello, world.</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h2 id="Importing-packages-from-your-module"><a href="#Importing-packages-from-your-module" class="headerlink" title="Importing packages from your module"></a>Importing packages from your module</h2><p>morestrings 패키지를 작성하고 그 패키지를 hello 프로그램에서 사용하도록 해봅시다. 먼저 해당 패키지를 저장할 $HOME/hello/morestrings 디렉토리를 생성해줍니다. 그리고나서 아래 내용을 포함하는 reverse.go 라는 파일을 그 디렉토리 내에서 생성해줍시다.</p><blockquote><p>Let’s write a morestrings package and use it from the hello program. First, create a directory for the package named $HOME/hello/morestrings, and then a file named reverse.go in that directory with the following contents:</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package morestrings implements additional functions to manipulate UTF-8</span></span><br><span class="line"><span class="comment">// encoded strings, beyond what is provided in the standard &quot;strings&quot; package.</span></span><br><span class="line"><span class="keyword">package</span> morestrings</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReverseRunes returns its argument string reversed rune-wise left to right.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReverseRunes</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    r := []<span class="keyword">rune</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(r)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(r)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        r[i], r[j] = r[j], r[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReverseRunes() 함수는 대문자로 시작하기 때문에 morestring 패키지를 임포트한 또 다른 패키지들에서 해당 함수를 사용할 수 있습니다.</p><blockquote><p>Because our ReverseRunes function begins with an upper-case letter, it is exported, and can be used in other packages that import our morestrings package.</p></blockquote><p>go build로 morestrings 패키지를 컴파일 해봅시다.</p><blockquote><p>Let’s test that the package compiles with go build:</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd $HOME/hello/morestrings</span><br><span class="line">$ <span class="keyword">go</span> build</span><br></pre></td></tr></table></figure><p>위 명령어로는 어떠한 결과 파일이 생성되지는 않을 것입니다. 대신에 그것은 로컬 빌드 캐시에 컴파일된 패키지를 저장합니다.</p><blockquote><p>This won’t produce an output file. Instead it saves the compiled package in the local build cache.</p></blockquote><p>morestrings 패키지 빌드 이후에, hello 프로그램에서 이것을 사용해봅시다. 이를 위해 $HOME/hello/hello.go 코드에서 morestrings 패키지를 사용할 수 있도록 수정해봅시다.</p><blockquote><p>After confirming that the morestrings package builds, let’s use it from the hello program. To do so, modify your original $HOME/hello/hello.go to use the morestrings package:</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;example/user/hello/morestrings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(morestrings.ReverseRunes(<span class="string">&quot;!oG ,olleH&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hello 프로그램을 설치하고</p><blockquote><p>Install the hello program:</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> install example/user/hello</span><br></pre></td></tr></table></figure><p>새로운 버전의 hello 프로그램을 실행해보면 여러분은 뒤집힌 메시지를 볼 수 있을겁니다.</p><blockquote><p>Running the new version of the program, you should see a new, reversed message:</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hello</span><br><span class="line">Hello, Go!</span><br></pre></td></tr></table></figure><h2 id="Importing-packages-from-remote-modules"><a href="#Importing-packages-from-remote-modules" class="headerlink" title="Importing packages from remote modules"></a>Importing packages from remote modules</h2><p>임포트 경로는 버전 관리 시스템인 Git 이나 Mercurial을 사용하는 패키지 소스 코드를 어떻게 받아오는지를 설명할 수 있습니다. go tool은 원격 저장소에 있는 패키지들을 자동으로 가져오기 위해 이러한 특성을 사용합니다.</p><blockquote><p>An import path can describe how to obtain the package source code using a revision control system such as Git or Mercurial. The go tool uses this property to automatically fetch packages from remote repositories. For instance, to use github.com/google/go-cmp/cmp in your program:</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;example/user/hello/morestrings&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/google/go-cmp/cmp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(morestrings.ReverseRunes(<span class="string">&quot;!oG ,olleH&quot;</span>))</span><br><span class="line">    fmt.Println(cmp.Diff(<span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;Hello Go&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 여러분은 외부 모듈에 대한 의존성을 가지게 되었고, 그러한 모듈을 다운로드하고 그것의 버전 정보를 go.mode 파일 내에 기록할 필요가 있습니다. go mod tidy 명령어는 임포트 패키지들에 대한 누락된 모듈 요구사항들을 추가해주고 더이상 사용하지 않는 모듈들에 대한 요구사항들을 제거해줍니다. </p><blockquote><p>Now that you have a dependency on an external module, you need to download that module and record its version in your go.mod file. The go mod tidy command adds missing module requirements for imported packages and removes requirements on modules that aren’t used anymore.</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> mod tidy</span><br><span class="line"><span class="keyword">go</span>: finding module <span class="keyword">for</span> <span class="keyword">package</span> github.com/google/<span class="keyword">go</span>-cmp/cmp</span><br><span class="line"><span class="keyword">go</span>: found github.com/google/<span class="keyword">go</span>-cmp/cmp in github.com/google/<span class="keyword">go</span>-cmp v0<span class="number">.5</span><span class="number">.4</span></span><br><span class="line">$ <span class="keyword">go</span> install example/user/hello</span><br><span class="line">$ hello</span><br><span class="line">Hello, Go!</span><br><span class="line">  <span class="keyword">string</span>(</span><br><span class="line">-     <span class="string">&quot;Hello World&quot;</span>,</span><br><span class="line">+     <span class="string">&quot;Hello Go&quot;</span>,</span><br><span class="line">  )</span><br><span class="line">$ cat <span class="keyword">go</span>.mod</span><br><span class="line">module example/user/hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.16</span></span><br><span class="line"></span><br><span class="line">require github.com/google/<span class="keyword">go</span>-cmp v0<span class="number">.5</span><span class="number">.4</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>모듈 의존성은 GOPATH 환경 변수가 가리키는 경로의 하위 경로인 pkg/mod에 자동으로 다운로드 됩니다. 다운로드된 모듈의 버전 정보들은 해당 버전을 필요로 하는 다른 모든 모듈들에게 공유됩니다. 그래서 go 명령어는 이러한 파일과 디렉토리를 read-only로 표시합니다. 다운로드 받은 모든 모듈들을 삭제하기 위해서는 go clean 명령어에 -modcache 플래그를 전달해주면 됩니다. </p><blockquote><p>Module dependencies are automatically downloaded to the pkg/mod subdirectory of the directory indicated by the GOPATH environment variable. The downloaded contents for a given version of a module are shared among all other modules that require that version, so the go command marks those files and directories as read-only. To remove all downloaded modules, you can pass the -modcache flag to go clean:</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> clean -modcache</span><br></pre></td></tr></table></figure><br><h1 id="내가-사용하는-Go-프로젝트-레이아웃"><a href="#내가-사용하는-Go-프로젝트-레이아웃" class="headerlink" title="내가 사용하는 Go 프로젝트 레이아웃"></a>내가 사용하는 Go 프로젝트 레이아웃</h1><p>다양한 프로젝트 레이아웃들을 비교해본 끝에 <a href="https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html">Package Oriented Design</a>라는 포스팅을 참조하여 프로젝트 레이아웃을 구성해보기로 결정했고, 실제 현업에서 개발 중인 서비스를 이 구조에 맞춰서 구현해나갔습니다.</p><h2 id="bin"><a href="#bin" class="headerlink" title="bin/"></a>bin/</h2><ul><li>실행가능한 바이너리 파일이 생성되는 경로</li><li>바이너리 실행을 위해 필요한 설정 값이 저장되는 config 파일도 포함됨</li></ul><h2 id="cmd"><a href="#cmd" class="headerlink" title="cmd/"></a>cmd/</h2><ul><li>main 패키지를 포함하는 go 파일이 저장되는 경로</li></ul><h2 id="internal"><a href="#internal" class="headerlink" title="internal/"></a>internal/</h2><ul><li>main 패키지에서 임포트하는 패키지들의 집합이며, 제공하는 서비스 별로 패키지들을 구분함(ex. internal/gateway) </li></ul><p>동일 프로젝트 내에 존재하는 2개 이상의 프로그램들에서 임포트될 필요성이 있는 패키지들이 internal/ 폴더 내에 속해있습니다. internal/ 이라는 명칭의 사용이 가져다 주는 한가지 이점은 프로젝트가 컴파일러로부터 추가적인 보호 레벨을 얻어낼 수 있다는 점입니다. internal/ 폴더 내에 존재하는 패키지들을 해당 프로젝트의 외부에 있는 패키지에서 임포트할 수 없습니다. 그러므로 이러한 패키지들은 오로지 해당 프로젝트 내에 귀속됩니다.</p><blockquote><p>Packages that need to be imported by multiple programs within the project belong inside the internal/ folder. One benefit of using the name internal/ is that the project gets an extra level of protection from the compiler. No package outside of this project can import packages from inside of internal/. These packages are therefore internal to this project only.</p></blockquote><h2 id="internal-platform"><a href="#internal-platform" class="headerlink" title="internal/platform/"></a>internal/platform/</h2><ul><li>internal에 포함된 패키지들에서 공통적으로 사용할 수 있는 기능을 제공하는 패키지들의 집합</li></ul><p>기반이되는 그러나 프로젝트에 특정되는 패키지들이 internal/platform 폴더 내에 속해있습니다. 이러한 패키지들은 데이터베이스나 인증 또는 marshaling과 같은 기능들을 제공하곤 합니다.</p><blockquote><p>Packages that are foundational but specific to the project belong in the internal/platform/ folder. These would be packages that provide support for things like databases, authentication or even marshaling.</p></blockquote><br><h1 id="프로젝트-예시"><a href="#프로젝트-예시" class="headerlink" title="프로젝트 예시"></a>프로젝트 예시</h1><p>현재 토이 프로젝트로 진행중인 go 서비스에서도 위 프로젝트 레이아웃을 사용 중에 있습니다. <a href="https://github.com/chelseafandev/wavynote/tree/main">해당 링크</a>를 통해 확인 가능하십니다.</p><br><br><span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎<p><strong>Reference</strong></p><ul><li><a href="https://go.dev/doc/code">https://go.dev/doc/code</a></li><li><a href="https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html">https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://chelseafandev.github.io/categories/Go/">Go</category>
      
      
      <category domain="https://chelseafandev.github.io/tags/go-project-layout/">go project layout</category>
      
      <category domain="https://chelseafandev.github.io/tags/golang-layout/">golang layout</category>
      
      <category domain="https://chelseafandev.github.io/tags/how-to-write-go-code/">how to write go code</category>
      
      
      <comments>https://chelseafandev.github.io/2024/07/28/my-golang-layout/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>boost strand를 사용하는 이유</title>
      <link>https://chelseafandev.github.io/2023/09/12/what-is-strand/</link>
      <guid>https://chelseafandev.github.io/2023/09/12/what-is-strand/</guid>
      <pubDate>Tue, 12 Sep 2023 08:03:48 GMT</pubDate>
      
      <description>&lt;p&gt;이번 포스팅에서는 boost에서 제공하는 strand에 대해 알아보는 시간을 갖도록 하겠습니다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>이번 포스팅에서는 boost에서 제공하는 strand에 대해 알아보는 시간을 갖도록 하겠습니다.</p><span id="more"></span><p>strand에 대한 설명은 <a href="https://www.crazygaze.com/blog/2016/03/17/how-strands-work-and-why-you-should-use-them/">How strands work and why you should use them</a> 내용을 바탕으로 작성되었으니 참고부탁드리며, 글 하단에는 strand 동작을 검증하기 위한 예제 코드를 첨부하였으니 직접 테스트 해보시며 strand의 사용법과 필요성에 대해 다시 한번 정리하는 시간을 갖으면 좋을것같네요😁</p><br><!-- toc --><br><h2 id="How-strands-work-and-why-you-should-use-them"><a href="#How-strands-work-and-why-you-should-use-them" class="headerlink" title="How strands work and why you should use them"></a>How strands work and why you should use them</h2><p>만약 여러분이 Boost Asio를 사용해본적이 있다면, 틀림없이 <a href="https://www.boost.org/doc/libs/1_83_0/doc/html/boost_asio/overview/core/strands.html">strands</a> 라는 것을 사용해봤거나 최소한 마주치기라도 해봤을 것입니다.</p><blockquote><p>If you ever used Boost Asio, certainly you used or at least looked at <a href="https://www.boost.org/doc/libs/1_83_0/doc/html/boost_asio/overview/core/strands.html">strands</a>.</p></blockquote><p>strands 사용을 통해 얻을 수 있는 주요한 이점은 여러분의 소스 코드를 단순화해준다는 것입니다. 이러한 단순화는 strand를 통해 실행되는 핸들러에 대해서는 명시적인 동기화가 필요하지 않기때문에 가능합니다. strand는 2개의 핸들러가 동시에 실행되지않음을 보장합니다.</p><blockquote><p>The main benefit of using strands is to simplify your code, since handlers that go through a strand don’t need explicit synchronization. A strand guarantees that no two handlers execute concurrently.</p></blockquote><p>만약 여러분이 단지 하나의 I/O 쓰레드(boost 라이브러리 측면에서 설명하자면 io_context::run()을 호출하는 쓰레드가 오직 하나인 경우를 의미함)를 사용한다면, 동기화를 걱정할 필요가 전혀 없습니다. 그것이 이미 암묵적인 strand입니다. 하지만 여러분이 더 많은 I/O 쓰레드를 사용해야하는 순간이 온다면 I/O 쓰레드에서 실행되는 핸들러에 대해 명시적인 동기화 처리를 하거나 strands를 사용해야합니다.</p><blockquote><p>If you use just one I/O thread (or in Boost terms, just one thread calling io_context::run), then you don’t need synchronization anyway. That is already an implicit strand. But the moment you want to ramp up and have more I/O threads, you need to either deal with explicit synchronization for your handlers, or use strands.</p></blockquote><p>여러분이 정의한 핸들러를 명시적으로 동기화하는 것은 명백히 가능한 일이지만 이것은 불필요하게 여러분의 소스 코드에 복잡성을 부여하여 버그를 발생시킬 수도 있습니다. 핸들러의 명시적 동기화가 갖는 또 다른 영향도 중 하나는 여러분이 정말 신중하게 고려하지 않는 이상 불필요한 블록 구간의 발생이 불가피하다는 점입니다.</p><blockquote><p>Explicitly synchronizing your handlers is certainly possible, but you will be unnecessarily introducing complexity to your code which will certainly lead to bugs. One other effect of explicit handler synchronization is that unless you think really hard, you’ll very likely introduce unnecessary blocking.</p></blockquote><p>strands는 여러분의 소스 코드와 핸들러의 실행 사이에 또 다른 계층을 하나 둠으로써 동작합니다. 여러분의 핸들러를 직접적으로 실행하는 worker 쓰레드들을 갖는 대신에, 이러한 핸들러들이 strand 내의 큐에 저장됩니다. 그리고나서 strand는 모든 조건이 충족되었을 때에만 핸들러를 실행하도록 하는 제어 권한을 갖게됩니다.</p><blockquote><p>Strands work by introducing another layer between your application code and the handler execution. Instead of having the worker threads directly execute your handlers, those handlers are queued in a strand. The strand then has control over when executing the handlers so that all guarantees can be met.</p></blockquote><p>이것에 대해 생각해볼 수 있는 한가지 방법은 아래 그림과 같습니다.</p><blockquote><p>One way you can think about is like this:</p></blockquote><div class="figure " style="width:;"><img class="fig-img" src="/assets/images/what-is-strand-figure-1.png" alt=""></div><h3 id="Possible-scenario"><a href="#Possible-scenario" class="headerlink" title="Possible scenario"></a>Possible scenario</h3><p>I/O 쓰레드와 핸들러에 어떤 일이 발생하는지를 시각적으로 보여주기 위해 <a href="https://github.com/Celtoys/Remotery">Remotry</a>를 사용했습니다.</p><blockquote><p>To visually demonstrate what happens with the I/O threads and handlers, I’ve used <a href="https://github.com/Celtoys/Remotery">Remotery</a>.</p></blockquote><p>사용되는 코드는 4개의 worker 쓰레드와 8개의 connection을 에뮬레이트합니다. 5ms ~ 15ms 사이의 임의의 작업량을 갖는 핸들러(일종의 작업 항목)는 worker 큐에 놓이게됩니다. 실제로 여러분이 이러한 커넥션별 쓰레드비율 또는 핸들러 작업량을 갖지않더라도 해당 수치들은 문제를 보여주기에 용이합니다. 또한 저는 Boost Asio 라이브러리를 사용하지 않았고, 해당 글의 주제를 논의해나가기 위해 자체적으로 strand를 구현해보았습니다.</p><blockquote><p>The code used emulates 4 worker threads, and 8 connections. Handlers (aka work items) with a random workload of [5ms,15ms] for a random connection are placed in the worker queue. In practice, you would not have this threads/connections ratio or handler workload, but it makes it easier to demonstrate the problem. Also, I’m not using Boost Asio at all. It’s a custom strand implementation to explore the topic.</p></blockquote><p>아래 그림은 worker 쓰레드들의 상태를 보여줍니다:</p><blockquote><p>So, a view into the worker threads:</p></blockquote><div class="figure " style="width:;"><img class="fig-img" src="/assets/images/what-is-strand-figure-2.png" alt=""></div><p><code>Conn N</code>은 커넥션 객체를 의미합니다(또는 worker 쓰레드 상에서 작업을 수행하는 어떠한 객체). 각각의 커넥션 객체는 서로 다른 색상을 갖고있습니다. 보시다시피 겉보기에는 괜찮아 보입니다. 이제 각각의 Conn 객체의 실직적인 상태를 시분할 단위로 살펴보도록 하겠습니다.</p><blockquote><p>Conn N are our connection objects (or any object doing work in our worker threads for that matter). Each has a distinct colour. All good on the surface as you can see. Now lets look at what each Conn object is actually doing with its time slice.</p></blockquote><div class="figure " style="width:;"><img class="fig-img" src="/assets/images/what-is-strand-figure-3.png" alt=""></div><p>worker 큐와 쓰레드는 핸들러가 수행하는 작업을 인지하지 못하기때문에서 worker 쓰레드는 처리할 커넥션 객체가 들어오는 순간 기꺼이 큐에서 꺼내려 할 것입니다. 하나의 쓰레드에서 또 다른 worker 쓰레드에서 이미 사용되고 있는 커넥션 객체를 실행하려고 할 때, 그것은 block 상태에 놓이게될 것입니다. 현재의 시나리오에서는 전체 시간의 약 19% 정도가 block 상태 또는 또 다른 오버 헤드로 인해 낭비되고 있습니다. 다시 말해, 실질적으로 worker 쓰레드가 작업에 할당하는 시간이 전체의 약 81% 뿐이라는 것입니다:</p><blockquote><p>What is happening is the worker queue and worker threads are oblivious to what its handlers do (as expected), so the worker threads will happily dequeue work as it comes. One thread tries to execute work for a given Conn object which is already being used in another worker thread, so it has to block. In this scenario, ~19% of total time is wasted with blocking or other overhead. In other words, only ~81% of the worker thread’s time is spent doing actual work:</p></blockquote><div class="figure " style="width:;"><img class="fig-img" src="/assets/images/what-is-strand-figure-4.png" alt=""></div><p>오버 헤드는 worker 쓰레드 전체 시간에서 실제 작업 시간을 뺀 값으로 측정됩니다. 그렇기 때문에 핸들러 내의 명시적인 동기화 그리고 worker 큐/쓰레드 내부적으로 수행된 모든 동기화 작업들이 이 오버 헤드에 포함됩니다.</p><blockquote><p>NOTE: The overhead was measured by subtracting actual work time from the total worker thread’s time. So it accounts for explicit synchronization in the handlers and any work/synchronization done internally by the worker queue/threads.</p></blockquote><p>이제 커넥션 객체의 작업을 동기화하기 위해 strands를 사용하는 경우의 상태 값을 살펴봅시다.</p><blockquote><p>Lets see how it looks like if we use strands to serialize work for our Conn objects:</p></blockquote><div class="figure " style="width:;"><img class="fig-img" src="/assets/images/what-is-strand-figure-5.png" alt=""></div><div class="figure " style="width:;"><img class="fig-img" src="/assets/images/what-is-strand-figure-6.png" alt=""></div><p>내부 작업 또는 동기화에 낭비되는 시간이 매우 작다는것을 알 수 있습니다.</p><blockquote><p>Very little time is wasted with internal work or synchronization.</p></blockquote><br><h3 id="Cache-locality"><a href="#Cache-locality" class="headerlink" title="Cache locality"></a>Cache locality</h3><p>strands를 사용하는 경우에 얻을 수 있는 또 하나의 작은 이점은 더 나은 CPU 캐시 활용입니다. worker 쓰레드는 또 다른 커넥션 객체를 가지고 오기 전에 현재 주어진 커넥션 객체의 핸들러를 더 많이 실행하려는 경향이 있습니다.</p><blockquote><p>Another possible small benefit with this scenario is better CPU cache utilization. Worker threads will tend to execute a few handlers for a given Conn object before grabbing another Conn object.</p></blockquote><p>Zoomed out, without strands</p><div class="figure " style="width:;"><img class="fig-img" src="/assets/images/what-is-strand-figure-7.png" alt=""></div><p>Zoomed out, with strands<br>(각각의 쓰레드에 따라 동일한 번호의 커넥션 객체의 작업 수행이 밀집되어 있는 것을 볼 수 있음)</p><div class="figure " style="width:;"><img class="fig-img" src="/assets/images/what-is-strand-figure-8.png" alt=""></div><br><h2 id="예제-코드"><a href="#예제-코드" class="headerlink" title="예제 코드"></a>예제 코드</h2><p>실제 예제 코드를 통해서 strand의 사용법을 알아보도록 하겠습니다. 아래 예제는 N개(1, 2, 4, 8, 16)의 쓰레드에서 각각 전역 변수인 sum에 2씩 더하는 연산을 수행하며, sum의 누적 합이 1억이 출력되는지를 확인하고자 하는 코드입니다.<br>쓰레드가 1개(N=1)인 상황에서 sum이 1억이 되기위해서는 2씩 더하는 연산이 총 50000000번 반복돼야하며 쓰레드를 16개(N=16)까지 늘린다면 해당 연산은 3125000번 반복되면 됩니다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread/detail/thread_group.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">thread_func</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">thread_func</span>(<span class="keyword">int</span> idx, boost::asio::io_context&amp; ctx) : <span class="built_in">idx_</span>(idx), <span class="built_in">ctx_</span>(ctx)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::ostringstream oss;</span><br><span class="line">        oss &lt;&lt; std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;io_context::run #%d thread [%s]\n&quot;</span>, idx_, oss.<span class="built_in">str</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        ctx_.<span class="built_in">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> idx_;</span><br><span class="line">    boost::asio::io_context&amp; ctx_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_sum_to_100_million_without_strand</span><span class="params">(<span class="keyword">int</span> thread_count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    boost::asio::io_context ctx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> loop_count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (thread_count)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        loop_count = <span class="number">50000000</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        loop_count = <span class="number">25000000</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        loop_count = <span class="number">12500000</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        loop_count = <span class="number">6250000</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">        loop_count = <span class="number">3125000</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no strand</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; thread_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        boost::asio::<span class="built_in">post</span>(ctx, [&amp;]()&#123;</span><br><span class="line">            std::ostringstream oss;</span><br><span class="line">            oss &lt;&lt; std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hello boost::asio::post in io_context [%s]\n&quot;</span>, oss.<span class="built_in">str</span>().<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loop_count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    boost::thread_group tg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; thread_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tg.<span class="built_in">create_thread</span>(<span class="built_in">thread_func</span>(i+<span class="number">1</span>, ctx));</span><br><span class="line">    &#125;</span><br><span class="line">    tg.<span class="built_in">join_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[make_sum_to_100_million_without_strand, %d thread] sum : %d\n&quot;</span>, thread_count, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thread_count = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">make_sum_to_100_million_without_strand</span>(thread_count)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실행결과</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[make_sum_to_100_million_without_strand, 2 thread] sum : 50614948</span><br></pre></td></tr></table></figure><p>(위 예시의 경우에는 2개의 쓰레드에서)핸들러 동기화를 수행하지 않는 경우에는 1억이 정상적으로 출력되지 않음을 볼 수 있습니다. 여러 쓰레드에서 동시에 접근하는 변수에 대한 명시적인 동기화 처리를 해주지 않았기 때문에 당연한 결과입니다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread/detail/thread_group.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">thread_func</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">thread_func</span>(<span class="keyword">int</span> idx, boost::asio::io_context&amp; ctx) : <span class="built_in">idx_</span>(idx), <span class="built_in">ctx_</span>(ctx)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::ostringstream oss;</span><br><span class="line">        oss &lt;&lt; std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;io_context::run #%d thread [%s]\n&quot;</span>, idx_, oss.<span class="built_in">str</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        ctx_.<span class="built_in">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> idx_;</span><br><span class="line">    boost::asio::io_context&amp; ctx_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_sum_to_100_million_with_strand</span><span class="params">(<span class="keyword">int</span> thread_count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    boost::asio::io_context ctx;</span><br><span class="line">    boost::asio::<span class="function">io_context::strand <span class="title">strand</span><span class="params">(ctx)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> loop_count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (thread_count)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        loop_count = <span class="number">50000000</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        loop_count = <span class="number">25000000</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        loop_count = <span class="number">12500000</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        loop_count = <span class="number">6250000</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">        loop_count = <span class="number">3125000</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// strand</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; thread_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        boost::asio::<span class="built_in">post</span>(strand.<span class="built_in">wrap</span>([&amp;]()&#123;</span><br><span class="line">            std::ostringstream oss;</span><br><span class="line">            oss &lt;&lt; std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hello boost::asio::post in io_context [%s]\n&quot;</span>, oss.<span class="built_in">str</span>().<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loop_count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    boost::thread_group tg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; thread_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tg.<span class="built_in">create_thread</span>(<span class="built_in">thread_func</span>(i+<span class="number">1</span>, ctx));</span><br><span class="line">    &#125;</span><br><span class="line">    tg.<span class="built_in">join_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[make_sum_to_100_million_with_strand, %d thread] sum : %d\n&quot;</span>, thread_count, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thread_count = <span class="number">16</span>;</span><br><span class="line">    <span class="built_in">make_sum_to_100_million_with_strand</span>(thread_count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실행결과</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[make_sum_to_100_million_with_strand, 16 thread] sum : 100000000</span><br></pre></td></tr></table></figure><p>(위 예시의 경우에는 16개의 쓰레드에서) boost strand를 사용하여 핸들러 동기화를 수행(전역 변수인 sum에 접근하는 핸들러가 동시에 실행되지 않음을 보장)하였기때문에 1억이 정상적으로 출력됨을 확인할 수 있습니다.</p><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><ul><li>I/O thread가 1개인 경우(즉, io_context::run() 함수가 호출되는 쓰레드가 1개인 경우)에는 오직 하나의 쓰레드에서만 핸들러가 호출되므로 동기화라는게 필요없음.</li><li>2개 이상의 I/O thread(즉, io_context::run() 함수가 호출되는 쓰레드가 2개 이상인 경우)를 사용하는 경우에는 핸들러를 동기화하기 위해 명시적인 Lock이 필요함.</li><li>이때 사용할 수 있는게 boost::asio::strand! 핸들러 내부에서 동기화를 위한 작업을 따로 해줄필요가 없다!</li></ul><br><br><span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎<p><strong>Reference</strong></p><ul><li><a href="https://www.crazygaze.com/blog/2016/03/17/how-strands-work-and-why-you-should-use-them/">https://www.crazygaze.com/blog/2016/03/17/how-strands-work-and-why-you-should-use-them/</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://chelseafandev.github.io/categories/C/">C++</category>
      
      
      <category domain="https://chelseafandev.github.io/tags/strands/">strands</category>
      
      <category domain="https://chelseafandev.github.io/tags/boost-strand/">boost strand</category>
      
      <category domain="https://chelseafandev.github.io/tags/synchronization/">synchronization</category>
      
      <category domain="https://chelseafandev.github.io/tags/handler-sync/">handler sync</category>
      
      
      <comments>https://chelseafandev.github.io/2023/09/12/what-is-strand/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>boost::io_context 실행 모델에 대해 알아보자</title>
      <link>https://chelseafandev.github.io/2023/05/19/multithreaded-execution/</link>
      <guid>https://chelseafandev.github.io/2023/05/19/multithreaded-execution/</guid>
      <pubDate>Fri, 19 May 2023 02:32:32 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;뭐하는 놈인지는 알고 쓰자&lt;/strong&gt;&lt;/em&gt; 시리즈의 네번째 주제는 &lt;code&gt;boost io_context 실행 모델&lt;/code&gt;입니다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><em><strong>뭐하는 놈인지는 알고 쓰자</strong></em> 시리즈의 네번째 주제는 <code>boost io_context 실행 모델</code>입니다.</p><span id="more"></span><p><a href="https://dens.website/tutorials/cpp-asio/multithreading">execution model where you launch N threads for the same io_context class instance.</a>와 <a href="https://dens.website/tutorials/cpp-asio/multithreading-2">execution model where you create N pairs of “1 io_context + 1 thread”</a>에 포스팅된 내용을 바탕으로 작성되었으니 참고부탁드립니다.</p><br><!-- toc --><br><h2 id="N개의-쓰레드에서-1개의-io-context를-사용하는-실행-모델"><a href="#N개의-쓰레드에서-1개의-io-context를-사용하는-실행-모델" class="headerlink" title="N개의 쓰레드에서 1개의 io_context를 사용하는 실행 모델"></a>N개의 쓰레드에서 1개의 io_context를 사용하는 실행 모델</h2><p>멀티 쓰레드 접근 방식에 뛰어들기 위한 가장 간단한 방법은 각각의 쓰레드들에서 동일한 io_context 객체에 대해서 io_context::run 멤버 함수를 실행하는 것입니다.</p><blockquote><p>The simplest way to jump into a multithreaded approach is to run io_context::run member function on multiple threads with the same io_context object.</p></blockquote><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOOST_ASIO_NO_DEPRECATED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">io::io_context io_context;</span><br><span class="line"><span class="comment">// Prepare things</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line"><span class="keyword">auto</span> count = <span class="built_in">std</span>::thread::hardware_concurrency() * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; count; ++n)</span><br><span class="line">{</span><br><span class="line">    threads.emplace_back([&amp;]</span><br><span class="line">    {</span><br><span class="line">        io_context.run();</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; thread : threads)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(thread.joinable())</span><br><span class="line">    {</span><br><span class="line">        thread.join();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><p>이 경우에 io_context는 클래식한 쓰레드 풀과 같이 동작합니다. 비동기 작업들은 OS 측면의 어딘가에서 수행되지만 완료 핸들러는 io_context::run 함수가 실행중인 쓰레드들에서 발생하게 됩니다. 좀 더 정확히 말하자면: 모든 완료 핸들러는 io_context::run 함수가 실행 중인 최초의 유휴 상태 쓰레드에서 발생합니다.</p><blockquote><p>In that case io_context operates like a classic thread pool. Asynchronous tasks are performed somewhere on the OS side, however completion handlers are invoked on those threads where io_context::run function is running. To be more precise: every completion handler is invoked on a first free thread which io_context::run function is running on.</p></blockquote><p>이것은 완료 핸들러가 병렬적으로 실행될 수 있다는 것을 의미합니다. 그리고 이것은 우리가 동기화가 필요한 지점에 도달했다는 것을 의미하기도 합니다.</p><blockquote><p>It means that completion handlers could run in parallel. And this is, in turn, mean that we’ve reached a point where we need some synchronization.</p></blockquote><p>멀티쓰레드 환경에서 여러분이 동기화에 대해 신경써야하는 부분들을 줄일 수록 더 좋을 것입니다. 좋은 소식은 Boost.Asio를 활용한 멀티쓰레드 환경에서는 동기화를 위해 뮤텍스 또는 세마포어와 같은 엣지 로우 레벨 동기화 툴들이 필요하지 않다는 것입니다.</p><blockquote><p>The less you have to care about synchronization in a multithreaded environment — the better. The good news is that we don’t need such edgy low-level synchronization tools like mutexes or semaphores to get things synchronized in the Boost.Asio multithreaded environment.</p></blockquote><p>여러분의 완료 핸들러를 적절하게 동기화하기 위해 필요한 것은 io_context::strand 클래스 인스턴스뿐입니다. 그것은 꽤 단순하게 동작합니다: 동일한 io_context::strand에 할당된 완료 핸들러는 순차적으로 실행될 것입니다. 그것들은 서로 다른 쓰레드들에서 실행되지만, 그것들의 실행은 순차적이게 될 것입니다. 이것은 그것들이 병렬적으로 처리되지 않을것이며 여러분이 동기화 처리를 해줄 필요가 없다는 것을 의미합니다.</p><blockquote><p>The only thing you need to get your completion handlers synchronized properly is io_context::strand class instance. It works pretty simple: completion handlers attached to the same io_context::strand will be invoked serially. They could be invoked from different threads, however those invocations will be serialized. This means that things won’t go in parallel and you don’t have to deal with synchronization.</p></blockquote><p>따라서 여러분이 해야 할 일은 공유 데이터에서 작동하는 완료 핸들러와 동일한 io_context::strand에 연결되어야 하는 완료 핸들러, 그리고 이들 중 어느 것이 독립적이고 병렬적으로 처리할 수 있는지를 결정하는 것입니다. 여러분은 완료 핸들러를 strand로 감싸기위해 boost::asio::bind_executor 함수를 사용해야합니다. 예제를 살펴봅시다. 우리의 io_context::run 함수가 멀티 쓰레드 환경에서 실행중이라고 가정해보겠습니다.</p><blockquote><p>So, everything you need to do is to decide which completion handlers operate on a shared data and should be attached to the same io_context::strand, and which of them are independent and can go in parallel. You should use boost::asio::bind_executor function to wrap a completion handler into a strand. Let’s look at the example. Assume that our io_context::run is running on multiple threads:</p></blockquote><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">session</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    session(io::io_context&amp; io_context)</span><br><span class="line">    : socket(io_context)</span><br><span class="line">    , read  (io_context)</span><br><span class="line">    , write (io_context)</span><br><span class="line">    {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">async_read</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        io::async_read(socket, read_buffer, io::bind_executor(read, [&amp;] (error_code error, <span class="built_in">std</span>::<span class="keyword">size_t</span> bytes_transferred)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(!error)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                async_read();</span><br><span class="line">            }</span><br><span class="line">        }));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">async_write</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        io::async_read(socket, write_buffer, io::bind_executor(write, [&amp;] (error_code error, <span class="built_in">std</span>::<span class="keyword">size_t</span> bytes_transferred)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(!error)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                async_write();</span><br><span class="line">            }</span><br><span class="line">        }));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    tcp::socket socket;</span><br><span class="line">    io::io_context::strand read;</span><br><span class="line">    io::io_context::strand write;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><p>위의 예제에서 우리는 2개의 strand를 사용했는데 하나는 read 연산을 다른 하나는 write 연산을 처리하기 위함입니다. 이것은 read 완료 핸들러와 write 완료 핸들러가 서로 다른 strand에서 직렬화 될 것이라는 것을 의미합니다. 또한 이것은 동일한 타입(여기서는 read냐 write냐)의 완료 핸들러들은 순차적으로 진행되나 read와 write 핸들러는 각각 병렬적으로 진행될 것이라는 의미이기도 합니다. 이것이 여러분이 제어 흐름을 동기적으로 유지하기 위해 해야할 전부입니다. 너무 간단하지 않은가요! 여러분이 strand를 적절하게 할당해주는 한 교착상태에 빠지거나 다른 일반적인 멀티쓰레딩 이슈가 발생할 수 없습니다.</p><blockquote><p>In the example above we used two strands, one for reading and one for writing operations. This means that read completion handlers will be serialized with one strand and write handlers will be serialized with another strand. Which means that completion handlers of the same type will go serially, however read and write handlers will go in parallel to each other. And that’s all you need to keep your control flow synchronized, so simple! Note that you can’t get deadlocked here or run into other common multithreading issues. As long as you designate your strands properly.</p></blockquote><p>여러분은 주어진 strand안에서 여러분의 functor를 실행하기 위해 boost::asio::post 함수를 사용할 수도 있습니다.</p><blockquote><p>You can also use boost::asio::post function with io_context::strand to execute your functors within a given strand:</p></blockquote><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">io::post(read, []</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"We're inside a read sequence, it's safe to access a read-related data here!\n"</span>;</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure></div></figure><br><h2 id="1개의-io-context와-1개의-쓰레드-쌍을-N개-생성하는-실행-모델"><a href="#1개의-io-context와-1개의-쓰레드-쌍을-N개-생성하는-실행-모델" class="headerlink" title="1개의 io_context와 1개의 쓰레드 쌍을 N개 생성하는 실행 모델"></a>1개의 io_context와 1개의 쓰레드 쌍을 N개 생성하는 실행 모델</h2><p>이전 강의에서 N개의 쓰레드를 하나의 io_context 클래스 객체에서 동작하도록 하는 실행 모델을 배워보았습니다. 이 경우에 io_context는 여러분을 위해 자체적으로 로드 밸런싱을 수행하며, 여러분은 다음 핸들러를 실행하기 위해 어떤 쓰레드를 사용해야하는지에 대해 신경 쓸 필요가 없습니다.</p><blockquote><p>In the previous lesson we’ve learned an execution model where you launch N threads for the same io_context class instance. In that case io_context do load balancing for you, and you don’t need to care which thread should be used for the next handler to execute on.</p></blockquote><p>1개의 io_context와 1개의 쓰레드 쌍을 N개 생성하는 또 다른 실행 모델이 있습니다. 이 경우에 모든 쓰레드는 각자의 io_context 클래스 객체를 갖게됩니다. 아래 예제를 살펴봅시다. io_context group wrapper는 요청된 io_context, work guard 그리고 쓰레드 클래스 객체의 카운트 값을 생성합니다. 우리는 아래 예제를 통해 이 실행 모델에 대해 논의할 예정입니다.</p><blockquote><p>There is another execution model where you create N pairs of “1 io_context + 1 thread” instead. In that case every thread has its own io_context class instance. Look at the example below. It’s io_context group wrapper which creates requested count of io_context, work guard and thread class instances. We will discuss this execution model below the example.</p></blockquote><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOOST_ASIO_NO_DEPRECATED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> io = boost::asio;</span><br><span class="line"><span class="keyword">using</span> tcp = io::ip::tcp;</span><br><span class="line"><span class="keyword">using</span> work_guard_type = io::executor_work_guard&lt;io::io_context::executor_type&gt;;</span><br><span class="line"><span class="keyword">using</span> error_code = boost::system::error_code;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">io_context_group</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    io_context_group(<span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Create io_context and work guard pairs</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="keyword">size_t</span> n = <span class="number">0</span>; n &lt; size; ++n)</span><br><span class="line">        {</span><br><span class="line">            contexts.emplace_back(<span class="built_in">std</span>::make_shared&lt;io::io_context&gt;());</span><br><span class="line">            guards.emplace_back(<span class="built_in">std</span>::make_shared&lt;work_guard_type&gt;(contexts.back()-&gt;get_executor()));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// Create threads</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; io_context : contexts)</span><br><span class="line">        {</span><br><span class="line">            threads.emplace_back([&amp;]</span><br><span class="line">            {</span><br><span class="line">                io_context-&gt;run();</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Join threads</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; thread : threads)</span><br><span class="line">        {</span><br><span class="line">            thread.join();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Round-robin io_context&amp; query</span></span><br><span class="line">    <span class="function">io::io_context&amp; <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> *contexts[index++ % contexts.size()];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">using</span> vector_ptr = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    vector_ptr&lt;io::io_context&gt; contexts;</span><br><span class="line">    vector_ptr&lt;work_guard_type&gt; guards;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt; index = <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">io_context_group <span class="title">group</span><span class="params">(<span class="built_in">std</span>::thread::hardware_concurrency() * <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">tcp::socket <span class="title">socket</span><span class="params">(group.query())</span></span>;</span><br><span class="line">    <span class="comment">// Schedule some tasks</span></span><br><span class="line">    group.run();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><p>여러분이 이 실행 모델에 관해 알아야하는 내용들:</p><blockquote><p>Things you should know about this execution model:</p></blockquote><p>여러분은 strands 또는 다른 어떤 동기화 도구들로 스트레스 받을 필요가 없습니다: 모든 io_context가 단일 쓰레드 내에서 실행되기때문에 동기화가 필요한 데이터가 없습니다. 물론 동일한 io_context 핸들러에서 동일한 데이터에 접근하는것에 한해서 입니다. 이러한 점은 플러스 요인으로 보입니다.</p><blockquote><p>💡 You don’t need to mess with strands or any other synchronization tools: since every io_context runs within a single thread, no data requires synchronization. As long as you access the same data from the same io_context handlers only. That looks like a plus.</p></blockquote><p>io_context에서 동작하는 socket이나 acceptor 등과 같은 객체들은 io_context 객체에 한 번만 바인딩됩니다. 여러분은 이러한 객체들의 생명주기 내에서는 또 다른 io_context에 다시 바인딩할 수 없습니다. 이 말은 곧 동일한 io_context에 바인딩된 모든 객체들은 단일 쓰레드 내에서 실행될 것이라는 것을 의미합니다. 이것이 그들이 모든 시간 동안에 동일한 CPU 코어에 바인딩된다는 의미는 아닙니다 - OS는 가장 적합한 코어라고 생각되는 곳에서 쓰레드를 실행하며 쓰레드의 생명주기 내에서 쓰레드의 코어가 변경될 수 있습니다. 하지만 쓰레드가 실행되는 코어가 어디냐에 관계없이 모든 io_context 객체들은 항상 (현재의)단일 코어 내에서 실행될 것입니다. 그래서 여러분은 하나의 코어가 100% 사용률을 보이는 반면 다른 코어들은 놀고 있는 상태인 상황을 직면할 수도 있습니다. 언뜻보기에 이것은 마이너스 요인처럼 보입니다.</p><blockquote><p>💡 Objects working on io_context, such as sockets, acceptors, etc, are bound to io_context object once. You can’t rebind any of them to another io_context within their lifetime. Which means that all objects bound to the same io_context will run within a single thread. This doesn’t mean that they’re bound to the same hardware CPU core all the time — an operating system runs a thread on the most suitable core and may change a thread’s core within a thread’s lifetime. However wherever that thread is running, all io_context objects will always run within a single (current) core. So you may face a situation when one core runs at 100% load while the others are idle. At a first glance that’s look like a minus.</p></blockquote><p>진짜 마이너스 요인은 이러한 사실 자체(하나의 코어가 100% 사용률을 보이는 반면 다른 코어들은 놀고 있는 상태)라기 보다는 선택한 밸런싱 알고리즘 또는 특정한 이용 사례에 대한 실행 모델의 부적절한 사용의 결과라고 볼 수 있습니다. 이전에 살펴본 1:N 실행 모델의 경우에는 자체적으로 여러분에게 밸런싱을 제공해주는 반면, 이 모델은 어플리케이션(또는 라이브러리) 개발자에 의해 구현되는 밸런싱 알고리즘을 요구하게 됩니다.</p><blockquote><p>💡 Well, it’s not really a minus of the execution model itself, but a minus of a balancing algorithm chosen or a result of improper usage of the execution model for a specific use-case. While the execution model from the previous lesson do balancing for you, this lesson’s model requires balancing algorithm to be implemented by the application (or a library) developer.</p></blockquote><p>이전 강의에서 살펴본 1:N 실행 모델은 범용적으로 사용되는 모델입니다. 여러분이 선택해야하는 밸런싱 알고리즘이 무엇인지 모르겠는 상황이라면 이 모델을 선택하시면 됩니다. 위에서 살펴본 1:1 실행 모델은 더 빠르게 동작할 수 있습니다. 하지만 이것은 특별한 케이스에 대해서만 알맞은 선택입니다: 여러분의 어플리케이션이 또 다른 어플리케이션과 몇가지 특별한 방식으로 상호작용하는 경우에. 그리고 이 특별한 방식은 적절한 밸런싱 알고리즘을 요구합니다. 위에서 본 예제에서는 라운드로빈 알고리즘을 사용했고, 일반적으로 그 알고리즘이 나쁘다 혹은 좋다라고 말할 수는 없습니다 - 이 알고리즘이 적절한지에 대한 판단은 다른 어플리케이션과의 상호작용 방식이 무엇이냐에 따라 달라집니다. 예를 들어, 우리의 어플리케이션이 많은 랜덤한 가벼운 작업들을 처리하는 경우라면 자동화된 밸런서보다 더 나은 해결책일 수 있습니다. 하지만 이러한 판단을 명확히 하는것은 쉽지 않습니다. 커스텀 밸런서의 다른 이용 사례나 디자인 패턴들은 이번 강의의 범위를 벗어나는 내용입니다. 이것들에 대해서는 나중에 다루어보도록 하겠습니다. 다시 한번: 여러분이 어떠한 타입의 실행 모델을 사용해야할지 확신이 서지 않는다면 이전 강의에서 살펴본 1:N 실행 모델을 선택하는것이 바람직합니다.</p><blockquote><p>💡 The execution model from the previous lesson is a universal one. Pick it if you don’t really know what balancing algorithm you should choose. The execution model from the current lesson may work faster though. However it best fit for special cases only: when your application interacts with other applications in some of special ways. And those special ways require a proper balancing algorithms. In the example above we used a round-robin algorithm, and we can’t really say if that algorithm is bad or good in general — that depends on a way of interaction of our application with other applications. For example, if our application handles a lot of random lightweight tasks then it could be a better solution than the automatic balancer. However things could be not as obvious as they’re appear to be at a first glance. Different use-cases and design patterns of a custom balancer is out of scope of this lesson. We will discuss them some later. Once again: if you’re not sure what type of execution model you should choose then pick an automatic one from the previous lesson.</p></blockquote><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>지금까지 boost::io_context의 실행 모델(execution model)에 대해 알아보았습니다. 아래와 같이 정리해보며 해당 포스팅은 여기서 마치도록 하겠습니다.<br><br></p><ul><li>boost::io_context의 실행 모델이란 하나의 어플리케이션에서 특정한 작업을 수행하는 <em><strong>thread</strong></em>와 그 쓰레드를 구동하는 공간인 <em><strong>io_context</strong></em>간의 관계를 규정해놓은 것이다.</li><li>boost::io_context의 실행 모델에는 1:N 방식과 1:1 방식이 있다. (io_context:thread)</li><li>1:N 실행 모델의 경우에는 N개의 쓰레드를 하나의 io_context에서 처리하는 구조이다.</li><li>1:1 실행 모델의 경우에는 모든 쓰레드가 각자의 io_context를 갖는 구조이다.</li><li>1:N 실행 모델은 N개의 쓰레드들에 대해서 자체적인 로드 밸런싱을 제공하지만, 1:1 실행 모델의 경우에는 그렇지 않다(적절한 밸런싱 알고리즘을 개발자가 선택해서 적용해야함).</li><li>어떠한 타입의 실행 모델을 사용해야할지 확신이 서지 않는다면 1:N 모델을 택하라.</li></ul><br><br><span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎<p><strong>Reference</strong></p><ul><li><a href="https://dens.website/tutorials/cpp-asio/multithreading">https://dens.website/tutorials/cpp-asio/multithreading</a></li><li><a href="https://dens.website/tutorials/cpp-asio/multithreading-2">https://dens.website/tutorials/cpp-asio/multithreading-2</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://chelseafandev.github.io/categories/%EA%B8%B0%EC%88%A0%EB%AC%B8%EC%84%9C-%EB%B2%88%EC%97%AD/">기술문서 번역</category>
      
      
      <category domain="https://chelseafandev.github.io/tags/boost-asio/">boost asio</category>
      
      <category domain="https://chelseafandev.github.io/tags/io-context/">io_context</category>
      
      <category domain="https://chelseafandev.github.io/tags/thread/">thread</category>
      
      <category domain="https://chelseafandev.github.io/tags/execution-model/">execution model</category>
      
      
      <comments>https://chelseafandev.github.io/2023/05/19/multithreaded-execution/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>boost::multiprecision을 활용하여 Java의 BigInteger 흉내내기</title>
      <link>https://chelseafandev.github.io/2023/05/12/impl-big-integer-in-cpp/</link>
      <guid>https://chelseafandev.github.io/2023/05/12/impl-big-integer-in-cpp/</guid>
      <pubDate>Fri, 12 May 2023 07:11:16 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;escape&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><escape><span id="more"></span></escape></p><p>아래 표에서 처럼 C/C++에서 지원하는 정수 타입의 자료형(long long 또는 unsigned long long)은 최대 8byte입니다. 그렇다면 8byte(32bit)를 초과하는 정수는 어떤 자료형을 통해 관리해야할까요?</p><table><thead><tr><th><strong>자료형</strong></th><th><strong>크기</strong></th><th><strong>범위</strong></th></tr></thead><tbody><tr><td>long long</td><td>8 byte</td><td>-9,223,372,036,854,775,807 ~ 9,223,372,036,854,775,807</td></tr><tr><td>unsigned long long</td><td>8 byte</td><td>0 ~ 18,446,744,073,709,551,615</td></tr></tbody></table><p>Java에서는 이처럼 8byte를 초과하는 큰 정수들을 처리하기 위한 BigInteger라는 클래스를 제공하고 있습니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">java</li></ul></figcaption><div class="tabs-content"><figure class="highlight java" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String left = <span class="string">"18446744073709551615"</span>;</span><br><span class="line">String right = <span class="string">"18446744073709551615"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열 타입의 첫번째 인자 값을 두번째 인자로 지정된 N진수로 변환해줌</span></span><br><span class="line">BigInteger bi_left = <span class="keyword">new</span> BigInteger(left, <span class="number">10</span>);</span><br><span class="line">BigInteger bi_right = <span class="keyword">new</span> BigInteger(right, <span class="number">10</span>);</span><br><span class="line">BigInteger output = bi_left.add(bi_right);</span><br><span class="line">System.out.println(<span class="string">"output(dec): "</span> + output.toString());</span><br><span class="line">      </span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">byte</span>[] ba = output.toByteArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">final</span> <span class="keyword">byte</span> b: ba)</span><br><span class="line">{</span><br><span class="line">  sb.append(String.format(<span class="string">"0x%02x "</span>, b&amp;<span class="number">0xff</span>));</span><br><span class="line">}</span><br><span class="line">System.out.println(<span class="string">"output(hex): "</span> + sb);</span><br></pre></td></tr></tbody></table></figure></div></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output(dec) : 36893488147419103230</span><br><span class="line">output(hex) : 0x01 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xfe</span><br></pre></td></tr></table></figure><br><p>불행히도 C/C++ 내장형 타입 중에는 8byte를 초과하는 자료형이 존재하지 않습니다. stackoverflow를 찾아보니 직접 구현을 해서 사용하거나 외부 라이브러리(<a href="https://gmplib.org/">Gmplib</a>, <a href="https://gist.github.com/bloopletech/338338">bigint</a>)를 사용하라고 하는데..<br>입맛에 맞게 사용하기 위해 boost::multiprecision을 활용하여 간략하게 구현해보았습니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cinttypes&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/multiprecision/cpp_int.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> left = <span class="string">"18446744073709551615"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> right = <span class="string">"18446744073709551615"</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 18446744073709551615는 10진수로 표현된 20자리 정수 값이며 풀어써보면 (1*10^19) + (8*10^18) + (4*10^17) + ... + (1*10^1) + (5*10^0) 입니다.</span></span><br><span class="line">  <span class="comment">// 해당 과정을 구현한 코드는 아래와 같습니다.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 사실 10진수 정수의 경우에는 문자열 타입의 값을 boost::multiprecision::cpp_int 생성자의 인자로 전달하면 쉽게 변환하여 연산이 가능합니다.</span></span><br><span class="line">  <span class="comment">//   std::string value = "18446744073709551615";</span></span><br><span class="line">  <span class="comment">//   boost::multiprecision::cpp_int bi_value(value);</span></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="comment">// 하지만 Java의 BigInteger 처럼 사용자가 직접 특정 진수를 지정하여 변환할 수는 없었기때문에 진수 변환 로직을 추가했습니다.</span></span><br><span class="line">  boost::<span class="function">multiprecision::cpp_int <span class="title">bi_left</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> len = left.length();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> tmp_str;</span><br><span class="line">    tmp_str.append(<span class="number">1</span>, left[i]);</span><br><span class="line">    bi_left += (boost::multiprecision::<span class="built_in">pow</span>(boost::multiprecision::cpp_int(<span class="number">10</span>), len - i - <span class="number">1</span>) * <span class="built_in">std</span>::strtoimax(tmp_str.c_str(), <span class="literal">nullptr</span>, <span class="number">10</span>));</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  boost::<span class="function">multiprecision::cpp_int <span class="title">bi_right</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  len = right.length();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> tmp_str;</span><br><span class="line">    tmp_str.append(<span class="number">1</span>, left[i]);</span><br><span class="line">    bi_right += (boost::multiprecision::<span class="built_in">pow</span>(boost::multiprecision::cpp_int(<span class="number">10</span>), len - i - <span class="number">1</span>) * <span class="built_in">std</span>::strtoimax(tmp_str.c_str(), <span class="literal">nullptr</span>, <span class="number">10</span>));</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  boost::multiprecision::cpp_int output = bi_left + bi_right;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"output(dec): "</span> &lt;&lt; output &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> byte_array_type = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;;</span><br><span class="line">  byte_array_type ba_output;</span><br><span class="line">  boost::multiprecision::export_bits(output, <span class="built_in">std</span>::back_inserter(ba_output), <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"output(hex): "</span>);</span><br><span class="line">  <span class="keyword">int</span> ba_output_len = ba_output.size();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ba_output_len; ++i)</span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0x%02x "</span>, ba_output[i]);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output(dec) : 36893488147419103230</span><br><span class="line">output(hex) : 0x01 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xfe</span><br></pre></td></tr></table></figure><br><p><strong>Reference</strong></p><ul><li><a href="https://learn.microsoft.com/ko-kr/cpp/cpp/data-type-ranges?view=msvc-170">https://learn.microsoft.com/ko-kr/cpp/cpp/data-type-ranges?view=msvc-170</a></li><li><a href="https://stackoverflow.com/questions/36952038/how-to-handle-big-integer-data-more-than-8-byte-or-more-than-20-digits-in-c">https://stackoverflow.com/questions/36952038/how-to-handle-big-integer-data-more-than-8-byte-or-more-than-20-digits-in-c</a></li><li><a href="https://gmplib.org/">https://gmplib.org/</a></li><li><a href="https://gist.github.com/bloopletech/338338">https://gist.github.com/bloopletech/338338</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://chelseafandev.github.io/categories/C/">C++</category>
      
      
      <category domain="https://chelseafandev.github.io/tags/boost-multiprecision/">boost::multiprecision</category>
      
      <category domain="https://chelseafandev.github.io/tags/biginteger-in-c/">biginteger in c++</category>
      
      
      <comments>https://chelseafandev.github.io/2023/05/12/impl-big-integer-in-cpp/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>클래스 템플릿의 특정 멤버 함수만 특수화하기</title>
      <link>https://chelseafandev.github.io/2023/05/02/make-specific-memberfunc-to-templatefunc/</link>
      <guid>https://chelseafandev.github.io/2023/05/02/make-specific-memberfunc-to-templatefunc/</guid>
      <pubDate>Tue, 02 May 2023 02:24:04 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;escape&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><escape><span id="more"></span></escape></p><p>아래와 같이 클래스 템플릿에서 <code>특정 멤버 함수만 특수화</code>가 가능합니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><span>mytemplateclass.h</span><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mytemplateclass</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">get_name</span><span class="params">()</span></span>; <span class="comment">// 특수화 하려는 대상</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get_grade</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> name_;</span><br><span class="line">  <span class="keyword">int</span> grade_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mytemplateclass.impl.h"</span></span></span><br></pre></td></tr></tbody></table></figure></div></figure><figure class="codeblock codeblock--tabbed"><figcaption><span>mytemplateclass.impl.h</span><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> mytemplateclass&lt;T&gt;::get_name()</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">return</span> name_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> mytemplateclass&lt;<span class="keyword">int</span>&gt;::get_name()</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"specific member function specialization"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> mytemplateclass&lt;T&gt;::get_grade()</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">return</span> grade_;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><br><p>C++17 부터는 <code>if constexpr</code>와 <code>std::is_same_v</code>를 조합하여 좀 더 깔끔하게 처리할 수 있습니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><span>mytemplateclass_v2.h</span><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mytemplateclass_v2</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">get_name</span><span class="params">()</span></span>; <span class="comment">// 특수화 하려는 대상</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get_grade</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> name_;</span><br><span class="line">  <span class="keyword">int</span> grade_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mytemplateclass_v2.impl.h"</span></span></span><br></pre></td></tr></tbody></table></figure></div></figure><figure class="codeblock codeblock--tabbed"><figcaption><span>mytemplateclass_v2.impl.h</span><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> mytemplateclass_v2&lt;T&gt;::get_name()</span><br><span class="line">{</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="built_in">std</span>::is_same_v&lt;<span class="keyword">int</span>, T&gt;)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"specific member function specialization"</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> name_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> mytemplateclass_v2&lt;T&gt;::get_grade()</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">return</span> grade_;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><br><p><strong>Reference</strong></p><ul><li><a href="https://stackoverflow.com/questions/5512910/explicit-specialization-of-template-class-member-function">https://stackoverflow.com/questions/5512910/explicit-specialization-of-template-class-member-function</a></li><li><a href="https://en.cppreference.com/w/cpp/types/is_same">https://en.cppreference.com/w/cpp/types/is_same</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://chelseafandev.github.io/categories/C/">C++</category>
      
      
      <category domain="https://chelseafandev.github.io/tags/template/">template</category>
      
      <category domain="https://chelseafandev.github.io/tags/template-function-specialization/">template function specialization</category>
      
      <category domain="https://chelseafandev.github.io/tags/if-constexpr/">if constexpr</category>
      
      <category domain="https://chelseafandev.github.io/tags/std-is-same-v/">std::is_same_v</category>
      
      
      <comments>https://chelseafandev.github.io/2023/05/02/make-specific-memberfunc-to-templatefunc/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>자주 사용하는 GDB 명령어</title>
      <link>https://chelseafandev.github.io/2023/02/10/tip-for-gdb-debugging/</link>
      <guid>https://chelseafandev.github.io/2023/02/10/tip-for-gdb-debugging/</guid>
      <pubDate>Fri, 10 Feb 2023 04:18:57 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;escape&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><escape><span id="more"></span></escape></p><!-- toc --><br><h3 id="gdb를-통해-프로그램-실행"><a href="#gdb를-통해-프로그램-실행" class="headerlink" title="gdb를 통해 프로그램 실행"></a>gdb를 통해 프로그램 실행</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb &#123;(경로포함)프로그램명&#125;</span><br></pre></td></tr></table></figure><br><h3 id="브레이크-포인트-등록"><a href="#브레이크-포인트-등록" class="headerlink" title="브레이크 포인트 등록"></a>브레이크 포인트 등록</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b 소스파일명:라인넘버</span><br></pre></td></tr></table></figure><br><h3 id="프로그램-시작"><a href="#프로그램-시작" class="headerlink" title="프로그램 시작"></a>프로그램 시작</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r &#123;인자를 추가해야한다면 입력&#125;</span><br></pre></td></tr></table></figure><br><h3 id="브레이크-포인트에-걸린-후-이어서-진행"><a href="#브레이크-포인트에-걸린-후-이어서-진행" class="headerlink" title="브레이크 포인트에 걸린 후 이어서 진행"></a>브레이크 포인트에 걸린 후 이어서 진행</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) c</span><br></pre></td></tr></table></figure><br><h3 id="자주-사용하는-명령어"><a href="#자주-사용하는-명령어" class="headerlink" title="자주 사용하는 명령어"></a>자주 사용하는 명령어</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bt(=backtrace)</span><br><span class="line">p(=print)</span><br><span class="line">set print pretty on(or off)</span><br><span class="line">f(=frame)</span><br><span class="line">up</span><br><span class="line">down</span><br></pre></td></tr></table></figure><br><h3 id="print-포맷-종류"><a href="#print-포맷-종류" class="headerlink" title="print 포맷 종류"></a>print 포맷 종류</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d decimal</span><br><span class="line">x hex</span><br><span class="line">t binary</span><br><span class="line">f floating point</span><br><span class="line">i instruction</span><br><span class="line">c character</span><br></pre></td></tr></table></figure><br><h3 id="쓰레드-정보-확인"><a href="#쓰레드-정보-확인" class="headerlink" title="쓰레드 정보 확인"></a>쓰레드 정보 확인</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info threads</span><br></pre></td></tr></table></figure><br><h3 id="info-threads-명령어를-통해-출력된-id값을-통한-쓰레드-진입"><a href="#info-threads-명령어를-통해-출력된-id값을-통한-쓰레드-진입" class="headerlink" title="(info threads 명령어를 통해 출력된 id값을 통한)쓰레드 진입"></a>(info threads 명령어를 통해 출력된 id값을 통한)쓰레드 진입</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) thread &#123;id&#125;</span><br></pre></td></tr></table></figure><br><h3 id="레지스터-정보-확인"><a href="#레지스터-정보-확인" class="headerlink" title="레지스터 정보 확인"></a>레지스터 정보 확인</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info registers</span><br></pre></td></tr></table></figure><ul><li>rax (eax) : 누산기(accumulator) 레지스터. 산술연산(덧셈, 나눗셈, 곱셈)이나 논리연산을 수행한 반환값이 저장</li><li>rbx (ebx) : 베이스 레지스터</li><li>rcx (ecx) : 카운터 레지스터. 반복 명령어 사용 시 반복 카운터로 사용되는 값을 저장</li><li>rdx (edx) : 데이터 레지스터. 산술연산과 I/O 명령에서 rax(eax)와 함께 사용</li><li>rsi (esi) : source 인덱스 레지스터</li><li>rdi (edi) : destination 인덱스 레지스터</li><li>rbp (ebp) : 베이스 포인터 레지스터. 스택의 시작 지점 주소를 저장</li><li>rsp (esp) : 스택 포인터 레지스터. 스택의 가장 마지막 지점 주소를 저장</li><li>rip : 명령 포인터 레지스터이다. 현재 명령의 위치를 가리킴</li></ul><br><h3 id="어셈블러-덤프"><a href="#어셈블러-덤프" class="headerlink" title="어셈블러 덤프"></a>어셈블러 덤프</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas</span><br></pre></td></tr></table></figure><br><h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) layout src</span><br><span class="line">(gdb) layout asm</span><br><span class="line">(gdb) layout reg</span><br></pre></td></tr></table></figure><br><h3 id="특정-변수-값의-주소-출력"><a href="#특정-변수-값의-주소-출력" class="headerlink" title="특정 변수 값의 주소 출력"></a>특정 변수 값의 주소 출력</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p &amp;&#123;변수명&#125;</span><br></pre></td></tr></table></figure><br><h3 id="특정-변수의-헥사값-출력"><a href="#특정-변수의-헥사값-출력" class="headerlink" title="특정 변수의 헥사값 출력"></a>특정 변수의 헥사값 출력</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/&#123;출력할크기&#125;bx &#123;변수의 주소값&#125;</span><br></pre></td></tr></table></figure><br><h3 id="gdb에서-긴-문자열을-줄이지-않고-그대로-출력"><a href="#gdb에서-긴-문자열을-줄이지-않고-그대로-출력" class="headerlink" title="gdb에서 긴 문자열을 줄이지 않고 그대로 출력"></a>gdb에서 긴 문자열을 줄이지 않고 그대로 출력</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set print elements 0</span><br></pre></td></tr></table></figure><br><h3 id="gdb에서-중복된-문자열을-그대로-풀어서-출력"><a href="#gdb에서-중복된-문자열을-그대로-풀어서-출력" class="headerlink" title="gdb에서 중복된 문자열을 그대로 풀어서 출력"></a>gdb에서 중복된 문자열을 그대로 풀어서 출력</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set print repeats 0</span><br></pre></td></tr></table></figure><br><h3 id="px-pn"><a href="#px-pn" class="headerlink" title="px pn"></a>px pn</h3><p>Boost::shared_ptr을 사용한다면 gdb 디버깅 시 px와 pn정보를 출력할 수 있음</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element_type* px;                   <span class="comment">// contained pointer</span></span><br><span class="line">boost::detail::shared_count pn;     <span class="comment">// reference count</span></span><br></pre></td></tr></table></figure><br><h3 id="실행-중인-프로세스의-특정-쓰레드-진입"><a href="#실행-중인-프로세스의-특정-쓰레드-진입" class="headerlink" title="실행 중인 프로세스의 특정 쓰레드 진입"></a>실행 중인 프로세스의 특정 쓰레드 진입</h3><p>프로세스가 실행 중인 상태에서 특정 쓰레드 id를 통해 gdb 진입이 가능하며, 이후 <code>CTRL + C</code>를 통해 해당 쓰레드의 흐름을 중단하여 backtrace 확인이 가능함(c 명령어를 통해 실행 재개)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb -p &#123;gdb로 확인할 쓰레드 id&#125;</span><br></pre></td></tr></table></figure><br><h3 id="sysroot-solib-search-path-substitute-path"><a href="#sysroot-solib-search-path-substitute-path" class="headerlink" title="sysroot / solib-search-path / substitute-path"></a>sysroot / solib-search-path / substitute-path</h3><p>아래 command들은 gdb 실행 시 -ex 옵션(execute a single GDB command)으로 추가해주면 유용함</p><ul><li>set sysroot {path}</li><li>set solib-search-path {path}</li><li>set substitute-path {original path} {substitute path}</li></ul><br><p><strong>Reference</strong></p><ul><li><a href="https://visualgdb.com/gdbreference/commands/">https://visualgdb.com/gdbreference/commands/</a></li><li><a href="https://visualgdb.com/gdbreference/commands/set_sysroot">https://visualgdb.com/gdbreference/commands/set_sysroot</a></li><li><a href="https://visualgdb.com/gdbreference/commands/set_solib-search-path">https://visualgdb.com/gdbreference/commands/set_solib-search-path</a></li><li><a href="https://www.irya.unam.mx/computo/sites/manuales/fce12/debugger/cl/commandref/gdb_mode/cmd_set_substitu.htm">https://www.irya.unam.mx/computo/sites/manuales/fce12/debugger/cl/commandref/gdb_mode/cmd_set_substitu.htm</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://chelseafandev.github.io/categories/%EB%94%94%EB%B2%84%EA%B9%85/">디버깅</category>
      
      
      <category domain="https://chelseafandev.github.io/tags/gdb/">gdb</category>
      
      <category domain="https://chelseafandev.github.io/tags/gdb-command/">gdb command</category>
      
      <category domain="https://chelseafandev.github.io/tags/backtrace/">backtrace</category>
      
      <category domain="https://chelseafandev.github.io/tags/bt/">bt</category>
      
      
      <comments>https://chelseafandev.github.io/2023/02/10/tip-for-gdb-debugging/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>UTF-8(Unicode Transformation Format - 8bit) 요약 정리</title>
      <link>https://chelseafandev.github.io/2023/01/30/unicode-encoding-utf8/</link>
      <guid>https://chelseafandev.github.io/2023/01/30/unicode-encoding-utf8/</guid>
      <pubDate>Mon, 30 Jan 2023 07:06:33 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;escape&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><escape><span id="more"></span></escape></p><p>유니코드는 전 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 산업 표준이며, 현존하는 문자 인코딩 방법들을 모두 유니코드로 교체하려는 것에 목적이 있습니다.</p><p>유니코드 영역 목록은 아래 링크를 참조</p><ul><li><a href="https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C_%EC%98%81%EC%97%AD">https://ko.wikipedia.org/wiki/유니코드_영역</a></li></ul><p>유니코드 인코딩 방식 중 하나가 UTF-8이며, 가변 길이 문자 인코딩 방식으로 1바이트를 기준으로 인코딩합니다. (한 글자가 1~4바이트 중 하나로 인코딩됨)</p><p><strong>인코딩 규칙</strong></p><ul><li>UTF-8 2-byte Characters<ul><li>첫 번째 byte = 0xc0 ~ 0xdf</li><li>두 번째 byte = 0x80 ~ 0xbf</li></ul></li><li>UTF-8 3-byte Characters<ul><li>첫 번째 byte = 0xe0 ~ 0xef</li><li>두 번째 byte = 0x80 ~ 0xbf</li><li>세 번째 byte = 0x80 ~ 0xbf</li></ul></li><li>UTF-8 4-byte Characters<ul><li>첫 번째 byte = 0xf0 ~ 0xf7</li><li>두 번째 byte = 0x80 ~ 0xbf</li><li>세 번째 byte = 0x80 ~ 0xbf</li><li>네 번째 byte = 0x80 ~ 0xbf</li></ul></li></ul><br><p><strong>Reference</strong></p><ul><li><a href="https://design215.com/toolbox/ascii-utf8.php">https://design215.com/toolbox/ascii-utf8.php</a></li><li><a href="https://design215.com/toolbox/utf8-3byte-characters.php">https://design215.com/toolbox/utf8-3byte-characters.php</a></li><li><a href="https://design215.com/toolbox/utf8-4byte-characters.php">https://design215.com/toolbox/utf8-4byte-characters.php</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://chelseafandev.github.io/categories/%EC%9D%B8%EC%BD%94%EB%94%A9/">인코딩</category>
      
      
      <category domain="https://chelseafandev.github.io/tags/UTF8/">UTF8</category>
      
      <category domain="https://chelseafandev.github.io/tags/Unicode/">Unicode</category>
      
      
      <comments>https://chelseafandev.github.io/2023/01/30/unicode-encoding-utf8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SELECT 쿼리 결과 동적으로 받아오는 방법</title>
      <link>https://chelseafandev.github.io/2023/01/26/how-to-get-query-result-dynamically/</link>
      <guid>https://chelseafandev.github.io/2023/01/26/how-to-get-query-result-dynamically/</guid>
      <pubDate>Thu, 26 Jan 2023 02:48:13 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;escape&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><escape><span id="more"></span></escape></p><p><code>SelectQueryResultType</code>은 쿼리 조회 결과로 나온 칼럼 이름을 key값으로 하고 해당 칼럼의 타입에 관계 없이 그 값을 저장하기 위한 빈 인터페이스 타입의 value를 갖는 map 슬라이스이고 조회된 row 개수 만큼 해당 슬라이스에 append 작업을 수행합니다.</p><p><code>pointers</code>라는 빈(empty) 인터페이스 슬라이스를 추가한 이유는 pq 라이브러리의 Scan() 함수는 조회된 칼럼 값을 저장하기 위한 <strong>변수의 주소 값</strong>을 인자로 받기 때문에 <code>values</code> 라는 빈(empty) 인터페이스 슬라이스(조회된 칼럼 값을 저장할 공간)의 요소 별 주소 값을 저장하기 위한 슬라이스를 추가적으로 생성합니다. <img src="/assets/images/how-to-get-query-result-dynamically-figure1.jpeg" class="" width="200" height="200"></p><br><figure class="highlight go"><figcaption><span>postgres.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> postgres</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;database/sql&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line">_ <span class="string">&quot;github.com/lib/pq&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SelectQueryResultType []<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">SelectQuery</span><span class="params">(query <span class="keyword">string</span>)</span> <span class="params">(SelectQueryResultType, error)</span></span> &#123;</span><br><span class="line">rows, err := db.db.Query(query)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cols, err := rows.Columns()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;db columns fail: %s\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result SelectQueryResultType</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">values := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(cols))</span><br><span class="line">pointers := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(cols))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> values &#123;</span><br><span class="line">pointers[i] = &amp;values[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err = rows.Scan(pointers...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;db scan fail: %s\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">row := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> i, val := <span class="keyword">range</span> values &#123;</span><br><span class="line">row[strings.ToLower(cols[i])] = val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = <span class="built_in">append</span>(result, row)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><strong>Reference</strong></p><ul><li><a href="https://stackoverflow.com/questions/53435455/handling-dynamic-queries-cant-scan-into-struct">https://stackoverflow.com/questions/53435455/handling-dynamic-queries-cant-scan-into-struct</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://chelseafandev.github.io/categories/Go/">Go</category>
      
      
      <category domain="https://chelseafandev.github.io/tags/lib-pq/">lib/pq</category>
      
      <category domain="https://chelseafandev.github.io/tags/Scan/">Scan()</category>
      
      <category domain="https://chelseafandev.github.io/tags/Golang-query/">Golang query</category>
      
      
      <comments>https://chelseafandev.github.io/2023/01/26/how-to-get-query-result-dynamically/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>boost::asio::post 함수의 인자로 클래스의 인스턴스를 전달할 때 주의 사항</title>
      <link>https://chelseafandev.github.io/2023/01/26/caution-when-passing-instance-to-post/</link>
      <guid>https://chelseafandev.github.io/2023/01/26/caution-when-passing-instance-to-post/</guid>
      <pubDate>Thu, 26 Jan 2023 02:43:57 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;escape&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><escape><span id="more"></span></escape></p><p>boost::asio::post 함수의 인자로 클래스의 인스턴스를 전달하는 경우에는 반드시 해당 클래스에 <code>함수 호출 연산자</code>가 <strong>오버로딩</strong> 되어있어야 합니다.</p><br><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">handler</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    handler(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : a_(a), b_(b) {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 해당 함수 주석 처리하면 compile error!!</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a_ * b_ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a_;</span><br><span class="line">    <span class="keyword">int</span> b_;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">handler <span class="title">h</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    boost::asio::post(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>]]></content:encoded>
      
      
      <category domain="https://chelseafandev.github.io/categories/C/">C++</category>
      
      
      <category domain="https://chelseafandev.github.io/tags/boost-asio-post/">boost::asio::post</category>
      
      <category domain="https://chelseafandev.github.io/tags/passing-instance-to-post-function/">passing instance to post function</category>
      
      <category domain="https://chelseafandev.github.io/tags/function-call-operator/">function call operator</category>
      
      <category domain="https://chelseafandev.github.io/tags/operator-overloading/">operator overloading</category>
      
      
      <comments>https://chelseafandev.github.io/2023/01/26/caution-when-passing-instance-to-post/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>템플릿 클래스를 정의할 때 선언부와 구현부를 서로 다른 파일로 분리하는 방법</title>
      <link>https://chelseafandev.github.io/2023/01/26/seperate-header-and-impl-in-template-class/</link>
      <guid>https://chelseafandev.github.io/2023/01/26/seperate-header-and-impl-in-template-class/</guid>
      <pubDate>Thu, 26 Jan 2023 02:41:06 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;escape&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><escape><span id="more"></span></escape></p><p>헤더 파일의 맨 하단에 템플릿 클래스를 구현한 파일을 include 시켜주면 됩니다. (<strong>#include</strong> 는 대상이 되는 파일을 단순히 붙여 넣어주는 역할을 하므로)</p><figure class="codeblock codeblock--tabbed"><figcaption><span>mytemplateclass.h</span><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYTEMPLATECLASS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYTEMPLATECLASS_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ggultip</span><br><span class="line">{</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mytemplateclass</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">mytemplateclass();</span><br><span class="line">~mytemplateclass();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">};</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mytemplateclass.impl.h"</span></span></span><br></pre></td></tr></tbody></table></figure></div></figure><figure class="codeblock codeblock--tabbed"><figcaption><span>mytemplateclass.impl.h</span><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ggultip</span><br><span class="line">{</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">mytemplateclass&lt;T&gt;::mytemplateclass()</span><br><span class="line">{</span><br><span class="line">...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">mytemplateclass&lt;T&gt;::~mytemplateclass()</span><br><span class="line">{</span><br><span class="line">...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><br><p><strong>Reference</strong></p><ul><li>Michael Main, Walter Savitch. (2010). Data Structures &amp; Other Objects Using C++, 4th Edition. Pearson</li></ul>]]></content:encoded>
      
      
      <category domain="https://chelseafandev.github.io/categories/C/">C++</category>
      
      
      <category domain="https://chelseafandev.github.io/tags/template-class/">template class</category>
      
      <category domain="https://chelseafandev.github.io/tags/%ED%85%9C%ED%94%8C%EB%A6%BF-%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B5%AC%ED%98%84%EB%B6%80-%EB%B6%84%EB%A6%AC/">템플릿 클래스 구현부 분리</category>
      
      
      <comments>https://chelseafandev.github.io/2023/01/26/seperate-header-and-impl-in-template-class/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>그룹이 아닌 계층으로서의 Go 패키지</title>
      <link>https://chelseafandev.github.io/2022/12/01/translate-packages-as-layers/</link>
      <guid>https://chelseafandev.github.io/2022/12/01/translate-packages-as-layers/</guid>
      <pubDate>Thu, 01 Dec 2022 05:43:31 GMT</pubDate>
      
      <description>&lt;p&gt;이번 포스팅은 지난번 &lt;a href=&quot;https://chelseafandev.github.io/2022/09/06/translate-standard-package-layout-in-go/&quot;&gt;어떠한 방식으로 Go코드를 구조화해야 하는가?&lt;/a&gt; 포스팅과 마찬가지로 Go 소스 코드의 구조화에 대한 고민의 연장선입니다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>이번 포스팅은 지난번 <a href="https://chelseafandev.github.io/2022/09/06/translate-standard-package-layout-in-go/">어떠한 방식으로 Go코드를 구조화해야 하는가?</a> 포스팅과 마찬가지로 Go 소스 코드의 구조화에 대한 고민의 연장선입니다.</p><span id="more"></span><p>이번에 번역해 본 글도 지난번 포스팅과 동일한 저자가 작성한 글이며 Go 소스 코드의 구조화에 관련된 글을 4년이 지난 후에 다시 한번 게시해주셨더라고요. Go 어플리케이션을 제작할 때 패키지들 간의 관계를 어떻게 바라볼 것인가에 대해 한 번 더 고민할 수 있는 시간이었습니다.</p><p>원문을 참고하실 분들은 <a href="https://www.gobeyond.dev/packages-as-layers/">해당 링크</a>를 확인해주시기 바랍니다.</p><br><!-- toc --><br><h1 id="그룹이-아닌-계층으로서의-Go-패키지"><a href="#그룹이-아닌-계층으로서의-Go-패키지" class="headerlink" title="그룹이 아닌 계층으로서의 Go 패키지"></a>그룹이 아닌 계층으로서의 Go 패키지</h1><p>숙련된 Go 개발자들에게도 가장 어려운 주제중 하나인 <code>package layout</code>에 대해 다루어보고자 4년전에 <a href="https://www.gobeyond.dev/standard-package-layout/">Standard Package Layout</a>이라는 글을 게시했었습니다. 하지만 대부분의 Go 개발자들은 여전히 그들의 어플리케이션과 함께 방대해져갈 소스 코드를 디렉토리 구조로 정리하는것에 대해 어려움을 겪고 있습니다.</p><blockquote><p>Four years ago, I wrote an article called <a href="https://www.gobeyond.dev/standard-package-layout/">Standard Package Layout</a> that tried to address one of the most difficult topics for even advanced Go developers: package layout. However, most developers still struggle with organizing their code into a directory structure that will grow gracefully with their application.</p></blockquote><p>거의 모든 프로그래밍 언어는 관련된 기능들을 함께 그룹화하는 메커니즘을 갖고 있습니다. Ruby는 gems, Java는 pacakages를 갖고 있습니다. 이러한 언어들은 코드를 그룹화 하는 일반적인 규약을 갖고 있지 않는데 솔직히 이것이 크게 중요하지 않기때문입니다. 코드를 그룹화하는 것은 전적으로 개인의 취향에 달려있습니다.</p><blockquote><p>Nearly all programming languages have a mechanism for grouping related functionality together. Ruby has gems, Java has packages. Those languages don’t have a standard convention for grouping code because, honestly, it doesn’t matter. It all comes down to personal preference.</p></blockquote><p>하지만 Go언어로 전환하는 개발자들은 매우 빈번하게 그들의 패키지 구조화가 그들을 다시 괴롭히게 된다는 것에 놀라게 됩니다. Go의 패키지는 다른 언어의 패키지의 개념과 왜 이렇게 다른걸까요? 그것은 바로 Go에서 패키지 개념은 그룹이 아닌 계층이기 때문입니다.</p><blockquote><p>However, developers that transition to Go are surprised by how often their package organization comes back to bite them. Why are Go packages so different from other languages? It’s because they’re not groups—they’re layers.</p></blockquote><br><h2 id="순환-참조-이해하기"><a href="#순환-참조-이해하기" class="headerlink" title="순환 참조 이해하기"></a>순환 참조 이해하기</h2><p>Go 언어의 패키지와 다른 언어들에서의 그룹화간의 주요한 차이는 Go 언어에서는 패키지간의 순환 의존을 허용하지 않는다는 것에 있습니다. 패키지 A가 패키지 B에 의존할 수 있지만 이와 동시에 패키지 B가 패키지 A에 의존적일 수는 없습니다.</p><blockquote><p>The primary difference between Go packages and grouping in other languages is that Go doesn’t allow for circular dependencies. Package A can depend on package B, but then package B cannot depend back on package A.</p></blockquote><div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/figure1.png" alt="Package dependencies can only go one way"><span class="caption">Package dependencies can only go one way</span></div><p>이러한 제약은 나중에 개발자들이 A와 B 패키지 모두에서 공통된 코드를 공유하게 하고자 할 때 문제를 야기하게 합니다. 이러한 문제에 대한 2가지 정도의 솔루션이 있습니다. 두 패키지를 단일 패키지로 합치거나 또 다른 세번째 패키지를 도입하는 것입니다.</p><blockquote><p>This restriction causes issues for developers later on when they need to have both packages share common code. There are typically two solutions: either combine both packages into a single package or introduce a third package.</p></blockquote><div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/figure2.png" alt=""></div><p>하지만 더 많은 패키지들로 분할해가는 것은 문제를 더 키우는 꼴입니다. 결국엔 실제 구조가 존재하지 않는 거대한 패키지들의 집합으로 귀결될 것입니다.</p><blockquote><p>However, splitting out into more and more packages only pushes the problem down the road. Eventually, you end up with a large mess of packages and no real structure.</p></blockquote><br><h2 id="스탠다드-라이브러리-차용하기"><a href="#스탠다드-라이브러리-차용하기" class="headerlink" title="스탠다드 라이브러리 차용하기"></a>스탠다드 라이브러리 차용하기</h2><p>Go 프로그래밍 시에 활용되는 가장 유용한 팁들 중에 하나는 여러분이 가이드가 필요할 때는 Go의 기본 라이브러리를 참고하라는 것입니다. 이 세상에 완벽한 코드라는 것은 없지만 Go의 기본 라이브러리는 해당 언어를 설계한 사람들이 이상적이라고 생각하는 내용들을 압축하고 있습니다.</p><blockquote><p>One of the most useful tips when programming Go is to look to the standard library when you need guidance. No code is perfect, but the Go standard library encapsulates many of the ideals of the creators of the language.</p></blockquote><p>예를 들어, net/http 패키지는 아래 그림과 같이 net 패키지의 추상을 기반으로 만들어지며 net 패키지는 io 레이어의 추상을 기반으로 만들어집니다. net 패키지가 net/http 패키지에 의존적일 수 있다고 가정하는 것은 다소 무의미하기 때문에 이러한 패키지 구조는 꽤 잘 동작합니다.</p><blockquote><p>For example, the net/http package builds on top of the abstractions of the net package, which, in turn, builds on the abstractions of the io layer below it. This package structure works well because it would be nonsensical to imagine the net package needing to somehow depend on net/http.</p></blockquote><div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/figure3.png" alt=""></div><p>Go의 기본 라이브러리에서 잘 동작하는 것과는 별개로 이것을 Go 어플리케이션 개발에 적용하는 것은 어려울 수 있습니다.</p><blockquote><p>While this works well in the standard library but can be difficult to translate to application development.</p></blockquote><br><h2 id="어플리케이션-개발에-계층-개념-적용하기"><a href="#어플리케이션-개발에-계층-개념-적용하기" class="headerlink" title="어플리케이션 개발에 계층 개념 적용하기"></a>어플리케이션 개발에 계층 개념 적용하기</h2><p><code>WTF Dial</code>이라는 어플리케이션을 예로 들어 살펴볼 예정이므로 이 어플리케이션에 대해 좀 더 살펴보고자 하시는 분들은 <a href="https://www.gobeyond.dev/wtf-dial/">해당 포스팅</a>을 읽어 보시면 됩니다.</p><blockquote><p>We’ll be looking at an example application called WTF Dial, so you can read the <a href="https://www.gobeyond.dev/wtf-dial/">introductory post</a> to understand more about it.</p></blockquote><p>이 어플리케이션은 2개의 논리적 계층을 가지고 있습니다:</p><blockquote><p>In this application, we have two logical layers:</p></blockquote><blockquote><ol><li>An SQLite database</li><li>An HTTP server</li></ol></blockquote><p>우리는 sqlite와 http 패키지를 각각 생성합니다. 많은 사람들이 Go의 기본 라이브러리 패키지와 동일한 형태의 패키지 이름을 사용하는 것을 꺼려할 것 입니다. 이러한 우려는 유효한 지적이고 여러분은 http 대신에 wtfhttp라고 네이밍할 수도 있을겁니다. 하지만 우리의 HTTP 패키지는 net/http 패키지를 완전히 캡슐화하기 때문에 동일한 파일 내에서 우리의 HTTP 패키지와 net/http 패키지를 함께 사용하는 경우는 결코 발생하지 않습니다. 저는 모든 패키지 이름에 접두어를 붙이는 작업은 지루하고 보기싫다라고 생각하기 때문에 그 짓은 하지 않겠습니다.</p><blockquote><p>We create a package for each of these — sqlite &amp; http. Many people will balk at naming a package the same name as a standard library package. That’s a valid criticism and you could name it wtfhttp instead, however, our HTTP package fully encapsulates the net/http package so we never use them both in the same file. I find that prefixing every package is tedious and ugly, so I don’t do it.</p></blockquote><br><h3 id="단순한-접근"><a href="#단순한-접근" class="headerlink" title="단순한 접근"></a>단순한 접근</h3><p>우리의 어플리케이션을 구조화하는 한가지 방법은 데이터 타입(User나 Dial과 같은)과 함수(FindUser()나 CreateDial()과 같은)를 sqlite 패키지에 포함시키는 것입니다. http 패키지는 sqlite 패키지에 직접적으로 의존할 수 있습니다:</p><blockquote><p>One way to structure our application would be to have our data types (e.g., User, Dial) and our functionality (e.g., FindUser(), CreateDial()) inside sqlite. Our http package could depend directly on it:</p></blockquote><div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/figure4.png" alt=""></div><p>이것은 그리 나쁜 접근 방식이 아니며 단순한 어플리케이션에서는 꽤 잘 동작합니다. 하지만 몇가지 문제들에 직면하게 될겁니다. 첫째로 데이터 타입은 sqlite.User와 sqlite.Dial로 네이밍되는데 데이터 타입이라는 것은 SQLite가 아니라 우리 어플리케이션에 속하는 것이므로 이러한 네이밍은 좀 이상해보입니다.</p><blockquote><p>This is not a bad approach, and it works for simple applications. We end up with a few issues though. First, our data types are named sqlite.User and sqlite.Dial. That sounds odd as our data types belong to our application—not SQLite.</p></blockquote><p>둘째로 위 구조상 HTTP 계층에서는 오로지 SQLite에 대한 데이터만을 제공할 수 있습니다. 만약 이 두 계층 사이에 캐싱 계층을 하나 추가한다고 하면 어떤일이 벌어질까요? 또 SQLite가 아닌 PostgreSQL 혹은 디스크에 존재하는 JSON 형식의 데이터와 같은 다른 형태의 타입들은 어떻게 지원할까요?</p><blockquote><p>Second, our HTTP layer can only serve data from SQLite now. What happens if we need to add a caching layer in between? Or how do we support other types of data storage such as Postgres or even storing as JSON on disk?</p></blockquote><p>마지막으로 SQLite를 추상화하는 계층이 존재하지 않기때문에 모든 HTTP 테스트에서 SQLite 데이터베이스를 구동해야만 합니다. </p><blockquote><p>Finally, we need to run an SQLite database for every HTTP test since there’s no abstraction layer to mock it out. I generally support doing end-to-end testing as much as you can, but there are valid use cases for introducing unit tests in your higher layers. This is especially true once you introduce cloud services that you wouldn’t want to run on every test invocation.</p></blockquote><br><h3 id="비즈니스-도메인-고립시키기"><a href="#비즈니스-도메인-고립시키기" class="headerlink" title="비즈니스 도메인 고립시키기"></a>비즈니스 도메인 고립시키기</h3><p>우리가 변경할 수 있는 첫번째 사항은 비즈니스 도메인을 그들 자체적인 패키지로 이동시키는 것입니다. 이러한 도메인을 “어플리케이션 도메인”이라고 칭할 수도 있습니다. 이것은 여러분의 어플리케이션에 특화된 데이터 타입입니다.</p><blockquote><p>The first thing we can change is moving our business domain to its own package. This can also be called the “application domain”. It’s the data types specific to your application—e.g., User, Dial in the case of WTF Dial.</p></blockquote><p>저는 이러한 목적으로 root 패키지(wtf)를 사용하는데, 이는 이미 제 어플리케이션 이름에 따라 편리하게 네이밍되어있고, 새로운 개발자가 코드 베이스를 열어 볼 때 가장 먼저 보는 곳이기 때문입니다. 이제 데이터 타입의 이름은 wtf.User, wtf.Dial로 위에서 나온 이름보다는 더 적절해 보입니다.</p><blockquote><p>I use the root package (wtf) for this purpose as it’s already conveniently named after my application, and it’s the first place new developers look when they open the code base. Our types are now named more appropriately as wtf.User and wtf.Dial.</p></blockquote><div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/figure5.png" alt=""></div><p>여러분은 아래 예시에서 wtf.Dial 타입을 볼 수 있습니다:</p><blockquote><p>You can see an example of this with the wtf.Dial type:</p></blockquote><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Dial <span class="keyword">struct</span> {</span><br><span class="line">ID <span class="keyword">int</span> <span class="string">`json:"id"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Owner of the dial. Only the owner may delete the dial.</span></span><br><span class="line">UserID <span class="keyword">int</span>   <span class="string">`json:"userID"`</span></span><br><span class="line">User   *User <span class="string">`json:"user"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Human-readable name of the dial.</span></span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Code used to share the dial with other users.</span></span><br><span class="line"><span class="comment">// It allows the creation of a shareable link without</span></span><br><span class="line"><span class="comment">// explicitly inviting users.</span></span><br><span class="line">InviteCode <span class="keyword">string</span> <span class="string">`json:"inviteCode,omitempty"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Aggregate WTF level for the dial.</span></span><br><span class="line">Value <span class="keyword">int</span> <span class="string">`json:"value"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Timestamps for dial creation &amp; last update.</span></span><br><span class="line">CreatedAt time.Time <span class="string">`json:"createdAt"`</span></span><br><span class="line">UpdatedAt time.Time <span class="string">`json:"updatedAt"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// List of associated members and their contributing WTF level.</span></span><br><span class="line"><span class="comment">// This is only set when returning a single dial.</span></span><br><span class="line">Memberships []*DialMembership <span class="string">`json:"memberships,omitempty"`</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><p>위 코드에서는 세부 구현에 대한 어떠한 참조도 존재하지 않습니다. 단지 Go의 내장 타입들과 time.Time만 존재합니다. JOSN 태그는 편의를 위해 추가했습니다.</p><blockquote><p>In this code, there is no reference to any implementation details—just primitive types &amp; time.Time. JSON tags are added for convenience.</p></blockquote><br><h3 id="추상화-서비스를-통한-의존성-제거"><a href="#추상화-서비스를-통한-의존성-제거" class="headerlink" title="추상화 서비스를 통한 의존성 제거"></a>추상화 서비스를 통한 의존성 제거</h3><p>어플리케이션의 구조가 조금은 더 나아진것 같아 보이지만 HTTP가 SQLite에 의존적이라는 것은 여전히 어색합니다. 우리의 HTTP 서버는 데이터 저장 공간이 SQLite인지 아닌지는 신경쓰지 않고 데이터를 전달하기를 원합니다.</p><blockquote><p>Our application structure is looking better, but it’s still odd that HTTP depends on SQLite. Our HTTP server wants to fetch data from an underlying data storage—it doesn’t specifically care if it’s SQLite or not.</p></blockquote><p>이 부분을 수정하기 위해, 비즈니스 도메인 내에 서비스들을 제공하기 위한 인터페이스를 생성할겁니다. 이 서비스들은 전형적인 CRUD 이지만 또 다른 동작을 수행하도록 확장할 수도 있습니다.</p><blockquote><p>To fix this, we’ll create interfaces for the services in our business domain. These services are typically Create/Read/Update/Delete (CRUD) but can extend to other operations.</p></blockquote><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DialService represents a service for managing dials.</span></span><br><span class="line"><span class="keyword">type</span> DialService <span class="keyword">interface</span> {</span><br><span class="line"><span class="comment">// Retrieves a single dial by ID along with associated memberships. Only</span></span><br><span class="line"><span class="comment">// the dial owner &amp; members can see a dial. Returns ENOTFOUND if dial does</span></span><br><span class="line"><span class="comment">// not exist or user does not have permission to view it.</span></span><br><span class="line">FindDialByID(ctx context.Context, id <span class="keyword">int</span>) (*Dial, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Retrieves a list of dials based on a filter. Only returns dials that</span></span><br><span class="line"><span class="comment">// the user owns or is a member of. Also returns a count of total matching</span></span><br><span class="line"><span class="comment">// dials which may different from the number of returned dials if the</span></span><br><span class="line"><span class="comment">// "Limit" field is set.</span></span><br><span class="line">FindDials(ctx context.Context, filter DialFilter) ([]*Dial, <span class="keyword">int</span>, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates a new dial and assigns the current user as the owner.</span></span><br><span class="line"><span class="comment">// The owner will automatically be added as a member of the new dial.</span></span><br><span class="line">CreateDial(ctx context.Context, dial *Dial) error</span><br><span class="line"></span><br><span class="line"><span class="comment">// Updates an existing dial by ID. Only the dial owner can update a dial.</span></span><br><span class="line"><span class="comment">// Returns the new dial state even if there was an error during update.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns ENOTFOUND if dial does not exist. Returns EUNAUTHORIZED if user</span></span><br><span class="line"><span class="comment">// is not the dial owner.</span></span><br><span class="line">UpdateDial(ctx context.Context, id <span class="keyword">int</span>, upd DialUpdate) (*Dial, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Permanently removes a dial by ID. Only the dial owner may delete a dial.</span></span><br><span class="line"><span class="comment">// Returns ENOTFOUND if dial does not exist. Returns EUNAUTHORIZED if user</span></span><br><span class="line"><span class="comment">// is not the dial owner.</span></span><br><span class="line">DeleteDial(ctx context.Context, id <span class="keyword">int</span>) error</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><p>이제 우리의 도메인 패키지(wtf)는 데이터 구조뿐만 아니라 계층 간의 커뮤니케이션 방식을 정의한 인터페이스도 구체화되었습니다. 이것은 우리의 패키지 계층 구조를 수평적으로 만들어주었으며 이를 통해 이제 모든 패키지들은 도메인 패키지에 의존하게됩니다. 이것은 패키지간의 직접적인 의존 관계를 깰 수 있도록 해주며 mock 패키지와 같은 부가적인 구현들도 추가할 수 있게 해줍니다.</p><blockquote><p>Now our domain package (wtf) specifies not just the data structures but also the interface contracts for how our layers can communicate with one another. This flattens our package hierarchy so that all packages now depend on the domain package. This lets us break direct dependencies between packages and introduce alternate implementations such as a mock package.</p></blockquote><div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/figure6.png" alt=""></div><br><h3 id="패키지의-재패키지화"><a href="#패키지의-재패키지화" class="headerlink" title="패키지의 재패키지화"></a>패키지의 재패키지화</h3><p>패키지간의 의존성을 깨는것은 우리가 작성한 코드를 유연하게 사용할 수 있도록 해줍니다. 우리의 어플리케이션 바이너리인 wtfd에 대해선 여전히 http 패키지가 sqlite에 의존적이지만 테스트를 위해 http 패키지가 새로운 mock 패키지에 의존하도록 변경할 수 있습니다.</p><blockquote><p>Breaking the dependency between packages allows us flexibility in how we use our code. For our application binary, wtfd, we still want http to depend on sqlite (see wtf/main.go) but for our tests we can change http to depend on our new mock package (see http/server_test.go):</p></blockquote><div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/figure7.png" alt=""></div><p>이것은 WTF Dial과 같은 작은 웹 어플리케이션에서는 조금 지나친 작업일 수 있으나 우리가 소스 코드를 늘려 나감에 있어서는 점차 중요한 문제가 될 겁니다.</p><blockquote><p>This may be overkill for our small web application, WTF Dial, but it becomes increasingly important as we grow our codebase.</p></blockquote><br><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>패키지는 Go 언어에서 매우 강력한 도구입니다. 하지만 여러분이 패키지를 계층이 아닌 그룹으로 바라본다면 끝없는 혼란의 원천이기도 합니다. 여러분이 만든 어플리케이션의 논리적인 계층을 이해한 후에 데이터 타입과 비즈니스 도메인을 위한 인터페이스를 추출해낼 수 있으며 이것들을 나머지 모든 서브 패키지들이 참조할 수 있도록 하는 범용적인 도메인 언어를 제공하기 위한 루트 패키지로 옮길 수 있습니다. 도메인 언어를 정의하는 것은 시간이 지남에 따라 여러분의 어플리케이션 규모를 키워나가는데 필수적입니다.</p><blockquote><p>Packages are a powerful tool in Go but are the source of endless frustration if you view them as groups instead of layers. After understanding the logical layers of your application, you can extract data types &amp; interface contracts for your business domain and move them into your root package to serve as a common domain language for all subpackages. Defining this domain language is essential to growing your application over time.</p></blockquote><br><br><span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎<p><strong>reference</strong></p><ul><li><a href="https://www.gobeyond.dev/packages-as-layers/">https://www.gobeyond.dev/packages-as-layers/</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://chelseafandev.github.io/categories/Go/">Go</category>
      
      
      <category domain="https://chelseafandev.github.io/tags/go/">go</category>
      
      <category domain="https://chelseafandev.github.io/tags/golang/">golang</category>
      
      <category domain="https://chelseafandev.github.io/tags/package-layer/">package layer</category>
      
      <category domain="https://chelseafandev.github.io/tags/go-layout/">go layout</category>
      
      <category domain="https://chelseafandev.github.io/tags/organize-go-code/">organize go code</category>
      
      
      <comments>https://chelseafandev.github.io/2022/12/01/translate-packages-as-layers/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>어떠한 방식으로 Go 코드를 구조화해야 하는가?</title>
      <link>https://chelseafandev.github.io/2022/09/06/translate-standard-package-layout-in-go/</link>
      <guid>https://chelseafandev.github.io/2022/09/06/translate-standard-package-layout-in-go/</guid>
      <pubDate>Tue, 06 Sep 2022 09:30:58 GMT</pubDate>
      
      <description>&lt;p&gt;최근 회사에서 Go 언어를 활용하여 신규 프로젝트를 진행할 기회가 생겼는데 추후 코드의 유지 관리를 고려해볼 때 Go 언어의 소스 코드 구조를 어떤 식으로 해야 하는가에 대해 고민이 생겼습니다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>최근 회사에서 Go 언어를 활용하여 신규 프로젝트를 진행할 기회가 생겼는데 추후 코드의 유지 관리를 고려해볼 때 Go 언어의 소스 코드 구조를 어떤 식으로 해야 하는가에 대해 고민이 생겼습니다.</p><span id="more"></span><p>구글링 중에 Go 언어의 코드 구조화에 관한 좋은 글을 발견하여 실제 프로젝트에도 반영해볼 겸 해서 번역해보았습니다. 역시나 저와 같은 고민을 앞서 해주신 선구자님들이 계시더라고요😁.</p><p>원문의 일부 내용은 번역에서 제외했으니 원문을 참고하실 분들은 <a href="https://www.gobeyond.dev/standard-package-layout/">해당 링크</a>를 확인해주시기 바랍니다.</p><br><!-- toc --><br><h1 id="표준-패키지-레이아웃"><a href="#표준-패키지-레이아웃" class="headerlink" title="표준 패키지 레이아웃"></a>표준 패키지 레이아웃</h1><p>Vendoring. Generics. 이것들은 Go 커뮤니티 내에서 큰 이슈들로 보입니다. 하지만 좀 처럼 언급되지 않는 또 다른 이슈가 하나 있습니다 - 바로 어플리케이션 패키지 레이아웃 입니다.</p><blockquote><p>Vendoring. Generics. These are seen as big issues in the Go community but there’s another issue that’s rarely mentioned — application package layout.</p></blockquote><p>제가 지금까지 작업해왔던 모든 Go 어플리케이션은 “내 코드를 어떤 방식으로 구조화해야하는가?”라는 질문에 대한 각기 다른 대답을 가지고 있는것 처럼 보입니다. 몇몇 어플리케이션은 하나의 패키지에 모든 것을 밀어 넣기도하고 또 다른 어플리케이션은 타입이나 모듈 단위로 그룹화하기도 합니다. 여러분의 팀 전반에 걸쳐 적용할 만한 좋은 전략이 없다면, 여러분의 어플리케이션의 다양한 패키지들에 곳곳에 코드가 흩뿌려지게 되는 것을 보게 될 것입니다. 우리는 Go 어플리케이션 디자인에 적용할 수 있는 더나은 표준이 필요합니다.</p><blockquote><p>Every Go application I’ve ever worked on appears to have a different answer to the question, how should I organize my code? Some applications push everything into one package while others group by type or module. Without a good strategy applied across your team, you’ll find code scattered across various packages of your application. We need a better standard for Go application design.</p></blockquote><p>저는 더 나은 접근 방식을 제안하고자 합니다. 몇가지 단순한 규칙들을 따름으로써 우리는 코드를 분리시키고 테스트를 용이하게 만들며 프로젝트에 일관된 구조를 가지고 올 수 있게됩니다.</p><blockquote><p>I suggest a better approach. By following a few simple rules we can decouple our code, make it easier to test, and bring a consistent structure to our project.</p></blockquote><br><h2 id="1-기본-패키지는-도메인-타입을-위한-패키지다"><a href="#1-기본-패키지는-도메인-타입을-위한-패키지다" class="headerlink" title="#1. 기본 패키지는 도메인 타입을 위한 패키지다"></a>#1. 기본 패키지는 도메인 타입을 위한 패키지다</h2><p>여러분의 어플리케이션은 데이터와 프로세스들이 어떠한 방식으로 상호작용하는지를 기술하는 논리적이고 고수준(사람이 이해하기 쉽게 작성된 프로그래밍 언어를 의미함)인 언어를 가지고 있습니다. 만약 여러분이 e커머스 어플리케이션을 개발 중이라면 여러분의 도메인은 고객, 계정, 신용카드 결제, 재고 관리와 같은 것들을 포함하고 있을것입니다. 만약 여러분이 페이스북을 개발하고 있다면 여러분의 도메인은 사용자, 좋아요, &amp; relationships(?)이 될것 입니다. 이러한 도메인은 여러분의 근본적인 기술과는 독립적인 개념입니다.</p><blockquote><p>Your application has a logical, high-level language that describes how data and processes interact. This is your domain. If you have an e-commerce application your domain involves things like customers, accounts, charging credit cards, and handling inventory. If you’re Facebook then your domain is users, likes, &amp; relationships. It’s the stuff that doesn’t depend on your underlying technology.</p></blockquote><p>저는 도메인 타입을 프로젝트의 기본(root) 패키지에 위치시킵니다. 기본 패키지는 사용자 정보를 저장하는 User 구조체나 사용자 정보를 가지고 오거나 저장하기 위해서 사용하는 UserService 인터페이스와 같은 단순한 데이터 타입들만을 포함하고 있습니다.</p><blockquote><p>I place my domain types in my root package. This package only contains simple data types like a User struct for holding user data or a UserService interface for fetching or saving user data.</p></blockquote><p>기본 패키지는 아래와 같은 구조를 보일 수 있을겁니다:</p><blockquote><p>It may look something like:</p></blockquote><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> myapp</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">ID      <span class="keyword">int</span></span><br><span class="line">Name    <span class="keyword">string</span></span><br><span class="line">Address Address</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserService <span class="keyword">interface</span> {</span><br><span class="line">User(id <span class="keyword">int</span>) (*User, error)</span><br><span class="line">Users() ([]*User, error)</span><br><span class="line">CreateUser(u *User) error</span><br><span class="line">DeleteUser(id <span class="keyword">int</span>) error</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><p>이것은 여러분의 기본 패키지를 매우 단순하게 만들어 줍니다. 또한 여러분은 다른 도메인 타입에 의존하는 경우에만 동작을 수행하도록 하는 타입들을 포함할 수도 있습니다. 예를 들어, 여러분이 UserService를 주기적으로 폴링(polling)하는 특정 타입을 포함시켜야할 수 있습니다. 그러나 외부 서비스를 호출하거나 데이터베이스에 저장해서는 안됩니다. 그것은 세부적인 구현 사항입니다.</p><blockquote><p>This makes your root package extremely simple. You may also include types that perform actions but only if they solely depend on other domain types. For example, you could have a type that polls your UserService periodically. However, it should not call out to external services or save to a database. That is an implementation detail.</p></blockquote><p><em>기본 패키지는 여러분의 어플리케이션에 존재하는 어떠한 다른 패키지에도 의존적이어선 안됩니다!</em></p><blockquote><p><em>The root package should not depend on any other package in your application!</em></p></blockquote><br><h2 id="2-의존성에-따라-하위패키지를-그룹화하라"><a href="#2-의존성에-따라-하위패키지를-그룹화하라" class="headerlink" title="#2. 의존성에 따라 하위패키지를 그룹화하라"></a>#2. 의존성에 따라 하위패키지를 그룹화하라</h2><p>만약 기본 패키지가 외부 의존성을 허용하지 않는다면 이러한 의존성들을 하위패키지에 추가해주어야 합니다. 이러한 접근 방식에서는 하위패키지가 도메인과 구현(implementation)사이의 어댑터로서 존재하게 됩니다.</p><blockquote><p>If your root package is not allowed to have external dependencies then we must push those dependencies to subpackages. In this approach to package layout, subpackages exist as an adapter between your domain and your implementation.</p></blockquote><p>예를 들어, 여러분의 UserService가 PostgreSQL을 지원해야할 수 있습니다. 이때 여러분은 postgres.UserService에 대한 세부 구현을 제공하는 postgres 하위패키지를 추가할 수 있습니다:</p><blockquote><p>For example, your UserService might be backed by PostgreSQL. You can introduce a postgres subpackage in your application that provides a postgres.UserService implementation:</p></blockquote><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> postgres</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"database/sql"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/benbjohnson/myapp"</span></span><br><span class="line">_ <span class="string">"github.com/lib/pq"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserService represents a PostgreSQL implementation of myapp.UserService.</span></span><br><span class="line"><span class="keyword">type</span> UserService <span class="keyword">struct</span> {</span><br><span class="line">DB *sql.DB</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// User returns a user for a given id.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *UserService)</span> <span class="title">User</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="params">(*myapp.User, error)</span></span> {</span><br><span class="line"><span class="keyword">var</span> u myapp.User</span><br><span class="line">row := db.QueryRow(<span class="string">`SELECT id, name FROM users WHERE id = $1`</span>, id)</span><br><span class="line"><span class="keyword">if</span> row.Scan(&amp;u.ID, &amp;u.Name); err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> &amp;u, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// implement remaining myapp.UserService interface...</span></span><br></pre></td></tr></tbody></table></figure></div></figure><p>이것은 PostgreSQL 의존성을 분리하게되는데 이러한 의존성의 분리는 테스트 과정을 단순화시켜주고 추후 또 다른 데이터베이스로 마이그레이션하기 위한 쉬운 방식을 제공합니다. 여러분이 BoltDB와 같은 또 다른 데이터베이스에 대한 세부 구현을 지원하기로 결정했다면 이것은 플러그형 구조로 사용될 수 있습니다.</p><blockquote><p>This isolates our PostgreSQL dependency which simplifies testing and provides an easy way to migrate to another database in the future. It can be used as a pluggable architecture if you decide to support other database implementations such as BoltDB.</p></blockquote><p>이것은 또한 구현을 계층화하는 방법을 제공합니다. 아마도 여러분은 PostgreSQL 앞에 LRU 캐시를 두어 데이터를 메모상에 보관하기를 원할 것입니다. 이를 위해 PostgreSQL 세부 구현을 래핑(wrapping)할 수 있는 UserService를 구현하는 UserCache를 추가할 수 있습니다.</p><blockquote><p>It also gives you a way to layer implementations. Perhaps you want to hold an in-memory, LRU cache in front of PostgreSQL. You can add a UserCache that implements UserService which can wrap your PostgreSQL implementation:</p></blockquote><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> myapp</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserCache wraps a UserService to provide an in-memory cache.</span></span><br><span class="line"><span class="keyword">type</span> UserCache <span class="keyword">struct</span> {</span><br><span class="line">cache   <span class="keyword">map</span>[<span class="keyword">int</span>]*User</span><br><span class="line">service UserService</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewUserCache returns a new read-through cache for service.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUserCache</span><span class="params">(service UserService)</span> *<span class="title">UserCache</span></span> {</span><br><span class="line"><span class="keyword">return</span> &amp;UserCache{</span><br><span class="line">cache: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*User),</span><br><span class="line">service: service,</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// User returns a user for a given id.</span></span><br><span class="line"><span class="comment">// Returns the cached instance if available.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *UserCache)</span> <span class="title">User</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="params">(*User, error)</span></span> {</span><br><span class="line"><span class="comment">// Check the local cache first.</span></span><br><span class="line"><span class="keyword">if</span> u := c.cache[id]; u != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> u, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Otherwise fetch from the underlying service.</span></span><br><span class="line">u, err := c.service.User(id)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> u != <span class="literal">nil</span> {</span><br><span class="line">c.cache[id] = u</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> u, err</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><p>Golang의 기본 라이브러리들에서도 이러한 접근 방식을 살펴볼 수 있습니다. io.Reader는 바이트를 읽어들이기 위한 도메인 타입이고 그것의 세부 구현들은 의존성에 의해 그룹화되어 있습니다 - tar.Reader, gzip.Reader, multipart.Reader. 이것들 또한 계층화될 수 있습니다. os.File은 bufio.Reader에 의해 래핑되어있고 이 bufio.Reader는 gzip.Reader에 의해 래핑되어있으며 gzip.Reader는 tar.Reader에 의해 래핑되어있는 이러한 모습들은 흔히 보이는 계층 구조들입니다.</p><blockquote><p>We see this approach in the standard library too. The io.Reader is a domain type for reading bytes and its implementations are grouped by dependency — tar.Reader, gzip.Reader, multipart.Reader. These can be layered as well. It’s common to see an os.File wrapped by a bufio.Reader which is wrapped by a gzip.Reader which is wrapped by a tar.Reader.</p></blockquote><br><h3 id="의존성-간의-의존성"><a href="#의존성-간의-의존성" class="headerlink" title="의존성 간의 의존성"></a>의존성 간의 의존성</h3><p>여러분의 의존성은 홀로 고립된 채로 살아갈 수 없습니다. User 데이터는 PostgreSQL에 저장을 하고 재무와 관련된 트랜잭션 데이터는 Stripe와 같은 3rd party 서비스에 저장해야하는 경우가 생길 수 있습니다. 이러한 경우에는 Stripe가 논리적인 도메인 타입과 함께 묶이게 됩니다 - 이것을 TranscationService라고 부르기로 하겠습니다.</p><blockquote><p>Your dependencies don’t live in isolation. You may store User data in PostgreSQL but your financial transaction data exists in a third party service like Stripe. In this case we wrap our Stripe dependency with a logical domain type — let’s call it TransactionService.</p></blockquote><p>UserService에 TransactionService를 추가함으로써 우리는 이 두가지 의존성을 분리할 수 있습니다.</p><blockquote><p>By adding our TransactionService to our UserService we decouple our two dependencies:</p></blockquote><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UserService <span class="keyword">struct</span> {</span><br><span class="line">DB                 *sql.DB</span><br><span class="line">TransactionService myapp.TransactionService</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><p>이제 우리의 의존성들은 오직 공통된 도메인 언어를 통해서만 소통하게 됩니다. 이것은 우리가 다른 의존성들에 영향을 주지 않고 PostgreSQL을 MySQL로 Stripe를 또 다른 지불 프로세서로 변경할 수 있음을 의미합니다.</p><blockquote><p>Now our dependencies communicate solely through our common domain language. This means that we could swap out PostgreSQL for MySQL or switch Stripe for another payment processor without affecting other dependencies.</p></blockquote><br><h3 id="이러한-접근-방식을-3rd-party-의존성에만-국한-시키지마라"><a href="#이러한-접근-방식을-3rd-party-의존성에만-국한-시키지마라" class="headerlink" title="이러한 접근 방식을 3rd party 의존성에만 국한 시키지마라"></a>이러한 접근 방식을 3rd party 의존성에만 국한 시키지마라</h3><p>3rd party 의존성에만 국한 시키지말라는 말이 이상하게 들릴 수 있지만 이와 동일한 방식으로 Golang에서 제공하는 기본 라이브러리를 고립시킬 수 있습니다. 예를 들어, net/http 패키지는 단지 또 다른 의존성입니다. 우리가 만든 어플리케이션에 존재하는 http 라는 하위패키지에 이 net/http 패키지를  추가함으로써 고립된 환경을 구성할 수 있습니다.</p><blockquote><p>This may sound odd but I also isolate my standard library dependencies with this same method. For instance, the net/http package is just another dependency. We can isolate it as well by including an http subpackage in our application.</p></blockquote><p>해당 패키지의 이름이 그것이 감싸고 있는 의존성과 동일한 이름을 갖는다는 것이 이상할 수 있지만 이것은 의도된 것입니다. 여러분이 만든 어플리케이션의 다른 어떠한 모듈들에서도 net/http 패키지를 사용하는 곳이 없다면 패키지 이름 충돌이 발생할 일은 없습니다. 이름을 중복시킴으로 얻을 수 있는 이점은 이를 통해 여러분이 HTTP와 관련된 모든 코드들은 새롭게 만든 http 패키지에 포함되도록 한다는 것입니다.</p><blockquote><p>It might seem odd to have a package with the same name as the dependency it wraps, however, this is intentional. There are no package name conflicts in your application unless you allow net/http to be used in other parts of your application. The benefit to duplicating the name is that it requires you to isolate all HTTP code to your http package.</p></blockquote><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> http</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/benbjohnson/myapp"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> {</span><br><span class="line">UserService myapp.UserService</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line"><span class="comment">// handle request</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><p>이제 우리가 만든 http.Handler는 도메인과 HTTP 프로토콜 간 어댑터로서의 역할을 수행하게 됩니다.</p><blockquote><p>Now your http.Handler acts as an adapter between your domain and the HTTP protocol.</p></blockquote><br><h2 id="3-공유된-mock-하위패키지를-사용하라"><a href="#3-공유된-mock-하위패키지를-사용하라" class="headerlink" title="#3. 공유된 mock 하위패키지를 사용하라"></a>#3. 공유된 mock 하위패키지를 사용하라</h2><p>우리의 의존성들은 도메인 인터페이스를 통해 다른 의존성들과 분리되어 있기떄문에 우리는 mock 구현을 주입하기 위해 이러한 연결 지점들을 사용할 수 있습니다.</p><blockquote><p>Because our dependencies are isolated from other dependencies by our domain interfaces, we can use these connection points to inject mock implementations.</p></blockquote><p>여러분에게 mock를 생성해주는 GoMock과 같은 mocking 라이브러리들이 몇가지 있지만 저는 개인적으로 그것들을 직접 작성하는것을 선호합니다. 대부분의 mocking 도구들은 너무 복잡하게 되어있습니다.</p><blockquote><p>There are several mocking libraries such as GoMock that will generate mocks for you but I personally prefer to just write them myself. I find many of the mocking tools to be overly complicated.</p></blockquote><p>제가 사용하는 mocks는 매우 간단합니다. 예를 들어, UserService를 위한 mock은 아래와 같습니다:</p><blockquote><p>The mocks I use are very simple. For example, a mock for the UserService looks like:</p></blockquote><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mock</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/benbjohnson/myapp"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// UserService represents a mock implementation of myapp.UserService.</span></span><br><span class="line"><span class="keyword">type</span> UserService <span class="keyword">struct</span> {</span><br><span class="line">UserFn      <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="params">(*myapp.User, error)</span></span></span><br><span class="line">UserInvoked <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">UsersFn     <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">([]*myapp.User, error)</span></span></span><br><span class="line">UsersInvoked <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// additional function implementations...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// User invokes the mock implementation and marks the function as invoked.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *UserService)</span> <span class="title">User</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="params">(*myapp.User, error)</span></span> {</span><br><span class="line">s.UserInvoked = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> s.UserFn(id)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// additional functions: Users(), CreateUser(), DeleteUser()</span></span><br></pre></td></tr></tbody></table></figure></div></figure><p>이 mock은 인자들의 유효성을 검사하거나 기대된 데이터가 반환되는지를 확인하거나 실패하는 케이스를 주입해보기 위해 myapp.UserService 인터페이스를 사용하기만 한다면 어느 곳이든 함수들을 주입해볼 수 있습니다.</p><blockquote><p>This mock lets me inject functions into anything that uses the myapp.UserService interface to validate arguments, return expected data, or inject failures.</p></blockquote><p>예를 들어 위에서 만들어 본 http.Handler를 테스트하기 원한다고 해봅시다:</p><blockquote><p>Let’s say we want to test our http.Handler that we built above:</p></blockquote><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> http_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/http/httptest"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/benbjohnson/myapp/mock"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHandler</span><span class="params">(t *testing.T)</span></span> {</span><br><span class="line"><span class="comment">// Inject our mock into our handler.</span></span><br><span class="line"><span class="keyword">var</span> us mock.UserService</span><br><span class="line"><span class="keyword">var</span> h Handler</span><br><span class="line">h.UserService = &amp;us</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mock our User() call.</span></span><br><span class="line">us.UserFn = <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="params">(*myapp.User, error)</span></span> {</span><br><span class="line"><span class="keyword">if</span> id != <span class="number">100</span> {</span><br><span class="line">t.Fatalf(<span class="string">"unexpected id: %d"</span>, id)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> &amp;myapp.User{ID: <span class="number">100</span>, Name: <span class="string">"susy"</span>}, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke the handler.</span></span><br><span class="line">w := httptest.NewRecorder()</span><br><span class="line">r, _ := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"/users/100"</span>, <span class="literal">nil</span>)</span><br><span class="line">h.ServeHTTP(w, r)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validate mock.</span></span><br><span class="line"><span class="keyword">if</span> !us.UserInvoked {</span><br><span class="line">t.Fatal(<span class="string">"expected User() to be invoked"</span>)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><p>mock는 유닛 테스트와 HTTP 프로토콜의 처리부분이 완전히 분리될 수 있도록 해줍니다.</p><blockquote><p>Our mock lets us completely isolate our unit test to only the handling of the HTTP protocol.</p></blockquote><br><h2 id="4-메인-패키지는-의존성들을-하나로-엮는다"><a href="#4-메인-패키지는-의존성들을-하나로-엮는다" class="headerlink" title="#4. 메인 패키지는 의존성들을 하나로 엮는다"></a>#4. 메인 패키지는 의존성들을 하나로 엮는다</h2><p>이러한 모든 의존성 패키지들이 고립된 채로 떠다니게 된다면 이들을 어떻게 하나로 결합할 수 있을지 궁금할 수 있습니다. 이 역할을 하는 것이 메인 패키지 입니다.</p><blockquote><p>With all these dependency packages floating around in isolation, you may wonder how they all come together. That’s the job of the main package.</p></blockquote><br><h3 id="메인-패키지-레이아웃"><a href="#메인-패키지-레이아웃" class="headerlink" title="메인 패키지 레이아웃"></a>메인 패키지 레이아웃</h3><p>어플리케이션은 2개 이상의 바이너리 파일을 생성할 수도 있는데 이를 위해 메인 패키지를 cmd 패키지의 하위 디렉토리로 두는 Go 언어의 관습(convention)을 사용할 것입니다. 예를 들어, 우리 프로젝트가 myapp 이라는 서버 바이너리뿐만 아니라 터미널을 통해 서버를 관리할 수 있도록 하는 myappctl 이라는 클라이언트 바이너리도 갖고있다고 해봅시다. 우리의 메인 패키지를 아래와 같이 구성하게 될 것입니다:</p><blockquote><p>An application may produce multiple binaries so we’ll use the Go convention of placing our main package as a subdirectory of the cmd package. For example, our project may have a myapp server binary but also a myappctl client binary for managing the server from the terminal. We’ll layout our main packages like this:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myapp/</span><br><span class="line">    cmd/</span><br><span class="line">        myapp/</span><br><span class="line">            main.go</span><br><span class="line">        myappctl/</span><br><span class="line">            main.go</span><br></pre></td></tr></table></figure><br><h3 id="컴파일-타임에-의존성-주입"><a href="#컴파일-타임에-의존성-주입" class="headerlink" title="컴파일 타임에 의존성 주입"></a>컴파일 타임에 의존성 주입</h3><p>“의존성 주입”이라는 용어는 나쁜 평판을 받아왔습니다. 이것은 장황한 Spring XML 파일에 대한 생각을 불러일으 킵니다. 하지만 그 용어의 실제 의미는 우리는 객체에게 스스로 빌드하거나 의존성을 직접 찾아가는 것을 요구하는 대신에 객체에게 의존성을 직접 전달해줄 것이다라는 것이 전부입니다.</p><blockquote><p>The term “dependency injection” has gotten a bad rap. It conjures up thoughts of verbose Spring XML files. However, all the term really means is that we’re going to pass dependencies to our objects instead of requiring that the object build or find the dependency itself.</p></blockquote><p>메인 패키지는 어떤 의존성을 어떤 객체에게 주입할 것인지를 선택하는 역할을 합니다. 메인 패키지는 단순히 이러한 조각들을 이어 붙이는 역할만을 수행하기 때문에 코드의 규모가 작고 사소한 경향이 있습니다:</p><blockquote><p>The main package is what gets to choose which dependencies to inject into which objects. Because the main package simply wires up the pieces, it tends to be fairly small and trivial code:</p></blockquote><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/benbjohnson/myapp"</span></span><br><span class="line"><span class="string">"github.com/benbjohnson/myapp/postgres"</span></span><br><span class="line"><span class="string">"github.com/benbjohnson/myapp/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// Connect to database.</span></span><br><span class="line">db, err := postgres.Open(os.Getenv(<span class="string">"DB"</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatal(err)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create services.</span></span><br><span class="line">us := &amp;postgres.UserService{DB: db}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attach to HTTP handler.</span></span><br><span class="line"><span class="keyword">var</span> h http.Handler</span><br><span class="line">h.UserService = us</span><br><span class="line"></span><br><span class="line"><span class="comment">// start http server...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><p>여러분의 메인 패키지 또한 어댑터의 역할을 한다는 것도 중요한 점입니다. 메인 패키지는 터미널과 여러분의 도메인을 연결해줍니다.</p><blockquote><p>It’s also important to note that your main package is also an adapter. It connects the terminal to your domain.</p></blockquote><br><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>어플리케이션 디자인은 매우 어려운 문제입니다. 너무나 많은 디자인 결정들이 존재하고 여러분에게 가이드해줄 견고한 이론들의 부재는 문제를 더욱 심각하게 만들 수 있습니다. 우리는 Go 어플리케이션에서 현재 사용되는 몇가지 접근 방식을 살펴보았고 그것들의 많은 결함들을 확인했습니다.</p><blockquote><p>Application design is a hard problem. There are so many design decisions to make and without a set of solid principles to guide you the problem is made even worse. We’ve looked at several current approaches to Go application design and we’ve seen many of their flaws.</p></blockquote><p>저는 의존성의 관점을 통해 디자인에 접근하는 방식이 코드 구성을 더 단순하고 쉽게 추론할 수 있도록 만들어 준다고 생각합니다. 먼저 우리는 도메인 언어를 디자인 합니다. 그리고나서 의존성들을 분리합니다. 다음으로 테스트 환경을 분리하기 위해 mocks를 도입합니다. 마지막으로 메인 패키지 안에서 이 모든 것들을 하나로 엮습니다.</p><blockquote><p>I believe approaching design from the standpoint of dependencies makes code organization simpler and easier to reason about. First we design our domain language. Then we isolate our dependencies. Next we introduce mocks to isolate our tests. Finally, we tie everything together within our main package.</p></blockquote><p>여러분이 디자인할 다음 어플리케이션에 이러한 이론들을 고려해보시기 바랍니다. 질문이 있으시거나 디자인에 대한 토론을 원하신다면 @benbjohnson 트위터를 통해 연락주시거나 Gopher 슬랙에서 benbjohnson을 찾아주세요.</p><blockquote><p>Consider these principles in the next application you design. If you have any questions or want to discuss design, contact me at @benbjohnson on Twitter or find me as benbjohnson on the Gopher slack.</p></blockquote><br><br><span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎<p><strong>Reference</strong></p><ul><li><a href="https://www.gobeyond.dev/standard-package-layout/">https://www.gobeyond.dev/standard-package-layout/</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://chelseafandev.github.io/categories/Go/">Go</category>
      
      
      <category domain="https://chelseafandev.github.io/tags/go/">go</category>
      
      <category domain="https://chelseafandev.github.io/tags/golang/">golang</category>
      
      <category domain="https://chelseafandev.github.io/tags/go-layout/">go layout</category>
      
      <category domain="https://chelseafandev.github.io/tags/organize-go-code/">organize go code</category>
      
      <category domain="https://chelseafandev.github.io/tags/package-layout/">package layout</category>
      
      
      <comments>https://chelseafandev.github.io/2022/09/06/translate-standard-package-layout-in-go/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CMake에 대해 알아보자</title>
      <link>https://chelseafandev.github.io/2022/03/05/cmake-tutorial/</link>
      <guid>https://chelseafandev.github.io/2022/03/05/cmake-tutorial/</guid>
      <pubDate>Sat, 05 Mar 2022 13:24:52 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;뭐하는 놈인지는 알고 쓰자&lt;/strong&gt;&lt;/em&gt; 시리즈의 세번째 주제는 &lt;code&gt;CMake&lt;/code&gt;입니다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><em><strong>뭐하는 놈인지는 알고 쓰자</strong></em> 시리즈의 세번째 주제는 <code>CMake</code>입니다.</p><span id="more"></span><p>해당 포스팅에서는 <a href="https://cmake.org/cmake/help/v3.22/guide/tutorial/index.html">CMake 공식 홈페이지</a>의 튜토리얼 내용을 번역해보았습니다. <a href="https://github.com/Kitware/CMake">CMake 공식 github</a>에서 제공해주는 프로젝트 폴더 구성과 소스 코드를 참조하여 좀 더 상세히 CMake의 사용법에 대해 알아보는 시간을 갖도록 하겠습니다. (튜토리얼 관련 소스 코드는 <a href="https://github.com/Kitware/CMake/tree/master/Help/guide/tutorial">이곳</a>에서 확인 가능합니다.)</p><p>한국어로 된 CMake 관련 설명이 필요하시다면 <a href="https://gist.github.com/luncliff/6e2d4eb7ca29a0afd5b592f72b80cb5c">CMake 할때 쪼오오금 도움이 되는 문서</a>도 굉장히 잘 정리되어있으니 참고하시기 바랍니다.</p><br><!-- toc --><br><hr><h1 id="CMake-Tutorial"><a href="#CMake-Tutorial" class="headerlink" title="CMake Tutorial"></a>CMake Tutorial</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>CMake 튜토리얼은 일반적인 빌드 시스템 이슈를 처리하기 위한 단계별 가이드를 제공해줍니다. 예시로 제공되는 프로젝트에서 다양한 주제들이 함께 처리되는 방식을 살펴보는 것은 아주 큰 도움이 될 것입니다.</p><blockquote><p>The CMake tutorial provides a step-by-step guide that covers common build system issues that CMake helps address. Seeing how various topics all work together in an example project can be very helpful.</p></blockquote><hr><h2 id="Step-1-A-Basic-Starting-Point"><a href="#Step-1-A-Basic-Starting-Point" class="headerlink" title="Step 1: A Basic Starting Point"></a>Step 1: A Basic Starting Point</h2><p>가장 기본적인 프로젝트는 소스 코드로부터 빌드되는 실행 파일입니다. 이 간단한 프로젝트에서는 <code>CMakeLists.txt</code> 파일에 단 3줄만이 필요합니다. 이것이 우리의 튜토리얼 시작 지점이 될 것입니다. 아래와 같이 작성된 <code>CMakeLists.txt</code> 파일을 <code>Step1</code> 디렉토리안에 생성해봅시다.</p><blockquote><p>The most basic project is an executable built from source code files. For simple projects, a three line <code>CMakeLists.txt</code> file is all that is required. This will be the starting point for our tutorial. Create a <code>CMakeLists.txt</code> file in the <code>Step1</code> directory that looks like:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.10)</span><br><span class="line"></span><br><span class="line"># set the project name</span><br><span class="line">project(Tutorial)</span><br><span class="line"></span><br><span class="line"># add the executable</span><br><span class="line">add_executable(Tutorial tutorial.cxx)</span><br></pre></td></tr></table></figure><p>이 예제에서는 <code>CMakeLists.txt</code> 파일에 소문자로 이루어진 명령어를 사용한다는 것에 주목하기바랍니다. CMake에서는 대문자, 소문자 그리고 이 둘이 혼합된 명령어를 지원합니다. <code>tutorial.cxx</code>의 소스 코드는 <code>Step1</code> 디렉토리에서 확인가능하며 이 코드는 제곱근을 계산하기 위해 사용될 수 있습니다.</p><blockquote><p>Note that this example uses lower case commands in the <code>CMakeLists.txt</code> file. Upper, lower, and mixed case commands are supported by CMake. The source code for <code>tutorial.cxx</code> is provided in the <code>Step1</code> directory and can be used to compute the square root of a number.</p></blockquote><h3 id="Build-and-Run"><a href="#Build-and-Run" class="headerlink" title="Build and Run"></a>Build and Run</h3><p>이것이 필요한 모든것입니다 - 지금 당장에 우리의 프로젝트를 빌드하고 실행할 수 있습니다! 먼저, 프로젝트를 설정하기 위해 <code>cmake</code> 실행 파일 또는 <code>cmake-gui</code> 실행합니다. 그리고나서 여러분이 선택한 빌드 툴을 가지고 빌드합니다.</p><blockquote><p>That’s all that is needed - we can build and run our project now! First, run the <code>cmake</code> executable or the <code>cmake-gui</code> to configure the project and then build it with your chosen build tool.</p></blockquote><p>예를 들어, 여러분은 커맨드 라인에서 CMake 소스 코드 트리의 <code>Help/guide/tutorial</code> 경로로 이동할 수 있고 아래 명령어를 입력하여 빌드 디렉토리를 생성할 수 있습니다:</p><blockquote><p>For example, from the command line we could navigate to the <code>Help/guide/tutorial</code> directory of the CMake source code tree and create a build directory:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir Step1_build</span><br></pre></td></tr></table></figure><p>다음으로, 생성한 빌드 디렉토리로 이동한 뒤 프로젝트를 설정하고 네이티브 빌드 시스템을 생성하기 위해 CMake를 실행합니다:</p><blockquote><p>Next, navigate to the build directory and run CMake to configure the project and generate a native build system:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Step1_build</span><br><span class="line">cmake ../Step1</span><br></pre></td></tr></table></figure><p>그리고나서 실질적으로 프로젝트를 컴파일하고 링크하기 위해 빌드 시스템을 호출합니다:</p><blockquote><p>Then call that build system to actually compile/link the project:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build</span><br></pre></td></tr></table></figure><p>마지막으로, 아래 명령어들을 통해 빌드된 <code>Tutorial</code>을 사용해봅시다:</p><blockquote><p>Finally, try to use the newly built <code>Tutorial</code> with these commands:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tutorial 4294967296</span><br><span class="line">Tutorial 10</span><br><span class="line">Tutorial</span><br></pre></td></tr></table></figure><h3 id="Adding-a-Version-Number-and-Configured-Header-File"><a href="#Adding-a-Version-Number-and-Configured-Header-File" class="headerlink" title="Adding a Version Number and Configured Header File"></a>Adding a Version Number and Configured Header File</h3><p>우리가 추가하게 될 첫번째 기능은 우리의 실행 파일과 프로젝트에 버전 번호를 제공하는 것입니다. 버전 번호를 소스 코드 상에 추가하는 것도 하나의 방법이지만 <code>CMakeLists.txt</code>의 사용은 이를 좀 더 유연하게 해줍니다.</p><blockquote><p>The first feature we will add is to provide our executable and project with a version number. While we could do this exclusively in the source code, using <code>CMakeLists.txt</code> provides more flexibility.</p></blockquote><p>먼저, 프로젝트의 이름과 버전 번호를 설정하기 위한 명령어인 project()를 사용하기 위해 <code>CMakeLists.txt</code> 파일을 수정합니다.</p><blockquote><p>First, modify the <code>CMakeLists.txt</code> file to use the project() command to set the project name and version number.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.10)</span><br><span class="line"></span><br><span class="line"># set the project name and version</span><br><span class="line">project(Tutorial VERSION 1.0)</span><br></pre></td></tr></table></figure><p>그리고나서, 버전 번호를 소스 코드로 전달하기 위해 헤더 파일을 설정합니다.</p><blockquote><p>Then, configure a header file to pass the version number to the source code:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configure_file(TutorialConfig.h.in TutorialConfig.h)</span><br></pre></td></tr></table></figure><p>설정된 파일은 바이너리 트리 안에 작성될 것이기때문에 포함 파일을 찾기 위해 경로 리스트에 해당 디렉토리를 추가해주어야합니다. <code>CMakeLists.txt</code> 파일의 끝에 아래 라인을 추가해줍니다.</p><blockquote><p>Since the configured file will be written into the binary tree, we must add that directory to the list of paths to search for include files. Add the following lines to the end of the <code>CMakeLists.txt</code> file:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target_include_directories(Tutorial PUBLIC &quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;)</span><br></pre></td></tr></table></figure><p>여러분이 선호하는 편집기를 사용하여 아래 내용을 포함하고 있는 <code>TutorialConfig.h.in</code> 파일을 소스 디렉토리에 생성해줍시다.</p><blockquote><p>Using your favorite editor, create <code>TutorialConfig.h.in</code> in the source directory with the following contents:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// the configured options and settings for Tutorial</span><br><span class="line">#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@</span><br><span class="line">#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@</span><br></pre></td></tr></table></figure><p>CMake가 이 헤더 파일을 설정하는 동안 <code>@Tutorial_VERSION_MAJOR@</code>와 <code>@Tutorial_VERSION_MINOR@</code> 값은 대체될 것입니다.</p><blockquote><p>When CMake configures this header file the values for <code>@Tutorial_VERSION_MAJOR@</code> and <code>@Tutorial_VERSION_MINOR@</code> will be replaced.</p></blockquote><p>다음으로 설정된 헤더 파일인 <code>TutorialConfig.h</code>를 포함하기 위해 <code>tutorial.cxx</code> 파일을 수정합시다.</p><blockquote><p>Next modify <code>tutorial.cxx</code> to include the configured header file, <code>TutorialConfig.h</code>.</p></blockquote><p>마지막으로, 아래와 같이 <code>tutorial.cxx</code> 파일을 수정해서 실행 파일의 이름과 버전 번호를 출력해봅시다.</p><blockquote><p>Finally, let’s print out the executable name and version number by updating <code>tutorial.cxx</code> as follows:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (argc &lt; 2) &#123;</span><br><span class="line">    // report version</span><br><span class="line">    std::cout &lt;&lt; argv[0] &lt;&lt; &quot; Version &quot; &lt;&lt; Tutorial_VERSION_MAJOR &lt;&lt; &quot;.&quot;</span><br><span class="line">              &lt;&lt; Tutorial_VERSION_MINOR &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; number&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Specify-the-C-Standard"><a href="#Specify-the-C-Standard" class="headerlink" title="Specify the C++ Standard"></a>Specify the C++ Standard</h3><p>다음으로 <code>tutorial.cxx</code> 소스 내에 <code>atof</code>를 <code>std::stod</code>로 변경함으로써 C++11 기능을 우리 프로젝트에 추가해봅시다. 동시에 <code>#include &lt;cstdlib&gt;</code> 선언도 제거해줍니다.</p><blockquote><p>Next let’s add some C++11 features to our project by replacing <code>atof</code> with <code>std::stod</code> in <code>tutorial.cxx</code>. At the same time, remove <code>#include &lt;cstdlib&gt;</code>.</p></blockquote><p>우리는 올바른 플래그 값을 사용하도록 CMake 코드에 명시적으로 언급할 필요가 있을것입니다. CMake에서 특정 C++ 버전을 지원하도록 하는 가장 쉬운 방법은 CMAKE_CXX_STANDARD 변수를 사용하는 것입니다. 현재 튜토리얼에서는 <code>CMakeLists.txt</code> 파일의 CMAKE_CXX_STANDARD 변수를 <code>11</code>로 설정하고, CMAKE_CXX_STANDARD_REQUIRED 변수를 <code>True</code>로 설정해보겠습니다. <code>CMAKE_CXX_STANDARD</code>는 <code>add_executable</code> 명령어 호출 이전에 선언되어야한다는 것을 잊지말기 바랍니다.</p><blockquote><p>We will need to explicitly state in the CMake code that it should use the correct flags. The easiest way to enable support for a specific C++ standard in CMake is by using the CMAKE_CXX_STANDARD variable. For this tutorial, set the CMAKE_CXX_STANDARD variable in the <code>CMakeLists.txt</code> file to <code>11</code> and CMAKE_CXX_STANDARD_REQUIRED to <code>True</code>. Make sure to add the <code>CMAKE_CXX_STANDARD</code> declarations above the call to <code>add_executable</code>.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.10)</span><br><span class="line"></span><br><span class="line"># set the project name and version</span><br><span class="line">project(Tutorial VERSION 1.0)</span><br><span class="line"></span><br><span class="line"># specify the C++ standard</span><br><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br><span class="line">set(CMAKE_CXX_STANDARD_REQUIRED True)</span><br></pre></td></tr></table></figure><h3 id="Rebuild"><a href="#Rebuild" class="headerlink" title="Rebuild"></a>Rebuild</h3><p>우리의 프로젝트를 다시 빌드해봅시다. 우리는 이미 빌드 디렉토리 생성했고 CMake를 실행했기때문에 빌드 과정으로 건너뛸 수 있습니다:</p><blockquote><p>Let’s build our project again. We already created a build directory and ran CMake, so we can skip to the build step:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Step1_build</span><br><span class="line">cmake --build .</span><br></pre></td></tr></table></figure><p>이제 이전과 동일한 명령어를 통해 새롭게 빌드된 <code>Tutorial</code>을 실행해볼 수 있습니다.</p><blockquote><p>Now we can try to use the newly built <code>Tutorial</code> with same commands as before:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tutorial 4294967296</span><br><span class="line">Tutorial 10</span><br><span class="line">Tutorial</span><br></pre></td></tr></table></figure><p>인자 없이 실행 파일을 구동 할때 버전 번호가 출력되는지 확인해보시길 바랍니다.</p><blockquote><p>Check that the version number is now reported when running the executable without any arguments.</p></blockquote><hr><h2 id="Step-2-Adding-a-Library"><a href="#Step-2-Adding-a-Library" class="headerlink" title="Step 2: Adding a Library"></a>Step 2: Adding a Library</h2><p>이제 우리의 프로젝트에 라이브러리를 추가해볼 것입니다. 이 라이브러리는 제곱근 계산을 직접 구현한 내용이 포함되어 있을 것입니다. 해당 라이브러리를 추가한 이후에는 실행 파일이 컴파일러가 제공하는 일반적인 제곱근 함수 대신에 이 라이브러리를 사용할 수 있게됩니다.</p><blockquote><p>Now we will add a library to our project. This library will contain our own implementation for computing the square root of a number. The executable can then use this library instead of the standard square root function provided by the compiler.</p></blockquote><p>이번 튜토리얼에서는 해당 라이브러리를 <code>MathFunctions</code>이라는 하위 디렉토리에 포함시킬 것입니다. 이 디렉토리에는 헤더 파일인 <code>MathFunctions.h</code>와 소스 파일인 <code>mysqrt.cxx</code>가 포함되어 있습니다. 소스 파일에는 컴파일러의 sqrt 함수와 유사한 기능을 제공하는 <code>mysqrt</code>라는 함수가 존재합니다.</p><blockquote><p>For this tutorial we will put the library into a subdirectory called <code>MathFunctions</code>. This directory already contains a header file, <code>MathFunctions.h</code>, and a source file <code>mysqrt.cxx</code>. The source file has one function called <code>mysqrt</code> that provides similar functionality to the compiler’s sqrt function.</p></blockquote><p><code>MathFunctions</code> 디렉토리의 <code>CMakeLists.txt</code> 파일에 아래와 같이 한 줄을 추가합니다.</p><blockquote><p>Add the following one line <code>CMakeLists.txt</code> file to the <code>MathFunctions</code> directory:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_library(MathFunctions mysqrt.cxx)</span><br></pre></td></tr></table></figure><p>새롭게 추가한 라이브러리를 사용하기 위해 <U>①최상위 <code>CMakeLists.txt</code> 파일에 <strong>add_subdirectory()</strong> 호출을 추가</U>할 것이며, 이 호출을 통해 라이브러리가 빌드될 것 입니다. <U>②실행 파일에 새로운 라이브러리를 추가</U>하고 <code>mysqrt.h</code> <U>③헤더 파일을 참조할 수 있도록 <code>MathFunctions</code>를 포함 디렉토리로 추가</U>합니다. 이제 최상위 <code>CMakeLists.txt</code> 파일의 마지막 몇 개의 라인은 아래와 같아야 합니다:</p><blockquote><p>To make use of the new library we will add an <strong>add_subdirectory()</strong> call in the top-level <code>CMakeLists.txt</code> file so that the library will get built. We add the new library to the executable, and add <code>MathFunctions</code> as an include directory so that the <code>mysqrt.h</code> header file can be found. The last few lines of the top-level <code>CMakeLists.txt</code> file should now look like:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># ① add the MathFunctions library</span><br><span class="line">add_subdirectory(MathFunctions)</span><br><span class="line"></span><br><span class="line"># add the executable</span><br><span class="line">add_executable(Tutorial tutorial.cxx)</span><br><span class="line"></span><br><span class="line"># ② add the new library(= MathFUnction) to the executable</span><br><span class="line">target_link_libraries(Tutorial PUBLIC MathFunctions)</span><br><span class="line"></span><br><span class="line"># ③ add the binary tree to the search path for include files so that we will find TutorialConfig.h</span><br><span class="line">target_include_directories(Tutorial PUBLIC </span><br><span class="line">                           &quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span><br><span class="line">                           &quot;$&#123;PROJECT_SOURCE_DIR&#125;/MathFunctions&quot;</span><br><span class="line">                          )</span><br></pre></td></tr></table></figure><p>이번엔 <code>MathFunctions</code> 라이브러리를 옵션화해봅시다. 이번 튜토리얼을 진행하는데 있어서 이 작업이 반드시 필요한 것은 아니지만, 규모가 더 큰 프로젝트들에서 이러한 옵션화 작업은 일반적입니다. 가장 먼저 최상위 <code>CMakeLists.txt</code> 파일에 option을 추가합니다.</p><blockquote><p>Now let us make the <code>MathFunctions</code> library optional. While for the tutorial there really isn’t any need to do so, for larger projects this is a common occurrence. The first step is to add an option to the top-level <code>CMakeLists.txt</code> file.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">option(USE_MYMATH &quot;Use tutorial provided math implementation&quot; ON)</span><br><span class="line"></span><br><span class="line"># configure a header file to pass some of the CMake settings</span><br><span class="line"># to the source code</span><br><span class="line">configure_file(TutorialConfig.h.in TutorialConfig.h)</span><br></pre></td></tr></table></figure><p>이 옵션은 <strong>cmake-gui</strong>와 <strong>ccmake</strong>에서 기본 값인 <code>ON</code>으로 보여지게 될 것이며 이 값은 사용자가 변경할 수 있습니다. 이 설정은 캐시에 저장될 것이기 때문에 사용자는 빌드 디렉토리에서 CMake를 실행할 때마다 이 값을 설정할 필요가 없습니다.</p><blockquote><p>This option will be displayed in the <strong>cmake-gui</strong> and <strong>ccmake</strong> with a default value of <code>ON</code> that can be changed by the user. This setting will be stored in the cache so that the user does not need to set the value each time they run CMake on a build directory.</p></blockquote><p>다음 변화는 <code>MathFunctions</code> 라이브러리를 조건에 따라 빌드하고 링킹하도록 만드는 것입니다. 이를 위해 옵션 값을 체크하는 if 구문을 생성할 것입니다. if 블록 내부에 라이브러리를 링크하기 위해 필요한 정보를 저장하고 하위 디렉토리를 튜토리얼 타겟의 포함 디렉토리로 추가하기 위한 list 명령어와 함께  <strong>add_subdirectory()</strong> 명령어를 추가합시다.</p><blockquote><p>The next change is to make building and linking the <code>MathFunctions</code> library conditional. To do this, we will create an <code>if</code> statement which checks the value of the option. Inside the if block, put the <strong>add_subdirectory()</strong> command from above with some additional list commands to store information needed to link to the library and add the subdirectory as an include directory in the <code>Tutorial</code> target. The end of the top-level <code>CMakeLists.txt</code> file will now look like the following:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if(USE_MYMATH)</span><br><span class="line">  add_subdirectory(MathFunctions)</span><br><span class="line">  list(APPEND EXTRA_LIBS MathFunctions)</span><br><span class="line">  list(APPEND EXTRA_INCLUDES &quot;$&#123;PROJECT_SOURCE_DIR&#125;/MathFunctions&quot;)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line"># add the executable</span><br><span class="line">add_executable(Tutorial tutorial.cxx)</span><br><span class="line"></span><br><span class="line">target_link_libraries(Tutorial PUBLIC $&#123;EXTRA_LIBS&#125;)</span><br><span class="line"></span><br><span class="line"># add the binary tree to the search path for include files</span><br><span class="line"># so that we will find TutorialConfig.h</span><br><span class="line">target_include_directories(Tutorial PUBLIC </span><br><span class="line">                           &quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span><br><span class="line">                           $&#123;EXTRA_INCLUDES&#125;</span><br><span class="line">                          )</span><br></pre></td></tr></table></figure><p>나중에 실행파일에 링크되는 옵션화된 라이브러리들을 모으기 위해 <code>EXTRA_LIBS</code> 라는 변수를 사용하는 것을 주목하기 바랍니다. <code>EXTRA_INCLUDES</code> 변수는 옵션화된 헤더 파일을 대상으로 이와 유사하게 사용됩니다. 이것은 많은 옵션 컴포넌트들을 처리하기 위한 고전적인 방식이며, 다음 단계에서 현대적인 접근 방식에 대해 살펴볼 것입니다.</p><blockquote><p>Note the use of the variable <code>EXTRA_LIBS</code> to collect up any optional libraries to later be linked into the executable. The variable <code>EXTRA_INCLUDES</code> is used similarly for optional header files. This is a classic approach when dealing with many optional components, we will cover the modern approach in the next step.</p></blockquote><p>위 작업에 따른 소스 코드 상의 변경점은 꽤 간단합니다. 먼저, 필요 시에 <code>tutorial.cxx</code>에서 <code>MathFunctions.h</code>를 포함시켜줍니다.</p><blockquote><p>The corresponding changes to the source code are fairly straightforward. First, in <code>tutorial.cxx</code>, include the <code>MathFunctions.h</code> header if we need it:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifdef USE_MYMATH</span><br><span class="line">#  include &quot;MathFunctions.h&quot;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>그리고 나서, <code>USE_MYMATH</code>를 제곱근 함수가 사용되는 조건으로 만들어줍니다.</p><blockquote><p>Then, in the same file, make <code>USE_MYMATH</code> control which square root function is used:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef USE_MYMATH</span><br><span class="line">  const double outputValue = mysqrt(inputValue);</span><br><span class="line">#else</span><br><span class="line">  const double outputValue = sqrt(inputValue);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>이제 소스 코드에서 <code>USE_MYMATH</code> 변수를 요구하고 있기때문에 이 값을 <code>TutorialConfig.h.in</code> 파일에 아래와 같이 추가할 수 있습니다:</p><blockquote><p>Since the source code now requires <code>USE_MYMATH</code> we can add it to <code>TutorialConfig.h.in</code> with the following line:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#cmakedefine USE_MYMATH</span><br></pre></td></tr></table></figure><p>프로젝트를 설정(configure)하기 위해 <strong>cmake</strong> 실행 파일 또는 <strong>cmake-gui</strong>를 실행시키고 여러분의 빌드 도구에 맞게 빌드합니다. 그리고 빌드된 Tutorial 실행 파일을 실행합니다.</p><blockquote><p>Run the <strong>cmake</strong> executable or the <strong>cmake-gui</strong> to configure the project and then build it with your chosen build tool. Then run the built Tutorial executable.</p></blockquote><p>이제 <code>USE_MYMATH</code> 값을 업데이트 해봅시다. 가장 쉬운 방법은 <strong>cmake-gui</strong>를 사용하거나 터미널 환경이라면 <strong>ccmake</strong>를 사용하는 것입니다. 또는 command-line의 옵션을 변경하기를 원한다면 아래와 같이 시도해보시기 바랍니다:</p><blockquote><p>Now let’s update the value of <code>USE_MYMATH</code>. The easiest way is to use the <strong>cmake-gui</strong> or <strong>ccmake</strong> if you’re in the terminal. Or, alternatively, if you want to change the option from the command-line, try:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake ../Step2 -DUSE_MYMATH=OFF</span><br></pre></td></tr></table></figure><hr><h2 id="Step-3-Adding-Usage-Requirements-for-a-Library"><a href="#Step-3-Adding-Usage-Requirements-for-a-Library" class="headerlink" title="Step 3: Adding Usage Requirements for a Library"></a>Step 3: Adding Usage Requirements for a Library</h2><p>사용 요구 사항을 통해 라이브러리 또는 실행 파일의 링크 및 포함 라인을 훨씬 더 잘 제어할 수 있으며 CMake 내 대상의 전이 속성을 더 많이 제어할 수 있습니다. 사용 요구 사항을 활용하는 기본 명령은 다음과 같습니다:</p><blockquote><p>Usage requirements allow for far better control over a library or executable’s link and include line while also giving more control over the transitive property of targets inside CMake. The primary commands that leverage usage requirements are:</p><ul><li>target_compile_definitions()</li><li>target_compile_options()</li><li>target_include_directories()</li><li>target_link_libraries()</li></ul></blockquote><p>사용 요구 사항의 현대적인 CMake 접근 방식을 사용하기 위해 앞선 챕터였던 <strong>Adding a Library</strong>에서 사용한 소스 코드를 리팩토링 해보겠습니다. 먼저 <code>MathFunctions</code> 라이브러리를 링킹하고자 한다면 현재 소스 디렉토리를 포함해야하지만 <code>MathFunctions</code> 자체는 포함하지 않습니다. 따라서 이것인 <code>INTERFACE</code> 사용 요구사항이 될 수 있습니다.</p><blockquote><p>Let’s refactor our code from <strong>Adding a Library</strong> to use the modern CMake approach of usage requirements. We first state that anybody linking to <code>MathFunctions</code> needs to include the current source directory, while <code>MathFunctions</code> itself doesn’t. So this can become an <code>INTERFACE</code> usage requirement.</p></blockquote><p><code>INTERFACE</code>는 소비자가 필요로 하지만 생산자는 그렇지 않다는 것을 기억하기 바랍니다. <code>MathFunctions/CMakeLists.txt</code> 파일의 끝에 아래 라인을 추가합니다.</p><blockquote><p>Remember <code>INTERFACE</code> means things that consumers require but the producer doesn’t. Add the following lines to the end of <code>MathFunctions/CMakeLists.txt</code>:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target_include_directories(MathFunctions</span><br><span class="line">          INTERFACE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span><br><span class="line">          )</span><br></pre></td></tr></table></figure><p>이제 <code>MathFunctions</code>에 대한 사용 요구 사항을 명시했으므로 최상위 <code>CMakeLists.txt</code>에서 <code>EXTRA_INCLUDES</code>변수 사용을 안전하게 제거할 수 있습니다:</p><blockquote><p>Now that we’ve specified usage requirements for <code>MathFunctions</code> we can safely remove our uses of the <code>EXTRA_INCLUDES</code> variable from the top-level <code>CMakeLists.txt</code>, here:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(USE_MYMATH)</span><br><span class="line">  add_subdirectory(MathFunctions)</span><br><span class="line">  list(APPEND EXTRA_LIBS MathFunctions)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure><blockquote><p>And here:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target_include_directories(Tutorial PUBLIC</span><br><span class="line">                           &quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span><br><span class="line">                           )</span><br></pre></td></tr></table></figure><p>위와 같이 수정을 완료하였다면 프로젝트를 설정(configure)하기 위해 <strong>cmake</strong> 실행 파일 또는 <strong>cmake-gui</strong>를 실행시키고 여러분의 빌드 도구에 맞게 빌드하거나 빌드 디렉토리에서 <code>cmake --build</code>를 사용하여 빌드합니다.</p><blockquote><p>Once this is done, run the <strong>cmake</strong> executable or the <strong>cmake-gui</strong> to configure the project and then build it with your chosen build tool or by using <code>cmake --build .</code> from the build directory.</p></blockquote><br><br><span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎<p><strong>reference</strong></p><ul><li><a href="https://cmake.org/cmake/help/v3.22/guide/tutorial/index.html">https://cmake.org/cmake/help/v3.22/guide/tutorial/index.html</a></li><li><a href="https://github.com/Kitware/CMake/tree/master/Help/guide/tutorial">https://github.com/Kitware/CMake/tree/master/Help/guide/tutorial</a></li><li><a href="https://gist.github.com/luncliff/6e2d4eb7ca29a0afd5b592f72b80cb5c">https://gist.github.com/luncliff/6e2d4eb7ca29a0afd5b592f72b80cb5c</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://chelseafandev.github.io/categories/C/">C++</category>
      
      
      <category domain="https://chelseafandev.github.io/tags/cmake/">cmake</category>
      
      <category domain="https://chelseafandev.github.io/tags/CMakeFile-txt/">CMakeFile.txt</category>
      
      <category domain="https://chelseafandev.github.io/tags/CMake-tutorial/">CMake tutorial</category>
      
      
      <comments>https://chelseafandev.github.io/2022/03/05/cmake-tutorial/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>io_context::run 함수가 반환되는 것을 막는 방법</title>
      <link>https://chelseafandev.github.io/2022/01/11/prevent-io-context-run-from-returning/</link>
      <guid>https://chelseafandev.github.io/2022/01/11/prevent-io-context-run-from-returning/</guid>
      <pubDate>Tue, 11 Jan 2022 07:17:36 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;뭐하는 놈인지는 알고 쓰자&lt;/strong&gt;&lt;/em&gt; 시리즈의 두번째 주제는 &lt;code&gt;boost io_context::run 함수를 실행 상태로 유지하는 방법&lt;/code&gt;입니다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><em><strong>뭐하는 놈인지는 알고 쓰자</strong></em> 시리즈의 두번째 주제는 <code>boost io_context::run 함수를 실행 상태로 유지하는 방법</code>입니다.</p><span id="more"></span><p>해당 포스팅에서는 io_context를 사용하기 위해서는 반드시 run 함수를 호출해야한다는 주입식(?) 교육에서 벗어나고자 boost io_context::run 함수에 대해 간략히 알아보고, 우리의 최종 목표인 io_context에 당장에 할당된 작업이 없더라도 io_context::run 함수를 실행 상태로 유지하는 방법에 대해 알아보도록 하겠습니다. <a href="https://dens.website/tutorials/cpp-asio/work">Prevent io_context::run from returning</a> 사이트의 내용을 바탕으로 작성되었으니 참고부탁드립니다.</p><br><!-- toc --><br><h2 id="io-context-run-함수란"><a href="#io-context-run-함수란" class="headerlink" title="io_context::run 함수란?"></a>io_context::run 함수란?</h2><p>먼저 <a href="https://www.boost.org/doc/libs/1_78_0/doc/html/boost_asio/reference/io_context/run/overload1.html">Boost 공식 매뉴얼</a>의 내용을 참고하여 io_context::run 함수에 대해 간략히 알아보도록 하겠습니다.</p><br><p>io_context::run 함수는 io_context 객체의 이벤트 처리 루프를 실행합니다.</p><blockquote><p>Run the io_context object’s event processing loop.</p></blockquote><p>run() 함수는 모든 작업이 완료되거나 더이상 처리할 핸들러가 없을때까지 블록상태를 유지합니다. </p><blockquote><p>The run() function blocks until all work has finished and there are no more handlers to be dispatched, or until the io_context has been stopped.</p></blockquote><p>io_context가 핸들러를 실행하는 공간인 쓰레드 풀을 설정하기 위해 다중 쓰레드에서도 run() 함수를 호출할 수 있습니다. 쓰레드 풀에서 대기 중인 쓰레드들은 모두 동등한 자격을 가지며 io_context는 핸들러를 실행시키기위해 임의로 그들중 한개를 선택하게됩니다.</p><blockquote><p>Multiple threads may call the run() function to set up a pool of threads from which the io_context may execute handlers. All threads that are waiting in the pool are equivalent and the io_context may choose any one of them to invoke a handler.</p></blockquote><p>run() 함수로 부터 빠져나오기 위한 일반적인 방법은 io_context 객체가 종료되도록하는 것입니다. run(), run_one(), poll() 또는 poll_one() 함수를 restart() 함수 호출없이 연속해서 호출하는 경우에는 곧바로 해당 함수를 빠져나오게 될 것입니다.</p><blockquote><p>A normal exit from the run() function implies that the io_context object is stopped (the stopped() function returns true). Subsequent calls to run(), run_one(), poll() or poll_one() will return immediately unless there is a prior call to restart().</p></blockquote><p>여기서 저희가 주목할 내용은 io_context::run 함수는 (의도적인 종료 함수의 호출을 제외하고는) io_context 상의 모든 작업이 종료되고, 더이상 io_context에 할당(dispatch)된 핸들러가 없을때까지만 블록(block)상태를 유지한다는 것입니다.</p><br><h2 id="io-context-run-함수가-반환되지-않도록-하는-방법"><a href="#io-context-run-함수가-반환되지-않도록-하는-방법" class="headerlink" title="io_context::run 함수가 반환되지 않도록 하는 방법"></a>io_context::run 함수가 반환되지 않도록 하는 방법</h2><p>그렇다면 io_context에 당장에 할당할 작업은 없더라도 run 함수를 블록상태로 유지하기 위해서는 어떻게 해야할까요? 여기서 부터는 원문 포스팅에 대한 번역 내용입니다.</p><br><p><strong>io_context::run</strong>은 모든 예약된 작업이 완료될때까지 실행 상태를 유지합니다. 모든 작업이 완료된 이후에 <strong>io_context::run</strong>은 반환될것이며, 해당 함수를 호출한 쓰레드는 블록이 해제될 것입니다.</p><blockquote><p><strong>io_context::run</strong> runs until all scheduled tasks are completed. After that <strong>io_context::run</strong> will return and the caller thread will unblock:</p></blockquote><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boost::asio::io_context io_context;</span><br><span class="line"><span class="comment">// Schedule some tasks</span></span><br><span class="line">io_context.run();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Job's done! Continue the execution\n"</span>;</span><br></pre></td></tr></tbody></table></figure></div></figure><p>하지만 때때로 수행할 작업의 유무에 관계없이 io_context::run의 실행 상태를 유지해야하는 경우가 있습니다. 지금까지 살펴보았던 서버들은 항상 <strong>async_accept</strong>를 수행중이었기때문에 적어도 하나의 예약된 작업을 계속해서 가지고 있었습니다. 그렇기때문에 우리는 특정한 방법을 활용하여 그들을 실행중인 상태로 유지해야할 필요가 없었습니다.</p><blockquote><p>However sometimes you may need to keep it running regardless if there are tasks to execute or not. Servers we’ve reviewed so far were always doing <strong>async_accept</strong>, so they always had at least one task scheduled, so we didn’t really need to keep them running in such a way. </p></blockquote><p>하지만 클라이언트는 <strong>async_accept</strong> 작업을 수행하지 않으며, 그것의 입장에서 어떠한 특정 시점에 예약된 작업이 없다는 것은 지극히 일반적인 상황입니다. 이러한 상황에서 <strong>io_context::run</strong> 함수가 반환되는 것을 막기 위해 여러분은 <strong>boost::asio::executor_work_guard</strong> 클래스 인스턴스를 사용해야 합니다. 그것의 이름이 너무 길어지는 관계로 별칭(alias)을 사용하도록 하겠습니다.</p><blockquote><p>However a client doesn’t do <strong>async_accept</strong> and it’s a normal thing for it not to have scheduled tasks at some point at all. To prevent <strong>io_context::run</strong> from returning you should use <strong>boost::asio::executor_work_guard</strong>(a former <strong>io_context::work</strong> which is currently deprecated) class instance. Its name is too long, so let’s alias it right away:</p></blockquote><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> work_guard_type = boost::asio::executor_work_guard&lt;boost::asio::io_context::executor_type&gt;;</span><br><span class="line"></span><br><span class="line">boost::asio::io_context io_context;</span><br><span class="line"><span class="function">work_guard_type <span class="title">work_guard</span><span class="params">(io_context.get_executor())</span></span>;</span><br><span class="line"><span class="comment">// Schedule some tasks or not</span></span><br><span class="line">io_context.run();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorry, we'll never reach this!\n"</span>;</span><br></pre></td></tr></tbody></table></figure></div></figure><p>여러분은 여전히 어플리케이션을 강제로 혹은 우아하게 종료하기 위한 방법이 필요합니다. 이를 위해 <strong>io_context::stop</strong> 함수를 사용할 수 있습니다.</p><blockquote><p>You still need a way to stop your application somehow, and to stop it gracefully. You may use <strong>io_context::stop</strong> function:</p></blockquote><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">boost::asio::io_context io_context;</span><br><span class="line"><span class="function">work_guard_type <span class="title">work_guard</span><span class="params">(io_context.get_executor())</span></span>;</span><br><span class="line"><span class="comment">// Schedule some tasks or not</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">watchdog</span><span class="params">([&amp;]</span></span></span><br><span class="line"><span class="function"><span class="params">{</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="number">10</span>s);</span></span></span><br><span class="line"><span class="function"><span class="params">    io_context.stop(); <span class="comment">// That's OK, io_context::stop is thread-safe</span></span></span></span><br><span class="line"><span class="function"><span class="params">})</span></span>;</span><br><span class="line">io_context.run();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"We stopped after 10 seconds of running\n"</span>;</span><br></pre></td></tr></tbody></table></figure></div></figure><p>위 경우에 <strong>io_context::run</strong> 함수는 그 즉시 종료되지는 않을 것이지만 가장 적절한 시점에 종료될 것이며 남아있는 예약 작업들은 버려지게 될 것입니다. 이것은 정확히 우리가 원하던 동작일 겁니다.</p><blockquote><p>In that case <strong>io_context::run</strong> won’t stop right away but do this in the nearest suitable point of time, and the rest of scheduled tasks will be discarded. And that may be exactly what you’re needed.</p></blockquote><p>여러분은 또한 예약된 모든 작업이 완료될때까지 대기하다 그 이후에 <strong>io_context::run</strong> 함수가 반환되길 원할수도 있습니다. 이를위해 <strong>io_context::work</strong> 클래스 인스턴스를 파괴해주기만 하면 됩니다. 파괴하는 연산 또한 쓰레드에 안전합니다.</p><blockquote><p>You may also need to wait until all scheduled tasks are completed and return from <strong>io_context::run</strong> after that. To do so you just need to destroy <strong>io_context::work</strong> class instance. This operation is also thread-safe:</p></blockquote><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">boost::asio::io_context io_context;</span><br><span class="line"><span class="keyword">auto</span> work_guard = <span class="built_in">std</span>::make_unique&lt;work_guard_type&gt;(io_context.get_executor());</span><br><span class="line"><span class="comment">// Schedule some tasks or not</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">watchdog</span><span class="params">([&amp;]</span></span></span><br><span class="line"><span class="function"><span class="params">{</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="number">10</span>s);</span></span></span><br><span class="line"><span class="function"><span class="params">    work_guard.reset(); <span class="comment">// Work guard is destroyed, io_context::run is free to return</span></span></span></span><br><span class="line"><span class="function"><span class="params">})</span></span>;</span><br><span class="line">io_context.run();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"We stopped after 10+ seconds of running\n"</span>;</span><br></pre></td></tr></tbody></table></figure></div></figure><p>만약 <strong>io_context::run</strong> 함수가 반환된 후 그것을 다시 호출하고 싶다면 그 전에 <strong>io_context::restart</strong> 함수를 호출해야합니다.</p><blockquote><p>If you’re going to call <strong>io_context::run</strong> once again after it returned, then you should call <strong>io_context::restart</strong> before that.</p></blockquote><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boost::asio::io_context context;</span><br><span class="line">boost::asio::post(context, [](){ <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello boost::asio::post in context first"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; });</span><br><span class="line">temp_context.run();</span><br><span class="line">boost::asio::post(temp_context, [](){ <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello boost::asio::post in context second"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; });</span><br><span class="line">temp_context.restart();</span><br><span class="line">temp_context.run();</span><br></pre></td></tr></tbody></table></figure></div></figure><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>지금까지 io_context에 당장에 할당된 작업이 없더라도 io_context::run 함수를 실행 상태로 유지하는 방법에 대해 알아보았습니다. 아래와 같이 정리해보면서 포스팅을 마치도록 하겠습니다.<br><br></p><ul><li>io_context에 할당된 작업이 없으면 io_context::run 함수는 즉시 반환된다.</li><li>io_context에 당장에 할당된 작업이 없는 상황에서 io_context::run 함수가 반환되는 것을 막기 위해서는 boost::asio::executor_work_guard 클래스 인스턴스를 사용하라.</li><li>io_context::run 함수가 반환된 후 다시 한번 호출하고 싶다면 io_context::restart 함수를 먼저 호출하라.</li></ul><br><br><span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎<p><strong>Reference</strong></p><ul><li><a href="https://www.boost.org/doc/libs/1_78_0/doc/html/boost_asio/reference/io_context/run/overload1.html">https://www.boost.org/doc/libs/1_78_0/doc/html/boost_asio/reference/io_context/run/overload1.html</a></li><li><a href="https://dens.website/tutorials/cpp-asio/work">https://dens.website/tutorials/cpp-asio/work</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://chelseafandev.github.io/categories/C/">C++</category>
      
      
      <category domain="https://chelseafandev.github.io/tags/boost-asio/">boost asio</category>
      
      <category domain="https://chelseafandev.github.io/tags/io-context/">io_context</category>
      
      <category domain="https://chelseafandev.github.io/tags/io-context-run/">io_context run</category>
      
      <category domain="https://chelseafandev.github.io/tags/io-context-block/">io_context block</category>
      
      
      <comments>https://chelseafandev.github.io/2022/01/11/prevent-io-context-run-from-returning/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>boost io_context에 대한 고찰</title>
      <link>https://chelseafandev.github.io/2021/12/28/boost-io-context/</link>
      <guid>https://chelseafandev.github.io/2021/12/28/boost-io-context/</guid>
      <pubDate>Tue, 28 Dec 2021 01:54:29 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;뭐하는 놈인지는 알고 쓰자&lt;/strong&gt;&lt;/em&gt; 시리즈의 첫번째 주제는 &lt;code&gt;boost io_context&lt;/code&gt;입니다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><em><strong>뭐하는 놈인지는 알고 쓰자</strong></em> 시리즈의 첫번째 주제는 <code>boost io_context</code>입니다.</p><span id="more"></span><p>이번 기회에 boost 라이브러리를 사용하다보면 한번쯤은 마주치게되는 io_context에 대해 생각해보는 시간을 갖겠습니다.</p><br><!-- toc --><br><hr><h1 id="Boost-Asio"><a href="#Boost-Asio" class="headerlink" title="Boost Asio"></a>Boost Asio</h1><p>우선 io_context에 대해 이야기하기 전에 Boost Asio를 간략하게 소개하고 넘어가도록 하겠습니다. boost 공식 홈페이지의 내용을 참고하여 작성하였으니 원문 내용은 <a href="https://www.boost.org/doc/libs/1_78_0/doc/html/boost_asio/overview.html">여기</a>를 참조해주시기 바랍니다.</p><br><p>Boost.Asio는 쓰레드와 명시적 Locking을 기반으로한 동시성 모델의 사용을 프로그램에게 요구하지 않으면서 느린 I/O operation을 관리하는 도구를 제공합니다. (이는 Boost.Asio 내부적으로 동시성 처리를 할거니깐 사용자들은 걱정말고 사용하라는 의미로도 볼 수 있죠.)</p><blockquote><p>Boost.Asio provides the tools to manage these long running operations, without requiring programs to use concurrency models based on threads and explicit locking.</p></blockquote><p>소켓을 예로 들어 Boost.Asio에서 사용하는 용어들에 대해 조금 더 알아보도록 하겠습니다.</p><br><h2 id="동기-연결"><a href="#동기-연결" class="headerlink" title="동기 연결"></a>동기 연결</h2><p>여러분의 프로그램은 적어도 한 개 이상의 (boost::asio::io_context나 boost::asio::thread_pool 또는 boost::asio::system_context 객체와 같은)I/O execution context를 가지고 있을 것입니다. I/O execution context는 OS의 I/O 서비스에 대한 프로그램의 링크를 나타냅니다.</p><blockquote><p><strong>Your program</strong> will have at least one <strong>I/O execution context</strong>, such as an boost::asio::io_context object, boost::asio::thread_pool object, or boost::asio::system_context. This <strong>I/O execution context</strong> represents <strong>your program</strong>‘s link to the <strong>operating system</strong>‘s I/O services.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boost::asio::io_context io_context;</span><br></pre></td></tr></table></figure><br><div class="figure " style="width:;"><img class="fig-img" src="/assets/images/boost-asio-sync-socket.png" alt=""></div><br><ol><li>I/O object(여기서는 socket)에서 connect 호출<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boost::asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">socket.<span class="built_in">connect</span>(server_endpoint);</span><br></pre></td></tr></table></figure></li><li>I/O object는 I/O execution context에게 요청 전달</li><li>I/O execution context는 connect 동작을 수행하기 위해 OS 호출</li><li>OS는 I/O execution context에게 수행 결과를 리턴</li><li>I/O execution context는 boost::system::error_code에 수행 결과 발생한 에러를 해석하고 이를 I/O object에게 다시 전달</li><li>I/O object는 수행에 실패했을 경우 예외를 던짐</li></ol><br><h2 id="비동기-연결"><a href="#비동기-연결" class="headerlink" title="비동기 연결"></a>비동기 연결</h2><div class="figure " style="width:;"><img class="fig-img" src="/assets/images/boost-asio-async-socket.png" alt=""></div><br><ol><li><p>I/O object에서 async_connect 호출(your_completion_handler는 함수 또는 함수 객체임)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">your_completion_handler</span><span class="params">(<span class="keyword">const</span> boost::system::error_code&amp; ec)</span></span>;</span><br><span class="line">socket.<span class="built_in">async_connect</span>(server_endpoint, your_completion_handler);</span><br></pre></td></tr></table></figure></li><li><p>I/O object는 I/O execution context에게 요청 전달</p></li><li><p>I/O execution context는 async_connect 동작을 수행하기 위해 OS 호출(동기 연결과 다르게 async_connect의 수행 결과를 기다리지는 않음)</p></li></ol><div class="figure " style="width:;"><img class="fig-img" src="/assets/images/boost-asio-async-socket-2.png" alt=""></div><ol start="4"><li>OS는 큐에 처리 결과를 추가함으로써 async_connect 수행이 완료됐다는 것을 알림</li><li>I/O execution context로 io_context를 사용하는 경우에는 io_context::run()함수를 반드시 호출해야함. io_context::run()함수는 완료되지 않은 비동기 수행이 있는 경우에는 block 상태이므로 대게 최초 비동기 수행을 시작하자마자 해당 함수를 호출함</li><li>io_context::run()함수 내에서 I/O execution context는 큐에 추가된 수행 결과들을 뽑아내어 error_code에 해석 결과를 저장하고 handler 함수에게 전달함</li></ol><p>동기 및 비동기 소켓 연결에 대한 내용을 바탕으로 io_context의 개념을 정리해보면 다음과 같습니다.  </p><blockquote><p>유저 공간에서 커널에 접근하기 위한 시스템 콜을 날리려고 할때 실제 커널과의 통신을 중계하는 주체이다. 즉, 실제 시스템 콜 함수가 실행되는 공간이라고 생각하면 된다.</p></blockquote><br> <hr><h1 id="Execution-Context"><a href="#Execution-Context" class="headerlink" title="Execution Context"></a>Execution Context</h1><p>io_context는 I/O 작업을 위한 매개체이자 일종의 작업 공간이라는건 어느정도 느낌이 온 것같습니다. 이제는 io_context를 포함하는 개념인 execution context에 대해 조금 더 알아보도록 하겠습니다. (해당 내용은 <a href="https://think-async.com/executors/Executors_and_Asynchronous_Operations_Slides.pdf">Executors and Asynchronous Operations</a>를 참조하여 작성하였습니다.)</p><p>execution context는 <U>함수 객체가 실행되는 공간</U>입니다.</p><blockquote><ul><li>An execution context is <U>a place where function objects are executed.</U></li><li>Examples<ul><li>A fixed-size thread pool</li><li>A loop scheduler</li><li>An asio::io_context</li><li>The set of all threads in the process</li></ul></li></ul></blockquote><p>말그대로 함수 객체(우리가 흔히 핸들러라고 부르는)가 실제로 실행되는 공간이라는 겁니다. 대표적인 execution context인 io_context와 thread pool 사용 예제를 한번 살펴봅시다.</p><br><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  boost::asio::io_context context;</span><br><span class="line">  boost::asio::post(context, [](){ <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello boost::asio::post in context"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; });</span><br><span class="line">  context.run();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><p>위 코드는 boost::asio::post 함수를 사용하여 람다 식으로 정의된 함수 객체를 위에서 정의한 io_context에서 실행시키겠다는 내용입니다. (람다 식은 closure라는 이름없는 함수 객체를 생성해줍니다. <a href="https://en.cppreference.com/w/cpp/language/lambda">람다 식의 정의</a>는 여기를 참고하세요.)  </p><p>아 그리고 post 함수 아래 io_context의 run 함수는 함수 객체를 실행시킬 공간(여기서는 io_context)을 활성화시켜주는 역할을 한다고 생각하시면 될 것같습니다. (run 함수를 실행하지 않고서는 람다 식이 실행되지 않습니다!)</p><br><p>아래 코드는 마찬가지로 boost::asio::post 함수를 사용하여 이번에는 직접 정의한 함수 test_function을 io_context가 아닌 thread_pool(또 다른 execution context들 중 하나죠)에서 실행시키겠다는 내용입니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello boost::asio::post in thread pool"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  boost::asio::thread_pool tp;</span><br><span class="line">  boost::asio::post(tp, test_function);</span><br><span class="line">  tp.join();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><br><hr><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>지금까지 io_context를 시작으로 execution context라는 개념을 조금이나마 구체화하는 시간을 가져봤습니다. 한줄로 정리하며 마치겠습니다.</p><blockquote><p>Execution Context는 함수 또는 함수 객체가 실행되는 공간이다.</p></blockquote><br><br><span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎<p><strong>Reference</strong></p><ul><li><a href="https://www.boost.org/doc/libs/1_78_0/doc/html/boost_asio/overview.html">https://www.boost.org/doc/libs/1_78_0/doc/html/boost_asio/overview.html</a></li><li><a href="https://www.boost.org/doc/libs/1_78_0/doc/html/boost_asio/overview/rationale.html">https://www.boost.org/doc/libs/1_78_0/doc/html/boost_asio/overview/rationale.html</a></li><li><a href="https://www.boost.org/doc/libs/1_78_0/doc/html/boost_asio/overview/core/basics.html">https://www.boost.org/doc/libs/1_78_0/doc/html/boost_asio/overview/core/basics.html</a></li><li><a href="https://think-async.com/executors/Executors_and_Asynchronous_Operations_Slides.pdf">https://think-async.com/executors/Executors_and_Asynchronous_Operations_Slides.pdf</a></li><li><a href="https://en.cppreference.com/w/cpp/language/lambda">https://en.cppreference.com/w/cpp/language/lambda</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://chelseafandev.github.io/categories/C/">C++</category>
      
      
      <category domain="https://chelseafandev.github.io/tags/boost-asio/">boost asio</category>
      
      <category domain="https://chelseafandev.github.io/tags/io-context/">io_context</category>
      
      <category domain="https://chelseafandev.github.io/tags/io-service/">io_service</category>
      
      <category domain="https://chelseafandev.github.io/tags/execution-context/">execution context</category>
      
      
      <comments>https://chelseafandev.github.io/2021/12/28/boost-io-context/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>IP 라우팅 과정에 대해 알아보자</title>
      <link>https://chelseafandev.github.io/2021/12/06/ip-routing-flow/</link>
      <guid>https://chelseafandev.github.io/2021/12/06/ip-routing-flow/</guid>
      <pubDate>Mon, 06 Dec 2021 03:33:13 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;a href=&quot;https://chelseafandev.github.io/2021/12/06/ethernet-switching-flow/&quot;&gt;저번 포스팅&lt;/a&gt;에 이어서 이번에는 L3 스위치에서의 IP 라우팅 과정에 대해 알아보겠습니다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><a href="https://chelseafandev.github.io/2021/12/06/ethernet-switching-flow/">저번 포스팅</a>에 이어서 이번에는 L3 스위치에서의 IP 라우팅 과정에 대해 알아보겠습니다.</p><span id="more"></span><p><a href="https://www.netmanias.com/ko/">넷매니아즈</a>라는 사이트에 총 4편의 시리즈로 연재된 L3 스위치의 패킷 전달에 대한 아주 양질의 게시물을 참고하여 정리해보았으며, 실제 연재글에서는 상세한 그림과 함께 L3 스위치 내부 구조를 좀 더 세분화하여 설명하고 있으니 관심이 있으신분들은 <a href="https://www.netmanias.com/ko/?m=view&id=blog&no=5529">여기</a>를 참조해주시기 바랍니다.</p><br><!-- toc --><p>서버1과 서버4는 서로 다른 VLAN(서버1은 VLAN ID: 10, 서버4는 VLAN ID: 20)에 존재하며, 서버1의 ARP 테이블에는 L3 스위치(여기서는 Gateway)의 엔트리가 이미 존재한다고 가정하겠습니다.<br><br></p><h3 id="서버1에서-서버4로-패킷-전달-ARP-Request-Flooding"><a href="#서버1에서-서버4로-패킷-전달-ARP-Request-Flooding" class="headerlink" title="서버1에서 서버4로 패킷 전달 - ARP Request Flooding"></a>서버1에서 서버4로 패킷 전달 - ARP Request Flooding</h3><div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/ip-routing-arp-request-flooding.png" alt="ARP Request Flooding"><span class="caption">ARP Request Flooding</span></div><ol><li>서버1에서 서버4로 패킷을 보내려고 합니다.</li><li>서버1의 <strong>라우팅 테이블</strong>을 참조(Destination 주소 별 게이트웨이 IP와 출력 포트를 확인할 수 있음)하여 서버4의 IP주소는 디폴트 라우트에 매칭된다는 사실과 Gateway IP주소(여기서는 L3 스위치의 주소임) 및 출력 포트를 확인할 수 있습니다.</li><li>서버1은 <strong>ARP 테이블</strong>을 참조하여 Gateway IP주소에 대한 MAC 주소를 확인합니다.</li><li>출력 포트와 MAC 주소를 확인했으니 서버1은 서버4로 패킷을 송신합니다.</li><li>해당 패킷은 출력 포트를 통해 L3 스위치로 이동합니다.</li><li>패킷을 수신한 L3 스위치는 해당 패킷을 버퍼(Ingress Packet Buffer)에 잠시 저장해둡니다.</li><li>이제 L3 스위치에서 수신한 패킷의 <strong>Source MAC 주소를 학습</strong>할 차례입니다. 동일 VLAN을 소유한 Line Card들에만 Source MAC 주소 정보를 공유하여 각각의 <strong>MAC 테이블</strong>에 그 값(VLAN, Source MAC 주소, 포트)을 저장하도록 합니다.</li><li>다음으로 해당 패킷을 <strong>IP 라우팅</strong>시킬지 <strong>Ethernet 스위칭</strong>시킬것인지를 결정하는데 이를 위해 Destination MAC 주소를 참조합니다.<div class="alert info"><p>Destination MAC 주소가 L3 스위치의 MAC 주소인 경우에는, <strong>IP 라우팅</strong><br>Destination MAC 주소가 L3 스위치의 MAC 주소가 아닌 경우에는, <strong>Ethernet 스위칭</strong></p></div><br></li><li>이 경우에는 해당 패킷의 Destination MAC 주소가 Gateway 즉, L3 스위치의 MAC 주소이므로 IP 라우팅을 시킵니다.</li><li>IP 라우팅을 위해 L3 스위치는 Destination IP 주소에 대한 FIB lookup(LPM: Longest Prefix Match)을 수행하여 해당 패킷이 L3 스위치와 바로 연결되어 있는 목적지인 서버4로 가고자한다는 것을 확인합니다.</li><li>다음으로 L3 스위치는 ARP 테이블을 확인하여 Destination IP 주소에 대한 MAC 주소가 존재하는지 확인합니다.</li><li>만약 존재하지 않는다(ARP Miss!)면 동일한 VLAN에 속한 Line Card들에게 ARP Request 패킷을 Flooding합니다.</li></ol><hr><h3 id="서버1에서-서버4로-패킷-전달-ARP-Reply-수신"><a href="#서버1에서-서버4로-패킷-전달-ARP-Reply-수신" class="headerlink" title="서버1에서 서버4로 패킷 전달 - ARP Reply 수신"></a>서버1에서 서버4로 패킷 전달 - ARP Reply 수신</h3><div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/ip-routing-arp-reply-receiving.png" alt="ARP Reply 수신"><span class="caption">ARP Reply 수신</span></div><ol><li>ARP Request 패킷을 수신한 서버4, 서버5, 서버6중에 해당 IP 주소를 소유한 서버4가 이에 대한 응답으로 ARP Reply를 L3 스위치로 전달합니다.</li><li>ARP Reply 패킷을 수신한 L3 스위치는 해당 패킷을 버퍼(Ingress Packet Buffer)에 잠시 저장해둡니다.</li><li>이제 L3 스위치에서 수신한 패킷의 <strong>Source MAC 주소를 학습</strong>할 차례입니다. 동일 VLAN을 소유한 Line Card들에만 Source MAC 주소 정보를 공유하여 각각의 <strong>MAC 테이블</strong>에 그 값(VLAN, Source MAC 주소, 포트)을 저장하도록 합니다.</li><li>다음으로 해당 패킷을 <strong>IP 라우팅</strong>시킬지 <strong>Ethernet 스위칭</strong>시킬것인지를 결정하는데 이를 위해 Destination MAC 주소를 참조합니다.</li><li>이 경우에는 해당 패킷의 Destination MAC 주소가 L3 스위치의 MAC 주소이므로 IP 라우팅을 시킵니다.</li><li>여기서 만약 해당 패킷의 타입(Ethernet Header에 있는 EtherType)이 ARP 패킷(EtherType = 0x0806)인 경우에는 라우팅 시키지 않고 무조건 Control Module(L3 스위치 내에 존재하는 특정 모듈)이라는 곳으로 올려줍니다.</li><li>ARP Reply 패킷을 수신한 Control Module은 ARP 테이블에 서버4의 IP 주소에 대한 MAC주소를 저장합니다.</li><li>여기까지 완료하면 이제 L3 스위치는 서버1에서 받은 패킷을 서버4로 송신할 수 있습니다.</li></ol><hr><h3 id="서버1에서-서버4로-패킷-전달-IP-라우팅"><a href="#서버1에서-서버4로-패킷-전달-IP-라우팅" class="headerlink" title="서버1에서 서버4로 패킷 전달 - IP 라우팅"></a>서버1에서 서버4로 패킷 전달 - IP 라우팅</h3><div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/ip-routing.png" alt="IP 라우팅"><span class="caption">IP 라우팅</span></div><ol><li>서버1이 목적지 주소가 서버4인 패킷을 L3 스위치로 보냅니다.</li><li>패킷을 수신한 L3 스위치는 해당 패킷을 버퍼(Ingress Packet Buffer)에 잠시 저장해둡니다.</li><li>Source MAC 주소를 학습해볼까 했지만 해당 패킷의 Source MAC 주소는 이미 학습된 서버1의 정보입니다. 그러니 건너뜁니다.</li><li>이제 수신 패킷의 Destination IP 주소로 FIB lookup을해서 OIF(Outgoing Interface)를 확인(여기서는 서버4가 속한 VLAN ID를 확인할 수 있음)합니다.</li><li>그리고 ARP 테이블을 참조하여 Destination IP에 대한 MAC 주소를 확인합니다.</li><li>마지막으로 5번에서 찾은 MAC 주소를 통해 MAC 테이블에서 출력 포트를 확인합니다.</li><li>L3 스위치는 앞서 버퍼에 잠시 저장해둔 패킷(2번 과정을 참고)을 출력을 위한 버퍼(Egress Packet Buffer)로 옮긴 후 6번에서 확인된 MAC주소로 해당 패킷을 송신합니다.</li><li>서버1이 송신한 패킷은 최종적으로 서버4에 도달하게됩니다.</li></ol><hr><h3 id="L3-스위치-동작의-핵심-정리"><a href="#L3-스위치-동작의-핵심-정리" class="headerlink" title="L3 스위치 동작의 핵심 정리"></a>L3 스위치 동작의 핵심 정리</h3><ul><li>L3 스위치는 수신 패킷에 대해 항상 Source MAC 학습부터 수행한다.</li><li>L3 스위치는 수신 패킷의 Destination MAC 주소가 L3 스위치의 MAC 주소이면 IP 라우팅시키고, 그렇지 않은 경우는 Ethernet 스위칭시킨다.</li><li>L3 스위치는 IP 라우팅 과정에서 RIB/FIB에 명시된 OIF(Outgoing Interface)가 물리적 포트가 아닌 VLAN ID 정보가 될 수 있으므로, 실제 패킷을 송신할 출력 포트를 확인하기 위해서는 MAC 테이블을 참조해야한다. 즉,<ol><li><strong>FIB</strong> lookup을 통해 <strong>Next Hop IP와 OIF</strong>를 알아내고</li><li><strong>ARP 테이블</strong> lookup을 통해 Next Hop IP에 대한 <strong>MAC 주소</strong>를 알아내고 (만약 목적지가 L3 스위치와 바로 연결된 경우라면, Destination IP 주소에 대한 MAC 주소를 알아냄)</li><li><strong>MAC 테이블</strong> lookup을 통해 MAC 주소에 대한 <strong>물리적 포트</strong>를 알아낸다 (만약 IP 라우팅 과정에서 MAC 테이블에 해당 엔트리가 존재하지 않으면, VLAN 테이블을 참조하여 OIF에 속한 모든 물리적 포트로 패킷을 Flooding 함)</li></ol></li></ul><br><br><span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎<p><strong>Reference</strong></p><ul><li><a href="https://www.netmanias.com/ko/?m=view&amp;id=blog&amp;no=5529">https://www.netmanias.com/ko/?m=view&amp;id=blog&amp;no=5529</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://chelseafandev.github.io/categories/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/">네트워크</category>
      
      
      <category domain="https://chelseafandev.github.io/tags/L3-%EC%8A%A4%EC%9C%84%EC%B9%98/">L3 스위치</category>
      
      <category domain="https://chelseafandev.github.io/tags/ip-routing/">ip routing</category>
      
      <category domain="https://chelseafandev.github.io/tags/ip-%EB%9D%BC%EC%9A%B0%ED%8C%85/">ip 라우팅</category>
      
      <category domain="https://chelseafandev.github.io/tags/ARP-Request/">ARP Request</category>
      
      <category domain="https://chelseafandev.github.io/tags/ARP-Reply/">ARP Reply</category>
      
      
      <comments>https://chelseafandev.github.io/2021/12/06/ip-routing-flow/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Ethernet 스위칭 과정에 대해 알아보자</title>
      <link>https://chelseafandev.github.io/2021/12/06/ethernet-switching-flow/</link>
      <guid>https://chelseafandev.github.io/2021/12/06/ethernet-switching-flow/</guid>
      <pubDate>Mon, 06 Dec 2021 03:06:07 GMT</pubDate>
      
      <description>&lt;p&gt;이번 포스팅에서는 L3 스위치에서의 Ethernet 스위칭 과정에 대해 알아보겠습니다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>이번 포스팅에서는 L3 스위치에서의 Ethernet 스위칭 과정에 대해 알아보겠습니다.</p><span id="more"></span><p><a href="https://www.netmanias.com/ko/">넷매니아즈</a>라는 사이트에 총 4편의 시리즈로 연재된 L3 스위치의 패킷 전달에 대한 아주 양질의 게시물을 참고하여 정리해보았습니다. 실제 연재글에서는 상세한 그림과 함께 L3 스위치 내부 구조를 좀 더 세분화하여 설명하고 있으니 관심이 있으신분들은 <a href="https://www.netmanias.com/ko/?m=view&id=blog&no=5526">여기</a>를 참조해주시기 바랍니다.</p><br><!-- toc --><p>서버1과 서버3은 현재 동일한 VLAN(VLAN ID: 10)내에 있으며, 서버1의 ARP 테이블에는 서버3의 엔트리가 이미 존재한다고 가정(존재하지 않는 경우에는 ARP Request/Reply 메시지를 통해 ARP 테이블을 채워주어야함)하겠습니다.<br><br></p><h3 id="서버1에서-서버3으로-패킷-전달-Flooding"><a href="#서버1에서-서버3으로-패킷-전달-Flooding" class="headerlink" title="서버1에서 서버3으로 패킷 전달(Flooding)"></a>서버1에서 서버3으로 패킷 전달(Flooding)</h3><div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/ehternet-switching-flooding.png" alt="Flooding"><span class="caption">Flooding</span></div><ol><li>서버1에서 서버3으로 Ping 패킷을 보내려고합니다.</li><li>서버1의 <strong>라우팅 테이블</strong>을 참조(Destination 주소 별 게이트웨이 IP와 출력 포트를 확인할 수 있음)하여 서버3이 서버1과 동일한 네트워크라는 것과 패킷을 내보낼 출력 포트를 확인합니다.</li><li>서버1의 <strong>ARP 테이블</strong>을 참조하여 서버3의 IP주소에 대한 MAC 주소를 확인합니다.</li><li>출력 포트와 MAC 주소를 확인했으니 서버1은 서버3으로 Ping 패킷을 송신합니다.</li><li>Ping 패킷은 출력 포트를 통해 L3 스위치로 이동합니다.</li><li>Ping 패킷을 수신한 L3 스위치는 해당 패킷을 버퍼(Ingress Packet Buffer)에 잠시 저장해둡니다.</li><li>이제 L3 스위치에서 수신한 Ping 패킷의 <strong>Source MAC 주소를 학습</strong>할 차례입니다. 동일 VLAN을 소유한 Line Card들에만 Source MAC 주소 정보를 공유하여 각각의 <strong>MAC 테이블</strong>에 그 값(VLAN, Source MAC 주소, 포트)을 저장하도록 합니다.</li><li>다음으로 해당 패킷을 <strong>IP 라우팅</strong>시킬지 <strong>Ethernet 스위칭</strong>시킬것인지를 결정하는데 이를 위해 Destination MAC 주소를 참조합니다.<div class="alert info"><p>Destination MAC 주소가 L3 스위치의 MAC 주소인 경우에는, <strong>IP 라우팅</strong><br>Destination MAC 주소가 L3 스위치의 MAC 주소가 아닌 경우에는, <strong>Ethernet 스위칭</strong></p></div><br></li><li>이 경우에는 해당 패킷의 Destination MAC 주소가 서버3의 MAC 주소이므로 Ethernet 스위칭을 시킵니다.</li><li>Ethernet 스위칭을 위해 L3 스위치에서는 해당 패킷의 Destination MAC 주소가 MAC 테이블에 존재하는지 확인합니다.</li><li>만약 등록되어 있지 않다면 동일 VLAN에 속한 포트들 중에서 수신 포트(서버1의 포트)를 제외한 나머지 모든 포트(여기서는 서버2와 서버3의 포트라고 가정)로 수신한 Ping 패킷을 <strong>Flooding</strong>해야함을 알게됩니다.</li><li>L3 스위치는 앞서 버퍼에 잠시 저장해둔 패킷(6번 과정을 참고)을 출력을 위한 버퍼(Egress Packet Buffer)로 옮긴 후 11번에서 확인된 포트들로 해당 패킷을 Flooding합니다.</li><li>이제 서버2와 서버3이 서버1이 보낸 Ping 패킷을 수신하게 됩니다.</li></ol><hr><h3 id="서버3에서-서버1로-패킷-전달-Unicasting"><a href="#서버3에서-서버1로-패킷-전달-Unicasting" class="headerlink" title="서버3에서 서버1로 패킷 전달(Unicasting)"></a>서버3에서 서버1로 패킷 전달(Unicasting)</h3><div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/ehternet-switching-unicasting.png" alt="Unicasting"><span class="caption">Unicasting</span></div><ol><li>Ping 패킷의 Destination MAC 주소는 서버3의 MAC 주소이기때문에 서버2에서는 수신한 Ping 패킷을 버립니다.</li><li>서버3은 수신한 Ping 패킷에 대한 응답 패킷을 서버1로 송신합니다.(서버1에서와 마찬가지로 서버3은 자신의 라우팅 테이블과 ARP 테이블을 참조하여 출력 포트와 서버1의 MAC주소를 확인함)</li><li>응답 패킷은 출력 포트를 통해 L3 스위치로 이동합니다.</li><li>응답 패킷을 수신한 L3 스위치는 해당 패킷을 버퍼(Ingress Packet Buffer)에 잠시 저장해둡니다.</li><li>이제 L3 스위치에서 수신한 응답 패킷의 <strong>Source MAC 주소를 학습</strong>할 차례입니다. 동일 VLAN을 소유한 Line Card들에만 Source MAC 주소 정보를 공유하여 각각의 <strong>MAC 테이블</strong>에 그 값(VLAN, Source MAC 주소, 포트)을 저장하도록 합니다.</li><li>다음으로 해당 패킷을 <strong>IP 라우팅</strong>시킬지 <strong>Ethernet 스위칭</strong>시킬것인지를 결정하는데 이를 위해 Destination MAC 주소를 참조합니다.</li><li>이 경우에는 해당 패킷의 Destination MAC 주소가 서버1의 MAC 주소이므로 Ethernet 스위칭을 시킵니다.</li><li>Ethernet 스위칭을 위해 L3 스위치에서는 해당 패킷의 Destination MAC 주소가 MAC 테이블에 존재하는지 확인합니다. 이번에는 존재(이전의 Source MAC 주소 학습을 통해 서버1의 MAC 주소가 저장된 상태이므로)합니다.</li><li>L3 스위치는 앞서 버퍼에 잠시 저장해둔 패킷(4번 과정을 참고)을 출력을 위한 버퍼(Egress Packet Buffer)로 옮긴 후 8번에서 확인된 MAC주소로 해당 패킷을 송신합니다. 이렇게 MAC 테이블에 매칭되어 하나의 포트로 패킷이 나가는 경우를 Unicasting이라고 합니다.</li></ol><br><br><span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎<p><strong>Reference</strong></p><ul><li><a href="https://www.netmanias.com/ko/?m=view&amp;id=blog&amp;no=5526">https://www.netmanias.com/ko/?m=view&amp;id=blog&amp;no=5526</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://chelseafandev.github.io/categories/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/">네트워크</category>
      
      
      <category domain="https://chelseafandev.github.io/tags/ethernet-switching/">ethernet switching</category>
      
      <category domain="https://chelseafandev.github.io/tags/%EC%9D%B4%EB%8D%94%EB%84%B7-%EC%8A%A4%EC%9C%84%EC%B9%98/">이더넷 스위치</category>
      
      <category domain="https://chelseafandev.github.io/tags/Source-MAC-Learning/">Source MAC Learning</category>
      
      <category domain="https://chelseafandev.github.io/tags/ARP-Table/">ARP Table</category>
      
      <category domain="https://chelseafandev.github.io/tags/L3-%EC%8A%A4%EC%9C%84%EC%B9%98/">L3 스위치</category>
      
      
      <comments>https://chelseafandev.github.io/2021/12/06/ethernet-switching-flow/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Seg Fault는 왜 발생하는가?</title>
      <link>https://chelseafandev.github.io/2021/11/09/gdb-chapter4-program-crash/</link>
      <guid>https://chelseafandev.github.io/2021/11/09/gdb-chapter4-program-crash/</guid>
      <pubDate>Tue, 09 Nov 2021 07:59:54 GMT</pubDate>
      
      <description>&lt;p&gt;이번 포스팅에서는 &lt;a href=&quot;https://nostarch.com/debugging.htm&quot;&gt;The Art of Debugging with GDB, DDD and Eclipse&lt;/a&gt;의 &lt;strong&gt;Chatper 4 WHEN A PROGRAM CRASHES&lt;/strong&gt; 내용을 번역해보았습니다. 해당 챕터의 앞부분에서는 가상 주소 공간에서의 페이지(page)에 대한 개념을 소개하고 seg fault가 발생하는 원인을 페이지(page)와 연관지어 잘 설명해주고 있습니다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>이번 포스팅에서는 <a href="https://nostarch.com/debugging.htm">The Art of Debugging with GDB, DDD and Eclipse</a>의 <strong>Chatper 4 WHEN A PROGRAM CRASHES</strong> 내용을 번역해보았습니다. 해당 챕터의 앞부분에서는 가상 주소 공간에서의 페이지(page)에 대한 개념을 소개하고 seg fault가 발생하는 원인을 페이지(page)와 연관지어 잘 설명해주고 있습니다.</p><span id="more"></span><br><!-- toc --><br><h2 id="Background-Material-Memory-Management"><a href="#Background-Material-Memory-Management" class="headerlink" title="Background Material: Memory Management"></a>Background Material: Memory Management</h2><h3 id="Why-does-a-program-crash"><a href="#Why-does-a-program-crash" class="headerlink" title="Why does a program crash?"></a>Why does a program crash?</h3><p>단연코 충돌이 발생하는 가장 일반적인 원인은 프로그램이 접근 권한이 없는 메모리 공간에 접근하려고 시도하기 때문입니다.</p><blockquote><p>By far the most common cause of a crash is for a program to attempt to access a memory location without having the permission to do so.</p></blockquote><br><p>Unix 계열의 플랫폼에서는 일반적으로 프로그램이 segmentation fault(seg fault로 알려져있는)를 발생시켰다는 것을 알려주고 해당 프로그램의 실행을 중단할 것입니다.</p><blockquote><p>On Unix-family platforms, the OS will normally announce that the program has caused a segmentation fault, commonly referred to as a seg fault, and discontinue execution of the program.</p></blockquote><br><p>seg fault를 처리하기 위한 용도로 GDB를 효율적으로 사용하기 위해서는, 메모리 접근 에러가 어떻게 발생하는지에 대해 정확히 이해하는 것이 중요합니다.</p><blockquote><p>In order to effectively use GDB to deal with seg faults, it is important to understand exactly how memory access errors occur.</p></blockquote><br><h3 id="Program-layout-in-memory"><a href="#Program-layout-in-memory" class="headerlink" title="Program layout in memory"></a>Program layout in memory</h3><p>Unix 플랫폼에서 프로그램에 할당된 가상 주소들의 집합은 Figure 4-1 그림과 같은 형태로 배치되어있습니다.</p><blockquote><p>On Unix platforms, a program’s set of allocated virtual addresses typically is laid out something like the diagram in Figure 4-1.</p></blockquote><div class="figure " style="width:;"><img class="fig-img" src="/assets/images/figure-4-1-program-memory-layout.png" alt=""></div><br><p><strong>text section</strong>은 컴파일러가 당신의 프로그램 소스 코드를 통해 생성해낸 기계 지시어들로 구성되어있습니다.</p><blockquote><p>The <strong>text section</strong> consists of the machine instructions produced by the compiler from your program’s source code.</p></blockquote><br><p><strong>data section</strong>은 컴파일 타임에 할당되는 모든 프로그램 변수들을 포함합니다. (초기화된 변수는 data영역에 초기화되지않은 변수는 bss영역에 저장됨)</p><blockquote><p>The <strong>data section</strong> contains all the program variables that are allocated at compile time. </p></blockquote><br><p>당신의 프로그램이 런타임에 OS로부터 추가적인 메모리를 요청하는 경우에 해당 메모리는 <strong>heap</strong>이라는 공간에 할당됩니다.</p><blockquote><p>When your program requests additional memory from the operating system at run time the requested memory is allocated in an area called the <strong>heap</strong>.</p></blockquote><br><p><strong>stack section</strong>은 동적으로 할당된 데이터를 위한 공간입니다. 함수 호출 시 사용되는 인자들이나 지역 변수들 그리고 반환 주소값들이 stack 공간에 저장됩니다. stack의 크기는 함수 호출이 발생할 때 증가하고 호출자에게 함수가 다시 반환될때 감소합니다.</p><blockquote><p>The <strong>stack section</strong> is space for dynamically allocated data. The data for function calls — including arguments, local variables, and return addresses — are stored on the stack. The stack grows each time a function call is made and shrinks each time a function returns to its caller.</p></blockquote><br><h3 id="The-notion-of-pages"><a href="#The-notion-of-pages" class="headerlink" title="The notion of pages"></a>The notion of pages</h3><p>가상 주소 공간은 <strong>페이지</strong>라고 불리는 덩어리(chunk)들의 구성으로 표현됩니다. RAM이나 ROM과 같은 물리적 메모리 또한 페이지들로 나누어진 무언가로 표현됩니다.</p><blockquote><p>A virtual address space is viewed as organized into chunks called <strong>pages</strong>. Physical memory (both RAM and ROM) is also viewed as divided into pages.</p></blockquote><br><p>실행에 의해 프로그램이 메모리에 로드될 때, OS는 프로그램의 몇몇 페이지들을 물리적 메모리의 페이지에 저장되도록 배열시킵니다. 이러한 페이지들을 <strong>resident</strong>라고 부르며 resident를 제외한 나머지 페이지들은 디스크에 저장됩니다.</p><blockquote><p>When a program is loaded into memory for execution, the OS arranges for some of the pages of the program to be stored in pages of physical memory. These pages are said to be <strong>resident</strong>, and the rest are stored on disk.</p></blockquote><br><p>지금 현재는 resident(물리적 메모리의 페이지에 저장된 프로그램의 페이지)가 아닌 몇몇 프로그램 페이지들이 프로그램이 실행 중인 동안의 다양한 시점에 필요할 수 있습니다. 이러한 시점에 그것은 하드웨어에 의해 감지되고 이를 통해 당신의 프로그램은 제어권을 OS로 넘겨주게 됩니다. OS는 필요한 프로그램의 페이지를 메모리로 로딩하고나서 제어권 다시 프로그램에게 넘겨줍니다. 이 과정에서 더이상 resident가 아닌 프로그램 페이지(= nonresident)는 디스크에 저장될 것입니다.</p><blockquote><p>At various times during execution, some program page that is not currently resident will be needed. When this occurs, it will be sensed by the hardware, which transfers control to the OS. The latter brings the required page into memory and then returns control to our program. The evicted program page, if any, becomes nonresident and will be stored on disk.</p></blockquote><br><p>위의 모든 과정을 관리하기 위해서 OS는 각각의 프로세스마다 <strong>페이지 테이블</strong>이라는 것을 유지하게 됩니다. 프로세스의 가상 페이지들 각각은 테이블 내에 entry를 가지고 있으며 이 entry에는 아래 정보들을 포함하고 있습니다.</p><blockquote><p>To manage all of this, the OS maintains a <strong>page table</strong> for each process. Each of the process’s virtual pages has an entry in the table, which includes the following information:</p></blockquote><br><ul><li>페이지의 메모리 혹은 디스크 상의 현재 물리적 위치 정보</li><li>페이지의 read, write, execute 권한 정보</li></ul><blockquote><ul><li>The current physical location of this page in memory or on disk.</li><li>Permissions — read, write, execute — for this page.</li></ul></blockquote><br><p>OS가 부분적인 페이지들을 프로그램에 할당하는 것이 아니라는 것에 주목합시다. 예를 들어, 실행 중인 프로그램이 약 10,000 bytes의 사이즈를 갖는다고 한다면, 이 프로그램이 온전히 로드됐을 경우 메모리의 3개 페이지를 차지(페이지 기본 사이즈가 4,096 bytes인 경우)할 것입니다. 페이지는 VM 시스템에 의해 조작되는 메모리의 가장 작은 단위이기 때문에 약 2.5 페이지를 차지한다거나 하지는 않을것입니다. 바로 이 지점이 디버깅 시에 매우 중요한 포인트입니다. 왜냐하면 이것은 프로그램에 의해 발생하는 몇몇 잘못된 메모리 접근들이 seg fault를 발생시키지 않을 수 있음을 의미하기 때문입니다. </p><blockquote><p>Note that the OS will not allocate partial pages to a program. For example, if the program to be run has a total size of about 10,000 bytes, it would occupy three pages of memory if fully loaded. It would not merely occupy about 2.5 pages, as pages are the smallest unit of memory manipulated by the VM system. This is an important point to understand when debugging, because it implies that some erroneous memory accesses by the program will not trigger seg faults, as you will see below.</p></blockquote><br><p>다시 말해, 디버깅 세션에 있는 동안에 당신은 “소스 코드의 이 라인은 seg fault를 발생시키지 않았기 때문에 틀림없이 괜찮을 것이다”와 같이 이야기 할 수 없다는 것입니다.</p><blockquote><p>In other words, during your debugging session, you cannot say something like, “This line of source code must be okay, since it didn’t cause a seg fault.”</p></blockquote><br><h3 id="Details-on-the-role-of-the-page-table"><a href="#Details-on-the-role-of-the-page-table" class="headerlink" title="Details on the role of the page table"></a>Details on the role of the page table</h3><div class="alert info"><p>아래 설명에 나오는 페이지의 크기는 4,096 bytes 라고 가정하자</p><p>virtual page 0 : 0 ~ 4,095 bytes<br>virtual page 1 : 4,096 ~ 8,191 bytes<br>…</p><p>Keep the virtual address space in Table 4-1 in mind, and continue to assume that the page size is 4,096 bytes. Then virtual page 0 comprises bytes 0 though 4,095 of the virtual address space, page 1 comprises bytes 4,096 through 8,191, and so on.</p></div><br><p>위에서 언급했듯이, 우리가 프로그램을 실행시킬때, OS는 프로그램 코드를 실행시키는 프로세스의 가상 메모리를 관리하기 위해 사용하는 페이지 테이블을 생성합니다. 프로세스가 실행 중이라면 언제든지, 하드웨어의 page table register는 페이지 테이블을 가리키고 있을겁니다.</p><blockquote><p>As mentioned, when we run a program, the OS creates a page table that it uses to manage the virtual memory of the process that executes the program code. Whenever that process runs, the hardware’s page table register will point to that table.</p></blockquote><br><p>개념적으로 이야기하자면, 프로세스 가상 주소 공간의 각각의 페이지는 페이지 테이블 안의 entry를 갖고 있습니다. 이 페이지 테이블 entry는 페이지와 관련된 다양한 정보들을 저장하고 있습니다. 이러한 정보들 중에서 seg faults와 관련된 데이터는 페이지에 대한 접근 권한입니다. 이는 read, write, execute와 같은 파일 접근 권한과 유사합니다. 예를 들어 페이지 3번에 대한 페이지 테이블 entry는 여러분의 프로세스가 그 페이지로부터 데이터를 읽을 권한이 있는지, 그 페이지에 데이터를 쓸 권한이 있는지, 그 페이지에 지시어를 실행할 권한이 있는지 가리킬 것입니다.</p><blockquote><p>Conceptually speaking, each page of the virtual address space of the process has an entry in the page table. This page table entry stores various pieces of information related to the page. The data of interest in relation to seg faults are the access permissions for the page, which are similar to file access permissions: read, write, and execute. For example, the page table entry for page 3 will indicate whether your process has the right to read data from that page, the right to write data to it, and the right to execute instructions on it.</p></blockquote><br><p>프로그램의 실행 과정에서, 프로그램의 실행에 의해 생성되는 주소들은 가상의 값일 것입니다. 프로그램이 y라고하는 특정한 가상 주소를 갖는 메모리에 접근하려고 할때, 하드웨어는 이 가상 주소 y를 가상 페이지 번호 v로 변환할 것입니다. 여기서 가상 페이지 번호인 v는 가상 주소 y를 4,096으로 나눈 것과 같습니다. 그리고나서 하드웨어는 페이지 테이블내에서 entry값인 v가 수행하고자 하는 연산과 일치하는 권한을 가지고있는지 여부를 확인할 것입니다. 만약 일치한다면, 하드웨어는 이 테이블 entry로부터 실제 물리적 메모리 공간의 페이지 번호를 얻어낼 것이며 요청된 메모리 연산을 수행할 것입니다. 하지만 만약 테이블 entry가 요청한 연산에 대한 적절한 권한이 없을때에는 내부적인 인터럽트를 실행할 것입니다. 이 인터럽트는 OS의 에러 핸들링 루틴으로 jump하도록 해줍니다. OS는 일반적으로 메모리 접근 위반을 알려주고 프로그램의 실행을 중단시킵니다.</p><blockquote><p>During the execution of the program, the addresses it generates will be virtual. When the program attempts to access memory at a certain virtual address, say y, the hardware will convert that to a virtual page number v, which equals y divided by 4,096. The hardware will then check entry v in the page table to see whether the permissions for the page match the operation to be performed. If they do match, the hardware will get the desired location’s actual physical page number from this table entry and then carry out the requested memory operation. But if the table entry shows that the requested operation does not have the proper permission, the hardware will execute an internal interrupt. This will cause a jump to the OS’s error-handling routine. The OS will normally then announce a memory access violation and discontinue execution of the program.</p></blockquote><br><h3 id="A-slight-memory-access-bug-might-not-cause-a-seg-fault"><a href="#A-slight-memory-access-bug-might-not-cause-a-seg-fault" class="headerlink" title="A slight memory-access bug might not cause a seg fault"></a>A slight memory-access bug might not cause a seg fault</h3><figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> q[<span class="number">200</span>];</span><br><span class="line">main()</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) {</span><br><span class="line">    q[i] = i;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><br><p>거의 대부분의 경우 실행 시간에 seg fault가 발생할 것입니다. 하지만 에러가 발생하는 시점이 당신을 놀라게 할 것입니다. 에러는 자연스러운 시점에 발생하지 않을 가능성이 있는데, 다시 말해, i가 200인 경우가 아닌 그 이후 시점에 발생할 수 있다는 것입니다.</p><blockquote><p>At execution time, a seg fault is quite likely to occur. However, the timing of the error may surprise you. The error is not likely to appear at the “natural” time, that is, when i = 200; rather, it is likely to happen much later than that. </p></blockquote><br><p>이 현상을 재현하기 위해 우리는 이 프로그램을 변수의 주소를 검색하기에 편리한 GDB를 통해 실행시켰습니다. 이를 통해 seg fault는 i가 200이 아닌 728(테스트 환경에 따라 i의 값은 달라질 수 있음)에서 발생했다는 것을 확인할 수 있었습니다. 왜 이러한 현상이 발생하는지 살펴봅시다.</p><blockquote><p>To illustrate this, we ran this program on a Linux PC under GDB, in order to conveniently query addresses of variables. It turned out that the seg fault occurred not at i = 200, but at i = 728. Let’s see why.</p></blockquote><br><p>GDB에 질의 결과, 우리는 배열 q(q[])의 주소값이 0x80497bf로 끝난다는 것을 확인했습니다. 즉, q[199]의 마지막 byte가 해당 메모리 주소에 존재한다는 것입니다. 페이지 크기는 4,096 byte에 32-bit의 word 크기를 갖는 장치라고 고려해본다면, 가상 주소 공간은 20-bit의 페이지 번호와 12-bit의 오프셋으로 나누어집니다. 우리 프로그램의 경우, 배열 q[]는 가상 페이지 번호 0x8049 = 32841, 오프셋 값 0x7bf = 1983이 됩니다. 그래서 q가 할당된 메모리의 페이지 위에 여전히 2,112 byte의 공간이 남아있게 됩니다. 이 공간은 integer 변수 528개를 저장할 수 있으며, 우리 프로그램은 그것을 마치 q의 요소들이 포함된 공간으로 처리하게 됩니다(q[200] ~ q[727]).</p><blockquote><p>From queries to GDB we found that the array q[] ended at address 0x80497bf; that is, the last byte of q[199] was at that memory location. Taking into account the Intel page size of 4,096 bytes and the 32-bit word size of this machine, a virtual address breaks down into a 20-bit page number and a 12-bit offset. In our case, q[] ended in virtual page number 0x8049 = 32841, offset 0x7bf = 1983. So there were still 4,096 − 1,984 = 2,112 bytes on the page of memory on which q was allocated. That space can hold 2112 / 4 = 528 integer variables (since each is 4 bytes wide on the machine used here), and our code treated it as if it contained elements of q at “positions” 200 through 727.</p></blockquote><br><p>물론 q[] 배열의 이러한 요소(q[200] ~ q[727])들은 실제로 존재하지 않지만, 컴파일러는 불만을 제기하지 않습니다. 여전히 해당 페이지는 쓰기 권한을 가지고 있기 떄문에 하드웨어 또한 불만을 제기하지 않습니다. 오로지 i가 728이 되는 시점에 q[i]는 다른 페이지를 가리키게 됩니다. 바로 이 경우에, 해당 페이지에는 쓰기 권한이 없게되고 가상 메모리 하드웨어는 이를 감지하여 seg fault를 발생시킵니다.</p><blockquote><p>Those elements of q[] don’t exist, of course, but the compiler did not complain. Neither did the hardware, since the writes were still being performed to a page for which we certainly had write permission. Only when i became 728 did q[i] refer to an address on a different page. In this case, it was a page for which we didn’t have write (or any other) permission; the virtual memory hardware detected this and triggered a seg fault.</p></blockquote><br><span class="highlight-text green">교훈: 이전에 언급했듯이, seg fault가 발생하지 않았다는 것이 메모리 연산에 오류가 없다는 것은 아닙니다.</span><blockquote><p>The moral: As stated earlier, we can’t conclude from the absence of a seg fault that a memory operation is correct.</p></blockquote><br><br><span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎<p><strong>Reference</strong></p><ul><li>Norman Matloff, Peter Jay Salzman. (2008). The Art of Debugging with GDB, DDD, and Eclipse. No Starch Press</li><li><a href="https://nostarch.com/debugging.htm">https://nostarch.com/debugging.htm</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://chelseafandev.github.io/categories/%EA%B8%B0%EC%88%A0%EB%AC%B8%EC%84%9C-%EB%B2%88%EC%97%AD/">기술문서 번역</category>
      
      
      <category domain="https://chelseafandev.github.io/tags/gdb/">gdb</category>
      
      <category domain="https://chelseafandev.github.io/tags/coredump/">coredump</category>
      
      <category domain="https://chelseafandev.github.io/tags/gdb-debugging/">gdb debugging</category>
      
      <category domain="https://chelseafandev.github.io/tags/page/">page</category>
      
      <category domain="https://chelseafandev.github.io/tags/page-table/">page table</category>
      
      <category domain="https://chelseafandev.github.io/tags/seg-fault/">seg fault</category>
      
      <category domain="https://chelseafandev.github.io/tags/segmentation-fault/">segmentation fault</category>
      
      
      <comments>https://chelseafandev.github.io/2021/11/09/gdb-chapter4-program-crash/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>인텔 Hyperscan API 테스트 코드 작성</title>
      <link>https://chelseafandev.github.io/2021/10/12/hyperscan-phase2/</link>
      <guid>https://chelseafandev.github.io/2021/10/12/hyperscan-phase2/</guid>
      <pubDate>Tue, 12 Oct 2021 12:20:27 GMT</pubDate>
      
      <description>&lt;p&gt;이번 포스팅에서는 &lt;a href=&quot;https://chelseafandev.github.io/2021/09/24/hyperscan-phase1/&quot;&gt;인텔 Hyperscan 레퍼런스 가이드 번역&lt;/a&gt;에 이어서 Hyperscan API를 직접 사용하여 정규 표현식 패턴 매칭을 수행하는 샘플 코드를 작성하고 테스트 해보는 시간을 갖겠습니다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>이번 포스팅에서는 <a href="https://chelseafandev.github.io/2021/09/24/hyperscan-phase1/">인텔 Hyperscan 레퍼런스 가이드 번역</a>에 이어서 Hyperscan API를 직접 사용하여 정규 표현식 패턴 매칭을 수행하는 샘플 코드를 작성하고 테스트 해보는 시간을 갖겠습니다.</p><span id="more"></span><p>해당 포스팅의 Hyperscan 설치 및 테스트 환경은 <span class="highlight-text yellow">Ubuntu 18.04.5 LTS 기준</span>입니다. 다른 OS에서 Hyperscan 테스트 코드를 작성하고자 하시는 분들은 <a href="http://intel.github.io/hyperscan/dev-reference/getting_started.html#requirements">Hyperscan 공식 홈페이지에 명시된 요구사항 정보</a>를 확인해주시기 바랍니다. </p><br><!-- toc --><br><p>아래 그림은 Hyperscan 라이브러리를 컴파일하기 위해 미리 설치되어야할 소프트웨어 목록과 최소 버전 정보입니다. Pcap은 hyperscan에서 제공하는 샘플 코드를 사용하지 않을거라면 굳이 설치할 필요는 없기때문에 제외하도록 하겠습니다. (설치 과정에서 발생하는 오류 댓글로 남겨주시면 피드백드리겠습니다😁)</p><div class="figure center" style="width:;"><img class="fig-img" src="/assets/images/hyperscan_dependency.png" alt=""></div><br><h3 id="CMake-설치"><a href="#CMake-설치" class="headerlink" title="CMake 설치"></a>CMake 설치</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install cmake</span><br></pre></td></tr></table></figure><br><h3 id="Ragel-설치"><a href="#Ragel-설치" class="headerlink" title="Ragel 설치"></a>Ragel 설치</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install ragel</span><br></pre></td></tr></table></figure><br><h3 id="Python-설치"><a href="#Python-설치" class="headerlink" title="Python 설치"></a>Python 설치</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install python</span><br></pre></td></tr></table></figure><br><h3 id="Boost-설치"><a href="#Boost-설치" class="headerlink" title="Boost 설치"></a>Boost 설치</h3><p><a href="https://www.boost.org/doc/libs/1_77_0/more/getting_started/unix-variants.html">Boost 공식 홈페이지</a>를 참조하여 최신 버전(21.10.11 기준 1.77.0) 설치를 수행합니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://boostorg.jfrog.io/artifactory/main/release/1.77.0/source/boost_1_77_0.tar.bz2</span><br><span class="line">$ tar xvf boost_1_77_0.tar.bz2</span><br><span class="line">$ cd boost_1_77_0</span><br><span class="line">$ sudo ./bootstrap.sh</span><br><span class="line">$ sudo ./b2 install</span><br></pre></td></tr></table></figure><br><h3 id="Hyperscan-소스-빌드"><a href="#Hyperscan-소스-빌드" class="headerlink" title="Hyperscan 소스 빌드"></a>Hyperscan 소스 빌드</h3><p><a href="https://github.com/intel/hyperscan">해당 링크</a>에서 Hyperscan 최신 소스 코드(21.10.11 기준 5.4.0)를 다운로드 받으실 수 있습니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ tar xvf v5.4.0.tar.gz</span><br><span class="line">$ cd hyperscan-5.4.0</span><br><span class="line">$ mkdir build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake -DBUILD_STATIC_AND_SHARED=1 ../</span><br><span class="line">$ sudo make</span><br><span class="line">$ sudo make install</span><br><span class="line">ln -s /usr/local/include/boost &lt;hyperscan-source-path&gt;/include/boost</span><br></pre></td></tr></table></figure><br><h3 id="테스트코드-작성"><a href="#테스트코드-작성" class="headerlink" title="테스트코드 작성"></a>테스트코드 작성</h3><p>테스트코드에 대한 설명은 코드 내 주석으로 대신하겠습니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><span>Hyperscan API test code</span><ul class="tabs"><li class="tab active">cpp</li></ul></figcaption><div class="tabs-content"><figure class="highlight cpp" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HyperscanTest</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">HyperscanTest()</span><br><span class="line">{</span><br><span class="line">db_ = <span class="literal">nullptr</span>;</span><br><span class="line">scratch_ = <span class="literal">nullptr</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">~HyperscanTest()</span><br><span class="line">{</span><br><span class="line">hs_free_scratch(scratch_);</span><br><span class="line">hs_free_database(db_);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 정규표현식 샘플 패턴이 저장된 파일을 Hyperscan Pattern DB를 컴파일하기 위한 형태로 파싱해주는 함수입니다.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 파싱하는 파일의 구조는 &lt;id&gt;:/&lt;pattern&gt;/&lt;flags&gt; 형태이며, </span></span><br><span class="line"><span class="comment">// id/pattern/flags를 각각 멤버 변수인 ids_, patterns_, flags_에 저장합니다.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">parseFile</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;filename)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="function"><span class="built_in">std</span>::ifstream <span class="title">inFile</span><span class="params">(filename, <span class="built_in">std</span>::ifstream::in)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!inFile.good())</span><br><span class="line">{</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR: unable to open file \""</span> &lt;&lt; filename &lt;&lt; <span class="string">"\""</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; !inFile.eof(); i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> line;</span><br><span class="line">getline(inFile, line);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (line.empty() || line[<span class="number">0</span>] == <span class="string">'#'</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> colonIdx = line.find_first_of(<span class="string">':'</span>);</span><br><span class="line"><span class="keyword">if</span> (colonIdx == <span class="built_in">std</span>::<span class="built_in">string</span>::npos)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR: Could not parse line "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">inFile.close();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> id = <span class="built_in">std</span>::stoi(line.substr(<span class="number">0</span>, colonIdx).c_str());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">expr</span><span class="params">(line.substr(colonIdx + <span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> flagsStart = expr.find_last_of(<span class="string">'/'</span>);</span><br><span class="line"><span class="keyword">if</span> (flagsStart == <span class="built_in">std</span>::<span class="built_in">string</span>::npos)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR: no trailing '/' char"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">inFile.close();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">pcre</span><span class="params">(expr.substr(<span class="number">1</span>, flagsStart - <span class="number">1</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">flagsStr</span><span class="params">(expr.substr(flagsStart + <span class="number">1</span>, expr.size() - flagsStart))</span></span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> flag = parseFlags(flagsStr);</span><br><span class="line"></span><br><span class="line">patterns_.push_back(pcre);</span><br><span class="line">flags_.push_back(flag);</span><br><span class="line">ids_.push_back(id);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">inFile.close();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 파싱된 데이터들을 활용하여 Hyperscan에서 사용하는 Pattern DB를 컴파일하는 함수입니다.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compileDatabase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">hs_database_t</span> *db = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">hs_compile_error_t</span> *compileErr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; cstrPatterns;</span><br><span class="line">cstrPatterns.reserve(patterns_.size());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;pattern : patterns_)</span><br><span class="line">{</span><br><span class="line">cstrPatterns.push_back(pattern.c_str());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">hs_error_t</span> err_compile = hs_compile_multi(cstrPatterns.data(), flags_.data(), ids_.data(), cstrPatterns.size(), HS_MODE_BLOCK, <span class="literal">nullptr</span>, &amp;db, &amp;compileErr);</span><br><span class="line"><span class="keyword">if</span> (err_compile != HS_SUCCESS)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (compileErr-&gt;expression &lt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR: "</span> &lt;&lt; compileErr-&gt;message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">hs_free_compile_error(compileErr);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR: Pattern '"</span> &lt;&lt; patterns_[compileErr-&gt;expression] &lt;&lt; <span class="string">"' failed with error '"</span> &lt;&lt; compileErr-&gt;message &lt;&lt; <span class="string">"'"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">hs_free_compile_error(compileErr);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (db_ != <span class="literal">nullptr</span>)</span><br><span class="line">hs_free_database(db_);</span><br><span class="line"></span><br><span class="line">db_ = db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">hs_error_t</span> err_scratch = hs_alloc_scratch(db_, &amp;scratch_);</span><br><span class="line"><span class="keyword">if</span> (err_scratch != HS_SUCCESS)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR: hs_alloc_scratch failed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인자로 전달된 패턴 정보가 Hyperscan Pattern DB에 존재하는지 여부를 반환하는 함수입니다.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">scanPattern</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> pattern)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> match_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 매칭되는 패턴이 Hyperscan Pattern DB에 존재한다면 hs_scan 함수의 6번째 인자로 등록되는 </span></span><br><span class="line"><span class="comment">// 콜백 함수(해당 코드에서는 람다 함수로 구현)를 통해 결과를 확인할 수 있으며,</span></span><br><span class="line"><span class="comment">// 5번째 인자인 ctx를 통해 hs_scan 외부의 변수에 콜백 함수의 결과를 저장할 수도 있습니다.</span></span><br><span class="line"><span class="keyword">if</span> (hs_scan(</span><br><span class="line">db_,</span><br><span class="line">pattern.c_str(),</span><br><span class="line">pattern.length(),</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">scratch_,</span><br><span class="line">[](<span class="keyword">unsigned</span> <span class="keyword">int</span> id, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> from, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> to, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">void</span> *ctx) -&gt; <span class="keyword">int</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">size_t</span> *matches = (<span class="keyword">size_t</span> *)ctx;</span><br><span class="line">(*matches)++;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"id: "</span> &lt;&lt; id &lt;&lt; <span class="string">" from: "</span> &lt;&lt; from &lt;&lt; <span class="string">" to: "</span> &lt;&lt; to &lt;&lt; <span class="string">" flags: "</span> &lt;&lt; flags &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">},</span><br><span class="line">&amp;match_count) != HS_SUCCESS)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hs_scan failed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"match count: "</span> &lt;&lt; match_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">hs_database_t</span> *db_;</span><br><span class="line">   <span class="keyword">hs_stream_t</span> *stream_;</span><br><span class="line">   <span class="keyword">hs_scratch_t</span> *scratch_;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; ids_;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; patterns_;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; flags_;</span><br><span class="line"></span><br><span class="line"><span class="comment">// parseFile 함수에서 호출하며 파일에 등록된 flags 정보를 Hyperscan에서 정의한 상수 값으로 변환하는 작업을 합니다.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parseFlags</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;flagsStr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c : flagsStr)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">switch</span> (c)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line">flags |= HS_FLAG_CASELESS;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'m'</span>:</span><br><span class="line">flags |= HS_FLAG_MULTILINE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">flags |= HS_FLAG_DOTALL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'H'</span>:</span><br><span class="line">flags |= HS_FLAG_SINGLEMATCH;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'V'</span>:</span><br><span class="line">flags |= HS_FLAG_ALLOWEMPTY;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'8'</span>:</span><br><span class="line">flags |= HS_FLAG_UTF8;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'W'</span>:</span><br><span class="line">flags |= HS_FLAG_UCP;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'\r'</span>: <span class="comment">// stray carriage-return</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> flags;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">   HyperscanTest hst;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 정규표현식 샘플 패턴들이 등록된 파일을 Hyperscan에서 사용 가능한 형태로 파싱</span></span><br><span class="line"><span class="keyword">if</span>(!hst.parseFile(<span class="string">"./pattern.db"</span>))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"parseFile failed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Hyperscan Pattern DB 컴파일</span></span><br><span class="line"><span class="keyword">if</span>(!hst.compileDatabase())</span><br><span class="line">{</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"compileDatabase failed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   {</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> pattren = <span class="string">""</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"체크할 패턴을 입력하세요 &gt;&gt; "</span>;</span><br><span class="line">    getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, pattren);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 컴파일된 Hyperscan Pattern DB를 기반으로 패턴 체크</span></span><br><span class="line"><span class="keyword">if</span>(!hst.scanPattern(pattren))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"scanPattern failed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line">   } <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure><br><h3 id="정규표현식-샘플-패턴-등록"><a href="#정규표현식-샘플-패턴-등록" class="headerlink" title="정규표현식 샘플 패턴 등록"></a>정규표현식 샘플 패턴 등록</h3><p>아래 예시는 (순서대로) 이메일, 전화번호, 휴대폰번호, 우편번호, 주민등록번호에 대한 정규표현식 샘플 패턴이며, 생성한 pattern.db는 테스트코드 빌드 결과 생성되는 실행 파일(example)과 동일한 경로에 위치시키면 됩니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ vim pattern.db</span><br><span class="line"></span><br><span class="line">1:/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]&#123;2,4&#125;$/</span><br><span class="line">2:/^(070|02|031|032|033|041|042|043|051|052|053|054|055|061|062|063|064)-\d&#123;3,4&#125;-\d&#123;4&#125;$/</span><br><span class="line">3:/^(010|011|016|017|018|019)-\d&#123;3,4&#125;-\d&#123;4&#125;$/</span><br><span class="line">4:/^\d&#123;3&#125;-?\d&#123;3&#125;$/</span><br><span class="line">5:/^\d&#123;2&#125;[0-1]\d[0-3]\d-?[1-6]\d&#123;6&#125;$/</span><br></pre></td></tr></table></figure><br><h3 id="빌드-및-테스트"><a href="#빌드-및-테스트" class="headerlink" title="빌드 및 테스트"></a>빌드 및 테스트</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ c++ -I /usr/local/include/hs example.cpp -o example -L &lt;hyperscan-source-path&gt;/build/lib -lhs</span><br><span class="line">$ ./example</span><br><span class="line">체크할 패턴을 입력하세요 &gt;&gt; 900101-1234567</span><br><span class="line">id: 5 from: 0 to: 14 flags: 0</span><br><span class="line">match count: 1</span><br><span class="line">체크할 패턴을 입력하세요 &gt;&gt; 010-1234-5678</span><br><span class="line">id: 3 from: 0 to: 13 flags: 0</span><br><span class="line">match count: 1</span><br><span class="line">체크할 패턴을 입력하세요 &gt;&gt; bluetomorrow90@gmail.com</span><br><span class="line">id: 1 from: 0 to: 24 flags: 0</span><br><span class="line">match count: 1</span><br><span class="line">체크할 패턴을 입력하세요 &gt;&gt; </span><br></pre></td></tr></table></figure><div class="alert info"><p>example 실행 시 libhs.so를 참조하지 못하는 경우에는 아래 명령어를 통해 라이브러리 참조 경로를 직접 지정해줍니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export LD_LIBRARY_PATH=&lt;hyperscan-source-path&gt;/build/lib</span><br></pre></td></tr></table></figure></div><br><h3 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h3><p>지금까지 Hyperscan 소스 빌드 과정과 정규표현식 샘플 패턴을 체크하기 위한 테스트 코드 작성에 대해 알아보았습니다. 해당 포스팅에서는 Hyperscan API의 가장 기본적인 동작들만을 살펴보았구요, Hyperscan 공식 문서를 살펴보면 멀티쓰레드 환경(“main” thread에서 pattern db를 compile하고 2개 이상의 “worker” thread에서 scan을 수행)에서도 사용이 가능하다고 하니 어떤식으로 구현해야할지 함께 고민해보면 좋을 것 같습니다. 긴 글 읽어주셔서 감사합니다🙂</p><blockquote><p>In a scenario where a set of expressions are compiled by a single “main” thread and data will be scanned by multiple “worker” threads, the convenience function hs_clone_scratch() allows multiple copies of an existing scratch space to be made for each thread (rather than forcing the caller to pass all the compiled databases through hs_alloc_scratch() multiple times).</p></blockquote><br><br><span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎<p><strong>Reference</strong></p><ul><li><a href="https://intel.github.io/hyperscan/dev-reference/getting_started.html">https://intel.github.io/hyperscan/dev-reference/getting_started.html</a></li><li><a href="https://www.boost.org/doc/libs/1_77_0/more/getting_started/unix-variants.html">https://www.boost.org/doc/libs/1_77_0/more/getting_started/unix-variants.html</a></li><li><a href="https://github.com/intel/hyperscan">https://github.com/intel/hyperscan</a></li><li><a href="https://myeonguni.tistory.com/1555">https://myeonguni.tistory.com/1555</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://chelseafandev.github.io/categories/%EA%B8%B0%EC%88%A0%EB%AC%B8%EC%84%9C-%EB%B2%88%EC%97%AD/">기술문서 번역</category>
      
      
      <category domain="https://chelseafandev.github.io/tags/hyperscan/">hyperscan</category>
      
      <category domain="https://chelseafandev.github.io/tags/regex/">regex</category>
      
      <category domain="https://chelseafandev.github.io/tags/regular-expression/">regular expression</category>
      
      <category domain="https://chelseafandev.github.io/tags/%EC%9D%B8%ED%85%94-%ED%95%98%EC%9D%B4%ED%8D%BC%EC%8A%A4%EC%BA%94/">인텔 하이퍼스캔</category>
      
      <category domain="https://chelseafandev.github.io/tags/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D-%ED%8C%A8%ED%84%B4-%EB%A7%A4%EC%B9%AD/">정규표현식 패턴 매칭</category>
      
      
      <comments>https://chelseafandev.github.io/2021/10/12/hyperscan-phase2/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
