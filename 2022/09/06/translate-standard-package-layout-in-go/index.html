
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta name="google-site-verification" content="Ojz5tvI9WuN6pn2n6i1E_mOkMyRiSSOp4KXuYSyaUjs">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="첼시팬 개발자 작업 공간">
    <title>어떠한 방식으로 Go 코드를 구조화해야 하는가? - 첼시팬 개발자 작업 공간</title>
    <meta name="author" content="첼시팬개발자">
    
    
        <link rel="icon" href="https://chelseafandev.github.io/assets/images/chelsea_favicon.png">
    
    
        
            <link rel="alternate" type="application/rss+xml" title="RSS" href="/rss2.xml">
        
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"첼시팬개발자","sameAs":[],"image":"profile_github.jpeg"},"articleBody":"최근 회사에서 Go 언어를 활용하여 신규 프로젝트를 진행할 기회가 생겼는데 추후 코드의 유지 관리를 고려해볼 때 Go 언어의 소스 코드 구조를 어떤 식으로 해야 하는가에 대해 고민이 생겼습니다.\n\n\n구글링 중에 Go 언어의 코드 구조화에 관한 좋은 글을 발견하여 실제 프로젝트에도 반영해볼 겸 해서 번역해보았습니다. 역시나 저와 같은 고민을 앞서 해주신 선구자님들이 계시더라고요😁.\n원문의 일부 내용은 번역에서 제외했으니 원문을 참고하실 분들은 해당 링크를 확인해주시기 바랍니다.\n\n\n\n\n\n\n표준 패키지 레이아웃Vendoring. Generics. 이것들은 Go 커뮤니티 내에서 큰 이슈들로 보입니다. 하지만 좀 처럼 언급되지 않는 또 다른 이슈가 하나 있습니다 - 바로 어플리케이션 패키지 레이아웃 입니다.\n\nVendoring. Generics. These are seen as big issues in the Go community but there’s another issue that’s rarely mentioned — application package layout.\n\n제가 지금까지 작업해왔던 모든 Go 어플리케이션은 “내 코드를 어떤 방식으로 구조화해야하는가?”라는 질문에 대한 각기 다른 대답을 가지고 있는것 처럼 보입니다. 몇몇 어플리케이션은 하나의 패키지에 모든 것을 밀어 넣기도하고 또 다른 어플리케이션은 타입이나 모듈 단위로 그룹화하기도 합니다. 여러분의 팀 전반에 걸쳐 적용할 만한 좋은 전략이 없다면, 여러분의 어플리케이션의 다양한 패키지들에 곳곳에 코드가 흩뿌려지게 되는 것을 보게 될 것입니다. 우리는 Go 어플리케이션 디자인에 적용할 수 있는 더나은 표준이 필요합니다.\n\nEvery Go application I’ve ever worked on appears to have a different answer to the question, how should I organize my code? Some applications push everything into one package while others group by type or module. Without a good strategy applied across your team, you’ll find code scattered across various packages of your application. We need a better standard for Go application design.\n\n저는 더 나은 접근 방식을 제안하고자 합니다. 몇가지 단순한 규칙들을 따름으로써 우리는 코드를 분리시키고 테스트를 용이하게 만들며 프로젝트에 일관된 구조를 가지고 올 수 있게됩니다.\n\nI suggest a better approach. By following a few simple rules we can decouple our code, make it easier to test, and bring a consistent structure to our project.\n\n\n\n#1. 기본 패키지는 도메인 타입을 위한 패키지다여러분의 어플리케이션은 데이터와 프로세스들이 어떠한 방식으로 상호작용하는지를 기술하는 논리적이고 고수준(사람이 이해하기 쉽게 작성된 프로그래밍 언어를 의미함)인 언어를 가지고 있습니다. 만약 여러분이 e커머스 어플리케이션을 개발 중이라면 여러분의 도메인은 고객, 계정, 신용카드 결제, 재고 관리와 같은 것들을 포함하고 있을것입니다. 만약 여러분이 페이스북을 개발하고 있다면 여러분의 도메인은 사용자, 좋아요, &amp; relationships(?)이 될것 입니다. 이러한 도메인은 여러분의 근본적인 기술과는 독립적인 개념입니다.\n\nYour application has a logical, high-level language that describes how data and processes interact. This is your domain. If you have an e-commerce application your domain involves things like customers, accounts, charging credit cards, and handling inventory. If you’re Facebook then your domain is users, likes, &amp; relationships. It’s the stuff that doesn’t depend on your underlying technology.\n\n저는 도메인 타입을 프로젝트의 기본(root) 패키지에 위치시킵니다. 기본 패키지는 사용자 정보를 저장하는 User 구조체나 사용자 정보를 가지고 오거나 저장하기 위해서 사용하는 UserService 인터페이스와 같은 단순한 데이터 타입들만을 포함하고 있습니다.\n\nI place my domain types in my root package. This package only contains simple data types like a User struct for holding user data or a UserService interface for fetching or saving user data.\n\n기본 패키지는 아래와 같은 구조를 보일 수 있을겁니다:\n\nIt may look something like:\n\ngo1234567891011121314package myapptype User struct {\tID      int\tName    string\tAddress Address}type UserService interface {\tUser(id int) (*User, error)\tUsers() ([]*User, error)\tCreateUser(u *User) error\tDeleteUser(id int) error}\n\n이것은 여러분의 기본 패키지를 매우 단순하게 만들어 줍니다. 또한 여러분은 다른 도메인 타입에 의존하는 경우에만 동작을 수행하도록 하는 타입들을 포함할 수도 있습니다. 예를 들어, 여러분이 UserService를 주기적으로 폴링(polling)하는 특정 타입을 포함시켜야할 수 있습니다. 그러나 외부 서비스를 호출하거나 데이터베이스에 저장해서는 안됩니다. 그것은 세부적인 구현 사항입니다.\n\nThis makes your root package extremely simple. You may also include types that perform actions but only if they solely depend on other domain types. For example, you could have a type that polls your UserService periodically. However, it should not call out to external services or save to a database. That is an implementation detail.\n\n기본 패키지는 여러분의 어플리케이션에 존재하는 어떠한 다른 패키지에도 의존적이어선 안됩니다!\n\nThe root package should not depend on any other package in your application!\n\n\n\n#2. 의존성에 따라 하위패키지를 그룹화하라만약 기본 패키지가 외부 의존성을 허용하지 않는다면 이러한 의존성들을 하위패키지에 추가해주어야 합니다. 이러한 접근 방식에서는 하위패키지가 도메인과 구현(implementation)사이의 어댑터로서 존재하게 됩니다.\n\nIf your root package is not allowed to have external dependencies then we must push those dependencies to subpackages. In this approach to package layout, subpackages exist as an adapter between your domain and your implementation.\n\n예를 들어, 여러분의 UserService가 PostgreSQL을 지원해야할 수 있습니다. 이때 여러분은 postgres.UserService에 대한 세부 구현을 제공하는 postgres 하위패키지를 추가할 수 있습니다:\n\nFor example, your UserService might be backed by PostgreSQL. You can introduce a postgres subpackage in your application that provides a postgres.UserService implementation:\n\ngo12345678910111213141516171819202122232425package postgresimport (\t\"database/sql\"\t\"github.com/benbjohnson/myapp\"\t_ \"github.com/lib/pq\")// UserService represents a PostgreSQL implementation of myapp.UserService.type UserService struct {\tDB *sql.DB}// User returns a user for a given id.func (s *UserService) User(id int) (*myapp.User, error) {\tvar u myapp.User\trow := db.QueryRow(`SELECT id, name FROM users WHERE id = $1`, id)\tif row.Scan(&amp;u.ID, &amp;u.Name); err != nil {\t\treturn nil, err\t}\treturn &amp;u, nil}// implement remaining myapp.UserService interface...\n\n이것은 PostgreSQL 의존성을 분리하게되는데 이러한 의존성의 분리는 테스트 과정을 단순화시켜주고 추후 또 다른 데이터베이스로 마이그레이션하기 위한 쉬운 방식을 제공합니다. 여러분이 BoltDB와 같은 또 다른 데이터베이스에 대한 세부 구현을 지원하기로 결정했다면 이것은 플러그형 구조로 사용될 수 있습니다.\n\nThis isolates our PostgreSQL dependency which simplifies testing and provides an easy way to migrate to another database in the future. It can be used as a pluggable architecture if you decide to support other database implementations such as BoltDB.\n\n이것은 또한 구현을 계층화하는 방법을 제공합니다. 아마도 여러분은 PostgreSQL 앞에 LRU 캐시를 두어 데이터를 메모상에 보관하기를 원할 것입니다. 이를 위해 PostgreSQL 세부 구현을 래핑(wrapping)할 수 있는 UserService를 구현하는 UserCache를 추가할 수 있습니다.\n\nIt also gives you a way to layer implementations. Perhaps you want to hold an in-memory, LRU cache in front of PostgreSQL. You can add a UserCache that implements UserService which can wrap your PostgreSQL implementation:\n\ngo123456789101112131415161718192021222324252627282930313233package myapp// UserCache wraps a UserService to provide an in-memory cache.type UserCache struct {\t\tcache   map[int]*User\t\tservice UserService}// NewUserCache returns a new read-through cache for service.func NewUserCache(service UserService) *UserCache {\t\treturn &amp;UserCache{\t\t\t\tcache: make(map[int]*User),\t\t\t\tservice: service,\t\t}}// User returns a user for a given id.// Returns the cached instance if available.func (c *UserCache) User(id int) (*User, error) {\t// Check the local cache first.\t\tif u := c.cache[id]; u != nil {\t\t\t\treturn u, nil\t\t}\t// Otherwise fetch from the underlying service.\t\tu, err := c.service.User(id)\t\tif err != nil {\t\t\treturn nil, err\t\t} else if u != nil {\t\t\tc.cache[id] = u\t\t}\t\treturn u, err}\n\nGolang의 기본 라이브러리들에서도 이러한 접근 방식을 살펴볼 수 있습니다. io.Reader는 바이트를 읽어들이기 위한 도메인 타입이고 그것의 세부 구현들은 의존성에 의해 그룹화되어 있습니다 - tar.Reader, gzip.Reader, multipart.Reader. 이것들 또한 계층화될 수 있습니다. os.File은 bufio.Reader에 의해 래핑되어있고 이 bufio.Reader는 gzip.Reader에 의해 래핑되어있으며 gzip.Reader는 tar.Reader에 의해 래핑되어있는 이러한 모습들은 흔히 보이는 계층 구조들입니다.\n\nWe see this approach in the standard library too. The io.Reader is a domain type for reading bytes and its implementations are grouped by dependency — tar.Reader, gzip.Reader, multipart.Reader. These can be layered as well. It’s common to see an os.File wrapped by a bufio.Reader which is wrapped by a gzip.Reader which is wrapped by a tar.Reader.\n\n\n\n의존성 간의 의존성여러분의 의존성은 홀로 고립된 채로 살아갈 수 없습니다. User 데이터는 PostgreSQL에 저장을 하고 재무와 관련된 트랜잭션 데이터는 Stripe와 같은 3rd party 서비스에 저장해야하는 경우가 생길 수 있습니다. 이러한 경우에는 Stripe가 논리적인 도메인 타입과 함께 묶이게 됩니다 - 이것을 TranscationService라고 부르기로 하겠습니다.\n\nYour dependencies don’t live in isolation. You may store User data in PostgreSQL but your financial transaction data exists in a third party service like Stripe. In this case we wrap our Stripe dependency with a logical domain type — let’s call it TransactionService.\n\nUserService에 TransactionService를 추가함으로써 우리는 이 두가지 의존성을 분리할 수 있습니다.\n\nBy adding our TransactionService to our UserService we decouple our two dependencies:\n\ngo1234type UserService struct {\tDB                 *sql.DB\tTransactionService myapp.TransactionService}\n\n이제 우리의 의존성들은 오직 공통된 도메인 언어를 통해서만 소통하게 됩니다. 이것은 우리가 다른 의존성들에 영향을 주지 않고 PostgreSQL을 MySQL로 Stripe를 또 다른 지불 프로세서로 변경할 수 있음을 의미합니다.\n\nNow our dependencies communicate solely through our common domain language. This means that we could swap out PostgreSQL for MySQL or switch Stripe for another payment processor without affecting other dependencies.\n\n\n\n이러한 접근 방식을 3rd party 의존성에만 국한 시키지마라3rd party 의존성에만 국한 시키지말라는 말이 이상하게 들릴 수 있지만 이와 동일한 방식으로 Golang에서 제공하는 기본 라이브러리를 고립시킬 수 있습니다. 예를 들어, net/http 패키지는 단지 또 다른 의존성입니다. 우리가 만든 어플리케이션에 존재하는 http 라는 하위패키지에 이 net/http 패키지를  추가함으로써 고립된 환경을 구성할 수 있습니다.\n\nThis may sound odd but I also isolate my standard library dependencies with this same method. For instance, the net/http package is just another dependency. We can isolate it as well by including an http subpackage in our application.\n\n해당 패키지의 이름이 그것이 감싸고 있는 의존성과 동일한 이름을 갖는다는 것이 이상할 수 있지만 이것은 의도된 것입니다. 여러분이 만든 어플리케이션의 다른 어떠한 모듈들에서도 net/http 패키지를 사용하는 곳이 없다면 패키지 이름 충돌이 발생할 일은 없습니다. 이름을 중복시킴으로 얻을 수 있는 이점은 이를 통해 여러분이 HTTP와 관련된 모든 코드들은 새롭게 만든 http 패키지에 포함되도록 한다는 것입니다.\n\nIt might seem odd to have a package with the same name as the dependency it wraps, however, this is intentional. There are no package name conflicts in your application unless you allow net/http to be used in other parts of your application. The benefit to duplicating the name is that it requires you to isolate all HTTP code to your http package.\n\ngo123456789101112131415package httpimport (\t\t\"net/http\"\t\t\t\t\"github.com/benbjohnson/myapp\")type Handler struct {\t\tUserService myapp.UserService}func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\t\t// handle request}\n\n이제 우리가 만든 http.Handler는 도메인과 HTTP 프로토콜 간 어댑터로서의 역할을 수행하게 됩니다.\n\nNow your http.Handler acts as an adapter between your domain and the HTTP protocol.\n\n\n\n#3. 공유된 mock 하위패키지를 사용하라우리의 의존성들은 도메인 인터페이스를 통해 다른 의존성들과 분리되어 있기떄문에 우리는 mock 구현을 주입하기 위해 이러한 연결 지점들을 사용할 수 있습니다.\n\nBecause our dependencies are isolated from other dependencies by our domain interfaces, we can use these connection points to inject mock implementations.\n\n여러분에게 mock를 생성해주는 GoMock과 같은 mocking 라이브러리들이 몇가지 있지만 저는 개인적으로 그것들을 직접 작성하는것을 선호합니다. 대부분의 mocking 도구들은 너무 복잡하게 되어있습니다.\n\nThere are several mocking libraries such as GoMock that will generate mocks for you but I personally prefer to just write them myself. I find many of the mocking tools to be overly complicated.\n\n제가 사용하는 mocks는 매우 간단합니다. 예를 들어, UserService를 위한 mock은 아래와 같습니다:\n\nThe mocks I use are very simple. For example, a mock for the UserService looks like:\n\ngo12345678910111213141516171819202122package mockimport \"github.com/benbjohnson/myapp\"// UserService represents a mock implementation of myapp.UserService.type UserService struct {\t\tUserFn      func(id int) (*myapp.User, error)\t\tUserInvoked bool\t\tUsersFn     func() ([]*myapp.User, error)\t\tUsersInvoked bool\t\t// additional function implementations...}// User invokes the mock implementation and marks the function as invoked.func (s *UserService) User(id int) (*myapp.User, error) {\t\ts.UserInvoked = true\t\treturn s.UserFn(id)}// additional functions: Users(), CreateUser(), DeleteUser()\n\n이 mock은 인자들의 유효성을 검사하거나 기대된 데이터가 반환되는지를 확인하거나 실패하는 케이스를 주입해보기 위해 myapp.UserService 인터페이스를 사용하기만 한다면 어느 곳이든 함수들을 주입해볼 수 있습니다.\n\nThis mock lets me inject functions into anything that uses the myapp.UserService interface to validate arguments, return expected data, or inject failures.\n\n예를 들어 위에서 만들어 본 http.Handler를 테스트하기 원한다고 해봅시다:\n\nLet’s say we want to test our http.Handler that we built above:\n\ngo12345678910111213141516171819202122232425262728293031323334package http_testimport (\t\"testing\"\t\"net/http\"\t\"net/http/httptest\"\t\"github.com/benbjohnson/myapp/mock\")func TestHandler(t *testing.T) {\t// Inject our mock into our handler.\tvar us mock.UserService\tvar h Handler\th.UserService = &amp;us\t// Mock our User() call.\tus.UserFn = func(id int) (*myapp.User, error) {\t\tif id != 100 {\t\t\tt.Fatalf(\"unexpected id: %d\", id)\t\t}\t\treturn &amp;myapp.User{ID: 100, Name: \"susy\"}, nil\t}\t// Invoke the handler.\tw := httptest.NewRecorder()\tr, _ := http.NewRequest(\"GET\", \"/users/100\", nil)\th.ServeHTTP(w, r)\t\t// Validate mock.\tif !us.UserInvoked {\t\tt.Fatal(\"expected User() to be invoked\")\t}}\n\nmock는 유닛 테스트와 HTTP 프로토콜의 처리부분이 완전히 분리될 수 있도록 해줍니다.\n\nOur mock lets us completely isolate our unit test to only the handling of the HTTP protocol.\n\n\n\n#4. 메인 패키지는 의존성들을 하나로 엮는다이러한 모든 의존성 패키지들이 고립된 채로 떠다니게 된다면 이들을 어떻게 하나로 결합할 수 있을지 궁금할 수 있습니다. 이 역할을 하는 것이 메인 패키지 입니다.\n\nWith all these dependency packages floating around in isolation, you may wonder how they all come together. That’s the job of the main package.\n\n\n\n메인 패키지 레이아웃어플리케이션은 2개 이상의 바이너리 파일을 생성할 수도 있는데 이를 위해 메인 패키지를 cmd 패키지의 하위 디렉토리로 두는 Go 언어의 관습(convention)을 사용할 것입니다. 예를 들어, 우리 프로젝트가 myapp 이라는 서버 바이너리뿐만 아니라 터미널을 통해 서버를 관리할 수 있도록 하는 myappctl 이라는 클라이언트 바이너리도 갖고있다고 해봅시다. 우리의 메인 패키지를 아래와 같이 구성하게 될 것입니다:\n\nAn application may produce multiple binaries so we’ll use the Go convention of placing our main package as a subdirectory of the cmd package. For example, our project may have a myapp server binary but also a myappctl client binary for managing the server from the terminal. We’ll layout our main packages like this:\n\n123456myapp/    cmd/        myapp/            main.go        myappctl/            main.go\n\n\n\n컴파일 타임에 의존성 주입“의존성 주입”이라는 용어는 나쁜 평판을 받아왔습니다. 이것은 장황한 Spring XML 파일에 대한 생각을 불러일으 킵니다. 하지만 그 용어의 실제 의미는 우리는 객체에게 스스로 빌드하거나 의존성을 직접 찾아가는 것을 요구하는 대신에 객체에게 의존성을 직접 전달해줄 것이다라는 것이 전부입니다.\n\nThe term “dependency injection” has gotten a bad rap. It conjures up thoughts of verbose Spring XML files. However, all the term really means is that we’re going to pass dependencies to our objects instead of requiring that the object build or find the dependency itself.\n\n메인 패키지는 어떤 의존성을 어떤 객체에게 주입할 것인지를 선택하는 역할을 합니다. 메인 패키지는 단순히 이러한 조각들을 이어 붙이는 역할만을 수행하기 때문에 코드의 규모가 작고 사소한 경향이 있습니다:\n\nThe main package is what gets to choose which dependencies to inject into which objects. Because the main package simply wires up the pieces, it tends to be fairly small and trivial code:\n\ngo12345678910111213141516171819202122232425262728package mainimport (\t\"log\"\t\"os\"\t\t\"github.com/benbjohnson/myapp\"\t\"github.com/benbjohnson/myapp/postgres\"\t\"github.com/benbjohnson/myapp/http\")func main() {\t// Connect to database.\tdb, err := postgres.Open(os.Getenv(\"DB\"))\tif err != nil {\t\tlog.Fatal(err)\t}\tdefer db.Close()\t// Create services.\tus := &amp;postgres.UserService{DB: db}\t// Attach to HTTP handler.\tvar h http.Handler\th.UserService = us\t\t// start http server...}\n\n여러분의 메인 패키지 또한 어댑터의 역할을 한다는 것도 중요한 점입니다. 메인 패키지는 터미널과 여러분의 도메인을 연결해줍니다.\n\nIt’s also important to note that your main package is also an adapter. It connects the terminal to your domain.\n\n\n\n결론어플리케이션 디자인은 매우 어려운 문제입니다. 너무나 많은 디자인 결정들이 존재하고 여러분에게 가이드해줄 견고한 이론들의 부재는 문제를 더욱 심각하게 만들 수 있습니다. 우리는 Go 어플리케이션에서 현재 사용되는 몇가지 접근 방식을 살펴보았고 그것들의 많은 결함들을 확인했습니다.\n\nApplication design is a hard problem. There are so many design decisions to make and without a set of solid principles to guide you the problem is made even worse. We’ve looked at several current approaches to Go application design and we’ve seen many of their flaws.\n\n저는 의존성의 관점을 통해 디자인에 접근하는 방식이 코드 구성을 더 단순하고 쉽게 추론할 수 있도록 만들어 준다고 생각합니다. 먼저 우리는 도메인 언어를 디자인 합니다. 그리고나서 의존성들을 분리합니다. 다음으로 테스트 환경을 분리하기 위해 mocks를 도입합니다. 마지막으로 메인 패키지 안에서 이 모든 것들을 하나로 엮습니다.\n\nI believe approaching design from the standpoint of dependencies makes code organization simpler and easier to reason about. First we design our domain language. Then we isolate our dependencies. Next we introduce mocks to isolate our tests. Finally, we tie everything together within our main package.\n\n여러분이 디자인할 다음 어플리케이션에 이러한 이론들을 고려해보시기 바랍니다. 질문이 있으시거나 디자인에 대한 토론을 원하신다면 @benbjohnson 트위터를 통해 연락주시거나 Gopher 슬랙에서 benbjohnson을 찾아주세요.\n\nConsider these principles in the next application you design. If you have any questions or want to discuss design, contact me at @benbjohnson on Twitter or find me as benbjohnson on the Gopher slack.\n\n\n\n\n해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다😎\n\nReference\n\nhttps://www.gobeyond.dev/standard-package-layout/\n\n","dateCreated":"2022-09-06T18:30:58+09:00","dateModified":"2023-07-02T22:23:21+09:00","datePublished":"2022-09-06T18:30:58+09:00","description":"최근 회사에서 Go 언어를 활용하여 신규 프로젝트를 진행할 기회가 생겼는데 추후 코드의 유지 관리를 고려해볼 때 Go 언어의 소스 코드 구조를 어떤 식으로 해야 하는가에 대해 고민이 생겼습니다.","headline":"어떠한 방식으로 Go 코드를 구조화해야 하는가?","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://chelseafandev.github.io/2022/09/06/translate-standard-package-layout-in-go/"},"publisher":{"@type":"Organization","name":"첼시팬개발자","sameAs":[],"image":"profile_github.jpeg","logo":{"@type":"ImageObject","url":"profile_github.jpeg"}},"url":"https://chelseafandev.github.io/2022/09/06/translate-standard-package-layout-in-go/","keywords":"go, golang, go layout, organize go code, package layout"}</script>
    <meta name="description" content="최근 회사에서 Go 언어를 활용하여 신규 프로젝트를 진행할 기회가 생겼는데 추후 코드의 유지 관리를 고려해볼 때 Go 언어의 소스 코드 구조를 어떤 식으로 해야 하는가에 대해 고민이 생겼습니다.">
<meta property="og:type" content="blog">
<meta property="og:title" content="어떠한 방식으로 Go 코드를 구조화해야 하는가?">
<meta property="og:url" content="https://chelseafandev.github.io/2022/09/06/translate-standard-package-layout-in-go/index.html">
<meta property="og:site_name" content="첼시팬 개발자 작업 공간">
<meta property="og:description" content="최근 회사에서 Go 언어를 활용하여 신규 프로젝트를 진행할 기회가 생겼는데 추후 코드의 유지 관리를 고려해볼 때 Go 언어의 소스 코드 구조를 어떤 식으로 해야 하는가에 대해 고민이 생겼습니다.">
<meta property="og:locale" content="ko_KR">
<meta property="article:published_time" content="2022-09-06T09:30:58.000Z">
<meta property="article:modified_time" content="2023-07-02T13:23:21.670Z">
<meta property="article:author" content="첼시팬개발자">
<meta property="article:tag" content="go">
<meta property="article:tag" content="golang">
<meta property="article:tag" content="go layout">
<meta property="article:tag" content="organize go code">
<meta property="article:tag" content="package layout">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://chelseafandev.github.io/assets/images/profile_github.jpeg">
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/all.css">

    
<link rel="stylesheet" href="/assets/css/jquery.fancybox.css">

    
<link rel="stylesheet" href="/assets/css/thumbs.css">

    
<link rel="stylesheet" href="/assets/css/tranquilpeak.css">

    <!--STYLES END-->
    

    

    
        
    
    <link rel="canonical" href="https://chelseafandev.github.io/2022/09/06/translate-standard-package-layout-in-go/">
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/" aria-label>
            첼시팬 개발자 작업 공간
        </a>
    </div>
    
        
            <a class="header-right-picture " href="#about" aria-label="링크 열기: /#about">
        
        
            <img class="header-picture" src="/assets/images/profile_github.jpeg" alt="저자 이미지">
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4" style="border-top-width: 100px;padding-top: 150px;">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about" aria-label="저자에 대해 더 알아보기">
                    <img class="sidebar-profile-picture" src="/assets/images/profile_github.jpeg" alt="저자 이미지">
                </a>
                <h4 class="sidebar-profile-name">첼시팬개발자</h4>
                
                    <h5 class="sidebar-profile-bio"><p>조금 더디더라도 꾸준히</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/" rel="noopener" title="전체글">
                        <i class="sidebar-button-icon fas fa-list-ul" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">전체글</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-categories" rel="noopener" title="카테고리">
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">카테고리</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-tags" rel="noopener" title="태그">
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">태그</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-archives" rel="noopener" title="아카이브">
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">아카이브</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://github.com/chelseafandev" target="_blank" rel="external nofollow noopener noreferrer" title="GitHub">
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/rss2.xml" rel="noopener" title="RSS">
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4" class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            어떠한 방식으로 Go 코드를 구조화해야 하는가?
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2022-09-06T18:30:58+09:00">
	
		    2022/09/06 18:30:58
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/Go/">Go</a>


    
    
        -
        <span class="reading-time">⏱</span>
        
            읽는데 17 분 정도 소요 예상
        
        
    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>최근 회사에서 Go 언어를 활용하여 신규 프로젝트를 진행할 기회가 생겼는데 추후 코드의 유지 관리를 고려해볼 때 Go 언어의 소스 코드 구조를 어떤 식으로 해야 하는가에 대해 고민이 생겼습니다.</p>
<span id="more"></span>

<p>구글링 중에 Go 언어의 코드 구조화에 관한 좋은 글을 발견하여 실제 프로젝트에도 반영해볼 겸 해서 번역해보았습니다. 역시나 저와 같은 고민을 앞서 해주신 선구자님들이 계시더라고요😁.</p>
<p>원문의 일부 내용은 번역에서 제외했으니 원문을 참고하실 분들은 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.gobeyond.dev/standard-package-layout/">해당 링크</a>를 확인해주시기 바랍니다.</p>
<br>

<h1 id="table-of-contents">목차</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%ED%91%9C%EC%A4%80-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83"><span class="toc-number">1.</span> <span class="toc-text">표준 패키지 레이아웃</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%EA%B8%B0%EB%B3%B8-%ED%8C%A8%ED%82%A4%EC%A7%80%EB%8A%94-%EB%8F%84%EB%A9%94%EC%9D%B8-%ED%83%80%EC%9E%85%EC%9D%84-%EC%9C%84%ED%95%9C-%ED%8C%A8%ED%82%A4%EC%A7%80%EB%8B%A4"><span class="toc-number">1.1.</span> <span class="toc-text">#1. 기본 패키지는 도메인 타입을 위한 패키지다</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%EC%9D%98%EC%A1%B4%EC%84%B1%EC%97%90-%EB%94%B0%EB%9D%BC-%ED%95%98%EC%9C%84%ED%8C%A8%ED%82%A4%EC%A7%80%EB%A5%BC-%EA%B7%B8%EB%A3%B9%ED%99%94%ED%95%98%EB%9D%BC"><span class="toc-number">1.2.</span> <span class="toc-text">#2. 의존성에 따라 하위패키지를 그룹화하라</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%9D%98%EC%A1%B4%EC%84%B1-%EA%B0%84%EC%9D%98-%EC%9D%98%EC%A1%B4%EC%84%B1"><span class="toc-number">1.2.1.</span> <span class="toc-text">의존성 간의 의존성</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%9D%B4%EB%9F%AC%ED%95%9C-%EC%A0%91%EA%B7%BC-%EB%B0%A9%EC%8B%9D%EC%9D%84-3rd-party-%EC%9D%98%EC%A1%B4%EC%84%B1%EC%97%90%EB%A7%8C-%EA%B5%AD%ED%95%9C-%EC%8B%9C%ED%82%A4%EC%A7%80%EB%A7%88%EB%9D%BC"><span class="toc-number">1.2.2.</span> <span class="toc-text">이러한 접근 방식을 3rd party 의존성에만 국한 시키지마라</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%EA%B3%B5%EC%9C%A0%EB%90%9C-mock-%ED%95%98%EC%9C%84%ED%8C%A8%ED%82%A4%EC%A7%80%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC"><span class="toc-number">1.3.</span> <span class="toc-text">#3. 공유된 mock 하위패키지를 사용하라</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%EB%A9%94%EC%9D%B8-%ED%8C%A8%ED%82%A4%EC%A7%80%EB%8A%94-%EC%9D%98%EC%A1%B4%EC%84%B1%EB%93%A4%EC%9D%84-%ED%95%98%EB%82%98%EB%A1%9C-%EC%97%AE%EB%8A%94%EB%8B%A4"><span class="toc-number">1.4.</span> <span class="toc-text">#4. 메인 패키지는 의존성들을 하나로 엮는다</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%A9%94%EC%9D%B8-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83"><span class="toc-number">1.4.1.</span> <span class="toc-text">메인 패키지 레이아웃</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%BB%B4%ED%8C%8C%EC%9D%BC-%ED%83%80%EC%9E%84%EC%97%90-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85"><span class="toc-number">1.4.2.</span> <span class="toc-text">컴파일 타임에 의존성 주입</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EA%B2%B0%EB%A1%A0"><span class="toc-number">1.5.</span> <span class="toc-text">결론</span></a></li></ol></li></ol>

<br>

<h1 id="표준-패키지-레이아웃"><a href="#표준-패키지-레이아웃" class="headerlink" title="표준 패키지 레이아웃"></a>표준 패키지 레이아웃</h1><p>Vendoring. Generics. 이것들은 Go 커뮤니티 내에서 큰 이슈들로 보입니다. 하지만 좀 처럼 언급되지 않는 또 다른 이슈가 하나 있습니다 - 바로 어플리케이션 패키지 레이아웃 입니다.</p>
<blockquote>
<p>Vendoring. Generics. These are seen as big issues in the Go community but there’s another issue that’s rarely mentioned — application package layout.</p>
</blockquote>
<p>제가 지금까지 작업해왔던 모든 Go 어플리케이션은 “내 코드를 어떤 방식으로 구조화해야하는가?”라는 질문에 대한 각기 다른 대답을 가지고 있는것 처럼 보입니다. 몇몇 어플리케이션은 하나의 패키지에 모든 것을 밀어 넣기도하고 또 다른 어플리케이션은 타입이나 모듈 단위로 그룹화하기도 합니다. 여러분의 팀 전반에 걸쳐 적용할 만한 좋은 전략이 없다면, 여러분의 어플리케이션의 다양한 패키지들에 곳곳에 코드가 흩뿌려지게 되는 것을 보게 될 것입니다. 우리는 Go 어플리케이션 디자인에 적용할 수 있는 더나은 표준이 필요합니다.</p>
<blockquote>
<p>Every Go application I’ve ever worked on appears to have a different answer to the question, how should I organize my code? Some applications push everything into one package while others group by type or module. Without a good strategy applied across your team, you’ll find code scattered across various packages of your application. We need a better standard for Go application design.</p>
</blockquote>
<p>저는 더 나은 접근 방식을 제안하고자 합니다. 몇가지 단순한 규칙들을 따름으로써 우리는 코드를 분리시키고 테스트를 용이하게 만들며 프로젝트에 일관된 구조를 가지고 올 수 있게됩니다.</p>
<blockquote>
<p>I suggest a better approach. By following a few simple rules we can decouple our code, make it easier to test, and bring a consistent structure to our project.</p>
</blockquote>
<br>

<h2 id="1-기본-패키지는-도메인-타입을-위한-패키지다"><a href="#1-기본-패키지는-도메인-타입을-위한-패키지다" class="headerlink" title="#1. 기본 패키지는 도메인 타입을 위한 패키지다"></a>#1. 기본 패키지는 도메인 타입을 위한 패키지다</h2><p>여러분의 어플리케이션은 데이터와 프로세스들이 어떠한 방식으로 상호작용하는지를 기술하는 논리적이고 고수준(사람이 이해하기 쉽게 작성된 프로그래밍 언어를 의미함)인 언어를 가지고 있습니다. 만약 여러분이 e커머스 어플리케이션을 개발 중이라면 여러분의 도메인은 고객, 계정, 신용카드 결제, 재고 관리와 같은 것들을 포함하고 있을것입니다. 만약 여러분이 페이스북을 개발하고 있다면 여러분의 도메인은 사용자, 좋아요, &amp; relationships(?)이 될것 입니다. 이러한 도메인은 여러분의 근본적인 기술과는 독립적인 개념입니다.</p>
<blockquote>
<p>Your application has a logical, high-level language that describes how data and processes interact. This is your domain. If you have an e-commerce application your domain involves things like customers, accounts, charging credit cards, and handling inventory. If you’re Facebook then your domain is users, likes, &amp; relationships. It’s the stuff that doesn’t depend on your underlying technology.</p>
</blockquote>
<p>저는 도메인 타입을 프로젝트의 기본(root) 패키지에 위치시킵니다. 기본 패키지는 사용자 정보를 저장하는 User 구조체나 사용자 정보를 가지고 오거나 저장하기 위해서 사용하는 UserService 인터페이스와 같은 단순한 데이터 타입들만을 포함하고 있습니다.</p>
<blockquote>
<p>I place my domain types in my root package. This package only contains simple data types like a User struct for holding user data or a UserService interface for fetching or saving user data.</p>
</blockquote>
<p>기본 패키지는 아래와 같은 구조를 보일 수 있을겁니다:</p>
<blockquote>
<p>It may look something like:</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> myapp</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">	ID      <span class="keyword">int</span></span><br><span class="line">	Name    <span class="keyword">string</span></span><br><span class="line">	Address Address</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserService <span class="keyword">interface</span> {</span><br><span class="line">	User(id <span class="keyword">int</span>) (*User, error)</span><br><span class="line">	Users() ([]*User, error)</span><br><span class="line">	CreateUser(u *User) error</span><br><span class="line">	DeleteUser(id <span class="keyword">int</span>) error</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>이것은 여러분의 기본 패키지를 매우 단순하게 만들어 줍니다. 또한 여러분은 다른 도메인 타입에 의존하는 경우에만 동작을 수행하도록 하는 타입들을 포함할 수도 있습니다. 예를 들어, 여러분이 UserService를 주기적으로 폴링(polling)하는 특정 타입을 포함시켜야할 수 있습니다. 그러나 외부 서비스를 호출하거나 데이터베이스에 저장해서는 안됩니다. 그것은 세부적인 구현 사항입니다.</p>
<blockquote>
<p>This makes your root package extremely simple. You may also include types that perform actions but only if they solely depend on other domain types. For example, you could have a type that polls your UserService periodically. However, it should not call out to external services or save to a database. That is an implementation detail.</p>
</blockquote>
<p><em>기본 패키지는 여러분의 어플리케이션에 존재하는 어떠한 다른 패키지에도 의존적이어선 안됩니다!</em></p>
<blockquote>
<p><em>The root package should not depend on any other package in your application!</em></p>
</blockquote>
<br>

<h2 id="2-의존성에-따라-하위패키지를-그룹화하라"><a href="#2-의존성에-따라-하위패키지를-그룹화하라" class="headerlink" title="#2. 의존성에 따라 하위패키지를 그룹화하라"></a>#2. 의존성에 따라 하위패키지를 그룹화하라</h2><p>만약 기본 패키지가 외부 의존성을 허용하지 않는다면 이러한 의존성들을 하위패키지에 추가해주어야 합니다. 이러한 접근 방식에서는 하위패키지가 도메인과 구현(implementation)사이의 어댑터로서 존재하게 됩니다.</p>
<blockquote>
<p>If your root package is not allowed to have external dependencies then we must push those dependencies to subpackages. In this approach to package layout, subpackages exist as an adapter between your domain and your implementation.</p>
</blockquote>
<p>예를 들어, 여러분의 UserService가 PostgreSQL을 지원해야할 수 있습니다. 이때 여러분은 postgres.UserService에 대한 세부 구현을 제공하는 postgres 하위패키지를 추가할 수 있습니다:</p>
<blockquote>
<p>For example, your UserService might be backed by PostgreSQL. You can introduce a postgres subpackage in your application that provides a postgres.UserService implementation:</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> postgres</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"database/sql"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/benbjohnson/myapp"</span></span><br><span class="line">	_ <span class="string">"github.com/lib/pq"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserService represents a PostgreSQL implementation of myapp.UserService.</span></span><br><span class="line"><span class="keyword">type</span> UserService <span class="keyword">struct</span> {</span><br><span class="line">	DB *sql.DB</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// User returns a user for a given id.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *UserService)</span> <span class="title">User</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="params">(*myapp.User, error)</span></span> {</span><br><span class="line">	<span class="keyword">var</span> u myapp.User</span><br><span class="line">	row := db.QueryRow(<span class="string">`SELECT id, name FROM users WHERE id = $1`</span>, id)</span><br><span class="line">	<span class="keyword">if</span> row.Scan(&amp;u.ID, &amp;u.Name); err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> &amp;u, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// implement remaining myapp.UserService interface...</span></span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>이것은 PostgreSQL 의존성을 분리하게되는데 이러한 의존성의 분리는 테스트 과정을 단순화시켜주고 추후 또 다른 데이터베이스로 마이그레이션하기 위한 쉬운 방식을 제공합니다. 여러분이 BoltDB와 같은 또 다른 데이터베이스에 대한 세부 구현을 지원하기로 결정했다면 이것은 플러그형 구조로 사용될 수 있습니다.</p>
<blockquote>
<p>This isolates our PostgreSQL dependency which simplifies testing and provides an easy way to migrate to another database in the future. It can be used as a pluggable architecture if you decide to support other database implementations such as BoltDB.</p>
</blockquote>
<p>이것은 또한 구현을 계층화하는 방법을 제공합니다. 아마도 여러분은 PostgreSQL 앞에 LRU 캐시를 두어 데이터를 메모상에 보관하기를 원할 것입니다. 이를 위해 PostgreSQL 세부 구현을 래핑(wrapping)할 수 있는 UserService를 구현하는 UserCache를 추가할 수 있습니다.</p>
<blockquote>
<p>It also gives you a way to layer implementations. Perhaps you want to hold an in-memory, LRU cache in front of PostgreSQL. You can add a UserCache that implements UserService which can wrap your PostgreSQL implementation:</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> myapp</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserCache wraps a UserService to provide an in-memory cache.</span></span><br><span class="line"><span class="keyword">type</span> UserCache <span class="keyword">struct</span> {</span><br><span class="line">		cache   <span class="keyword">map</span>[<span class="keyword">int</span>]*User</span><br><span class="line">		service UserService</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewUserCache returns a new read-through cache for service.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUserCache</span><span class="params">(service UserService)</span> *<span class="title">UserCache</span></span> {</span><br><span class="line">		<span class="keyword">return</span> &amp;UserCache{</span><br><span class="line">				cache: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*User),</span><br><span class="line">				service: service,</span><br><span class="line">		}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// User returns a user for a given id.</span></span><br><span class="line"><span class="comment">// Returns the cached instance if available.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *UserCache)</span> <span class="title">User</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="params">(*User, error)</span></span> {</span><br><span class="line">	<span class="comment">// Check the local cache first.</span></span><br><span class="line">		<span class="keyword">if</span> u := c.cache[id]; u != <span class="literal">nil</span> {</span><br><span class="line">				<span class="keyword">return</span> u, <span class="literal">nil</span></span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Otherwise fetch from the underlying service.</span></span><br><span class="line">		u, err := c.service.User(id)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		} <span class="keyword">else</span> <span class="keyword">if</span> u != <span class="literal">nil</span> {</span><br><span class="line">			c.cache[id] = u</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> u, err</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>Golang의 기본 라이브러리들에서도 이러한 접근 방식을 살펴볼 수 있습니다. io.Reader는 바이트를 읽어들이기 위한 도메인 타입이고 그것의 세부 구현들은 의존성에 의해 그룹화되어 있습니다 - tar.Reader, gzip.Reader, multipart.Reader. 이것들 또한 계층화될 수 있습니다. os.File은 bufio.Reader에 의해 래핑되어있고 이 bufio.Reader는 gzip.Reader에 의해 래핑되어있으며 gzip.Reader는 tar.Reader에 의해 래핑되어있는 이러한 모습들은 흔히 보이는 계층 구조들입니다.</p>
<blockquote>
<p>We see this approach in the standard library too. The io.Reader is a domain type for reading bytes and its implementations are grouped by dependency — tar.Reader, gzip.Reader, multipart.Reader. These can be layered as well. It’s common to see an os.File wrapped by a bufio.Reader which is wrapped by a gzip.Reader which is wrapped by a tar.Reader.</p>
</blockquote>
<br>

<h3 id="의존성-간의-의존성"><a href="#의존성-간의-의존성" class="headerlink" title="의존성 간의 의존성"></a>의존성 간의 의존성</h3><p>여러분의 의존성은 홀로 고립된 채로 살아갈 수 없습니다. User 데이터는 PostgreSQL에 저장을 하고 재무와 관련된 트랜잭션 데이터는 Stripe와 같은 3rd party 서비스에 저장해야하는 경우가 생길 수 있습니다. 이러한 경우에는 Stripe가 논리적인 도메인 타입과 함께 묶이게 됩니다 - 이것을 TranscationService라고 부르기로 하겠습니다.</p>
<blockquote>
<p>Your dependencies don’t live in isolation. You may store User data in PostgreSQL but your financial transaction data exists in a third party service like Stripe. In this case we wrap our Stripe dependency with a logical domain type — let’s call it TransactionService.</p>
</blockquote>
<p>UserService에 TransactionService를 추가함으로써 우리는 이 두가지 의존성을 분리할 수 있습니다.</p>
<blockquote>
<p>By adding our TransactionService to our UserService we decouple our two dependencies:</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UserService <span class="keyword">struct</span> {</span><br><span class="line">	DB                 *sql.DB</span><br><span class="line">	TransactionService myapp.TransactionService</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>이제 우리의 의존성들은 오직 공통된 도메인 언어를 통해서만 소통하게 됩니다. 이것은 우리가 다른 의존성들에 영향을 주지 않고 PostgreSQL을 MySQL로 Stripe를 또 다른 지불 프로세서로 변경할 수 있음을 의미합니다.</p>
<blockquote>
<p>Now our dependencies communicate solely through our common domain language. This means that we could swap out PostgreSQL for MySQL or switch Stripe for another payment processor without affecting other dependencies.</p>
</blockquote>
<br>

<h3 id="이러한-접근-방식을-3rd-party-의존성에만-국한-시키지마라"><a href="#이러한-접근-방식을-3rd-party-의존성에만-국한-시키지마라" class="headerlink" title="이러한 접근 방식을 3rd party 의존성에만 국한 시키지마라"></a>이러한 접근 방식을 3rd party 의존성에만 국한 시키지마라</h3><p>3rd party 의존성에만 국한 시키지말라는 말이 이상하게 들릴 수 있지만 이와 동일한 방식으로 Golang에서 제공하는 기본 라이브러리를 고립시킬 수 있습니다. 예를 들어, net/http 패키지는 단지 또 다른 의존성입니다. 우리가 만든 어플리케이션에 존재하는 http 라는 하위패키지에 이 net/http 패키지를  추가함으로써 고립된 환경을 구성할 수 있습니다.</p>
<blockquote>
<p>This may sound odd but I also isolate my standard library dependencies with this same method. For instance, the net/http package is just another dependency. We can isolate it as well by including an http subpackage in our application.</p>
</blockquote>
<p>해당 패키지의 이름이 그것이 감싸고 있는 의존성과 동일한 이름을 갖는다는 것이 이상할 수 있지만 이것은 의도된 것입니다. 여러분이 만든 어플리케이션의 다른 어떠한 모듈들에서도 net/http 패키지를 사용하는 곳이 없다면 패키지 이름 충돌이 발생할 일은 없습니다. 이름을 중복시킴으로 얻을 수 있는 이점은 이를 통해 여러분이 HTTP와 관련된 모든 코드들은 새롭게 만든 http 패키지에 포함되도록 한다는 것입니다.</p>
<blockquote>
<p>It might seem odd to have a package with the same name as the dependency it wraps, however, this is intentional. There are no package name conflicts in your application unless you allow net/http to be used in other parts of your application. The benefit to duplicating the name is that it requires you to isolate all HTTP code to your http package.</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> http</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">		<span class="string">"net/http"</span></span><br><span class="line">		</span><br><span class="line">		<span class="string">"github.com/benbjohnson/myapp"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> {</span><br><span class="line">		UserService myapp.UserService</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">		<span class="comment">// handle request</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>이제 우리가 만든 http.Handler는 도메인과 HTTP 프로토콜 간 어댑터로서의 역할을 수행하게 됩니다.</p>
<blockquote>
<p>Now your http.Handler acts as an adapter between your domain and the HTTP protocol.</p>
</blockquote>
<br>

<h2 id="3-공유된-mock-하위패키지를-사용하라"><a href="#3-공유된-mock-하위패키지를-사용하라" class="headerlink" title="#3. 공유된 mock 하위패키지를 사용하라"></a>#3. 공유된 mock 하위패키지를 사용하라</h2><p>우리의 의존성들은 도메인 인터페이스를 통해 다른 의존성들과 분리되어 있기떄문에 우리는 mock 구현을 주입하기 위해 이러한 연결 지점들을 사용할 수 있습니다.</p>
<blockquote>
<p>Because our dependencies are isolated from other dependencies by our domain interfaces, we can use these connection points to inject mock implementations.</p>
</blockquote>
<p>여러분에게 mock를 생성해주는 GoMock과 같은 mocking 라이브러리들이 몇가지 있지만 저는 개인적으로 그것들을 직접 작성하는것을 선호합니다. 대부분의 mocking 도구들은 너무 복잡하게 되어있습니다.</p>
<blockquote>
<p>There are several mocking libraries such as GoMock that will generate mocks for you but I personally prefer to just write them myself. I find many of the mocking tools to be overly complicated.</p>
</blockquote>
<p>제가 사용하는 mocks는 매우 간단합니다. 예를 들어, UserService를 위한 mock은 아래와 같습니다:</p>
<blockquote>
<p>The mocks I use are very simple. For example, a mock for the UserService looks like:</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mock</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/benbjohnson/myapp"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// UserService represents a mock implementation of myapp.UserService.</span></span><br><span class="line"><span class="keyword">type</span> UserService <span class="keyword">struct</span> {</span><br><span class="line">		UserFn      <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="params">(*myapp.User, error)</span></span></span><br><span class="line">		UserInvoked <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">		UsersFn     <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">([]*myapp.User, error)</span></span></span><br><span class="line">		UsersInvoked <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// additional function implementations...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// User invokes the mock implementation and marks the function as invoked.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *UserService)</span> <span class="title">User</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="params">(*myapp.User, error)</span></span> {</span><br><span class="line">		s.UserInvoked = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">return</span> s.UserFn(id)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// additional functions: Users(), CreateUser(), DeleteUser()</span></span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>이 mock은 인자들의 유효성을 검사하거나 기대된 데이터가 반환되는지를 확인하거나 실패하는 케이스를 주입해보기 위해 myapp.UserService 인터페이스를 사용하기만 한다면 어느 곳이든 함수들을 주입해볼 수 있습니다.</p>
<blockquote>
<p>This mock lets me inject functions into anything that uses the myapp.UserService interface to validate arguments, return expected data, or inject failures.</p>
</blockquote>
<p>예를 들어 위에서 만들어 본 http.Handler를 테스트하기 원한다고 해봅시다:</p>
<blockquote>
<p>Let’s say we want to test our http.Handler that we built above:</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> http_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"testing"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"net/http/httptest"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/benbjohnson/myapp/mock"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHandler</span><span class="params">(t *testing.T)</span></span> {</span><br><span class="line">	<span class="comment">// Inject our mock into our handler.</span></span><br><span class="line">	<span class="keyword">var</span> us mock.UserService</span><br><span class="line">	<span class="keyword">var</span> h Handler</span><br><span class="line">	h.UserService = &amp;us</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Mock our User() call.</span></span><br><span class="line">	us.UserFn = <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="params">(*myapp.User, error)</span></span> {</span><br><span class="line">		<span class="keyword">if</span> id != <span class="number">100</span> {</span><br><span class="line">			t.Fatalf(<span class="string">"unexpected id: %d"</span>, id)</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> &amp;myapp.User{ID: <span class="number">100</span>, Name: <span class="string">"susy"</span>}, <span class="literal">nil</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Invoke the handler.</span></span><br><span class="line">	w := httptest.NewRecorder()</span><br><span class="line">	r, _ := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"/users/100"</span>, <span class="literal">nil</span>)</span><br><span class="line">	h.ServeHTTP(w, r)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Validate mock.</span></span><br><span class="line">	<span class="keyword">if</span> !us.UserInvoked {</span><br><span class="line">		t.Fatal(<span class="string">"expected User() to be invoked"</span>)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>mock는 유닛 테스트와 HTTP 프로토콜의 처리부분이 완전히 분리될 수 있도록 해줍니다.</p>
<blockquote>
<p>Our mock lets us completely isolate our unit test to only the handling of the HTTP protocol.</p>
</blockquote>
<br>

<h2 id="4-메인-패키지는-의존성들을-하나로-엮는다"><a href="#4-메인-패키지는-의존성들을-하나로-엮는다" class="headerlink" title="#4. 메인 패키지는 의존성들을 하나로 엮는다"></a>#4. 메인 패키지는 의존성들을 하나로 엮는다</h2><p>이러한 모든 의존성 패키지들이 고립된 채로 떠다니게 된다면 이들을 어떻게 하나로 결합할 수 있을지 궁금할 수 있습니다. 이 역할을 하는 것이 메인 패키지 입니다.</p>
<blockquote>
<p>With all these dependency packages floating around in isolation, you may wonder how they all come together. That’s the job of the main package.</p>
</blockquote>
<br>

<h3 id="메인-패키지-레이아웃"><a href="#메인-패키지-레이아웃" class="headerlink" title="메인 패키지 레이아웃"></a>메인 패키지 레이아웃</h3><p>어플리케이션은 2개 이상의 바이너리 파일을 생성할 수도 있는데 이를 위해 메인 패키지를 cmd 패키지의 하위 디렉토리로 두는 Go 언어의 관습(convention)을 사용할 것입니다. 예를 들어, 우리 프로젝트가 myapp 이라는 서버 바이너리뿐만 아니라 터미널을 통해 서버를 관리할 수 있도록 하는 myappctl 이라는 클라이언트 바이너리도 갖고있다고 해봅시다. 우리의 메인 패키지를 아래와 같이 구성하게 될 것입니다:</p>
<blockquote>
<p>An application may produce multiple binaries so we’ll use the Go convention of placing our main package as a subdirectory of the cmd package. For example, our project may have a myapp server binary but also a myappctl client binary for managing the server from the terminal. We’ll layout our main packages like this:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myapp/</span><br><span class="line">    cmd/</span><br><span class="line">        myapp/</span><br><span class="line">            main.go</span><br><span class="line">        myappctl/</span><br><span class="line">            main.go</span><br></pre></td></tr></table></figure>

<br>

<h3 id="컴파일-타임에-의존성-주입"><a href="#컴파일-타임에-의존성-주입" class="headerlink" title="컴파일 타임에 의존성 주입"></a>컴파일 타임에 의존성 주입</h3><p>“의존성 주입”이라는 용어는 나쁜 평판을 받아왔습니다. 이것은 장황한 Spring XML 파일에 대한 생각을 불러일으 킵니다. 하지만 그 용어의 실제 의미는 우리는 객체에게 스스로 빌드하거나 의존성을 직접 찾아가는 것을 요구하는 대신에 객체에게 의존성을 직접 전달해줄 것이다라는 것이 전부입니다.</p>
<blockquote>
<p>The term “dependency injection” has gotten a bad rap. It conjures up thoughts of verbose Spring XML files. However, all the term really means is that we’re going to pass dependencies to our objects instead of requiring that the object build or find the dependency itself.</p>
</blockquote>
<p>메인 패키지는 어떤 의존성을 어떤 객체에게 주입할 것인지를 선택하는 역할을 합니다. 메인 패키지는 단순히 이러한 조각들을 이어 붙이는 역할만을 수행하기 때문에 코드의 규모가 작고 사소한 경향이 있습니다:</p>
<blockquote>
<p>The main package is what gets to choose which dependencies to inject into which objects. Because the main package simply wires up the pieces, it tends to be fairly small and trivial code:</p>
</blockquote>
<figure class="codeblock codeblock--tabbed"><figcaption><ul class="tabs"><li class="tab active">go</li></ul></figcaption><div class="tabs-content"><figure class="highlight go" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	</span><br><span class="line">	<span class="string">"github.com/benbjohnson/myapp"</span></span><br><span class="line">	<span class="string">"github.com/benbjohnson/myapp/postgres"</span></span><br><span class="line">	<span class="string">"github.com/benbjohnson/myapp/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// Connect to database.</span></span><br><span class="line">	db, err := postgres.Open(os.Getenv(<span class="string">"DB"</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create services.</span></span><br><span class="line">	us := &amp;postgres.UserService{DB: db}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Attach to HTTP handler.</span></span><br><span class="line">	<span class="keyword">var</span> h http.Handler</span><br><span class="line">	h.UserService = us</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// start http server...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>

<p>여러분의 메인 패키지 또한 어댑터의 역할을 한다는 것도 중요한 점입니다. 메인 패키지는 터미널과 여러분의 도메인을 연결해줍니다.</p>
<blockquote>
<p>It’s also important to note that your main package is also an adapter. It connects the terminal to your domain.</p>
</blockquote>
<br>

<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>어플리케이션 디자인은 매우 어려운 문제입니다. 너무나 많은 디자인 결정들이 존재하고 여러분에게 가이드해줄 견고한 이론들의 부재는 문제를 더욱 심각하게 만들 수 있습니다. 우리는 Go 어플리케이션에서 현재 사용되는 몇가지 접근 방식을 살펴보았고 그것들의 많은 결함들을 확인했습니다.</p>
<blockquote>
<p>Application design is a hard problem. There are so many design decisions to make and without a set of solid principles to guide you the problem is made even worse. We’ve looked at several current approaches to Go application design and we’ve seen many of their flaws.</p>
</blockquote>
<p>저는 의존성의 관점을 통해 디자인에 접근하는 방식이 코드 구성을 더 단순하고 쉽게 추론할 수 있도록 만들어 준다고 생각합니다. 먼저 우리는 도메인 언어를 디자인 합니다. 그리고나서 의존성들을 분리합니다. 다음으로 테스트 환경을 분리하기 위해 mocks를 도입합니다. 마지막으로 메인 패키지 안에서 이 모든 것들을 하나로 엮습니다.</p>
<blockquote>
<p>I believe approaching design from the standpoint of dependencies makes code organization simpler and easier to reason about. First we design our domain language. Then we isolate our dependencies. Next we introduce mocks to isolate our tests. Finally, we tie everything together within our main package.</p>
</blockquote>
<p>여러분이 디자인할 다음 어플리케이션에 이러한 이론들을 고려해보시기 바랍니다. 질문이 있으시거나 디자인에 대한 토론을 원하신다면 @benbjohnson 트위터를 통해 연락주시거나 Gopher 슬랙에서 benbjohnson을 찾아주세요.</p>
<blockquote>
<p>Consider these principles in the next application you design. If you have any questions or want to discuss design, contact me at @benbjohnson on Twitter or find me as benbjohnson on the Gopher slack.</p>
</blockquote>
<br>
<br>

<span class="highlight-text yellow">해당 게시글에서 발생한 오탈자나 잘못된 내용에 대한 정정 댓글 격하게 환영합니다</span>😎

<p><strong>Reference</strong></p>
<ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.gobeyond.dev/standard-package-layout/">https://www.gobeyond.dev/standard-package-layout/</a></li>
</ul>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">태그</span><br>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/go/" rel="tag">go</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/go-layout/" rel="tag">go layout</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/golang/" rel="tag">golang</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/organize-go-code/" rel="tag">organize go code</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/package-layout/" rel="tag">package layout</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a class="post-action-btn btn btn--default tooltip--top" href="/2022/12/01/translate-packages-as-layers/" data-tooltip="그룹이 아닌 계층으로서의 Go 패키지" aria-label="이전: 그룹이 아닌 계층으로서의 Go 패키지">
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a class="post-action-btn btn btn--default tooltip--top" href="/2022/03/05/cmake-tutorial/" data-tooltip="CMake에 대해 알아보자" aria-label="다음: CMake에 대해 알아보자">
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="이 포스트 공유하기">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://chelseafandev.github.io/2022/09/06/translate-standard-package-layout-in-go/" title="Facebook에 공유하기" aria-label="Facebook에 공유하기" rel="external nofollow noopener noreferrer">
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="_blank" href="https://twitter.com/intent/tweet?text=https://chelseafandev.github.io/2022/09/06/translate-standard-package-layout-in-go/" title="Twitter에 공유하기" aria-label="Twitter에 공유하기" rel="external nofollow noopener noreferrer">
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="_blank" href="https://plus.google.com/share?url=https://chelseafandev.github.io/2022/09/06/translate-standard-package-layout-in-go/" title="Google+에 공유하기" aria-label="Google+에 공유하기" rel="external nofollow noopener noreferrer">
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="목차">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



<!-- Comment -->
<!--  utteranc comment -->

<script src="https://utteranc.es/client.js" repo="chelseafandev/blog-comment" issue-term="title" label="Comment" theme="github-light" crossorigin="anonymous" async>
</script>

                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2024 첼시팬개발자. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a class="post-action-btn btn btn--default tooltip--top" href="/2022/12/01/translate-packages-as-layers/" data-tooltip="그룹이 아닌 계층으로서의 Go 패키지" aria-label="이전: 그룹이 아닌 계층으로서의 Go 패키지">
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a class="post-action-btn btn btn--default tooltip--top" href="/2022/03/05/cmake-tutorial/" data-tooltip="CMake에 대해 알아보자" aria-label="다음: CMake에 대해 알아보자">
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="이 포스트 공유하기">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://chelseafandev.github.io/2022/09/06/translate-standard-package-layout-in-go/" title="Facebook에 공유하기" aria-label="Facebook에 공유하기" rel="external nofollow noopener noreferrer">
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="_blank" href="https://twitter.com/intent/tweet?text=https://chelseafandev.github.io/2022/09/06/translate-standard-package-layout-in-go/" title="Twitter에 공유하기" aria-label="Twitter에 공유하기" rel="external nofollow noopener noreferrer">
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="_blank" href="https://plus.google.com/share?url=https://chelseafandev.github.io/2022/09/06/translate-standard-package-layout-in-go/" title="Google+에 공유하기" aria-label="Google+에 공유하기" rel="external nofollow noopener noreferrer">
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="목차">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a class="share-option-btn" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://chelseafandev.github.io/2022/09/06/translate-standard-package-layout-in-go/" aria-label="Facebook에 공유하기" rel="external nofollow noopener noreferrer">
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Facebook에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a class="share-option-btn" target="_blank" href="https://twitter.com/intent/tweet?text=https://chelseafandev.github.io/2022/09/06/translate-standard-package-layout-in-go/" aria-label="Twitter에 공유하기" rel="external nofollow noopener noreferrer">
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Twitter에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a class="share-option-btn" target="_blank" href="https://plus.google.com/share?url=https://chelseafandev.github.io/2022/09/06/translate-standard-package-layout-in-go/" aria-label="Google+에 공유하기" rel="external nofollow noopener noreferrer">
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Google+에 공유하기</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/profile_github.jpeg" alt="저자 이미지">
        
            <h4 id="about-card-name">첼시팬개발자</h4>
        
            <div id="about-card-bio"><p>조금 더디더라도 꾸준히</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>개발자</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br>
                서울, 대한민국
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="external nofollow noopener noreferrer" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="/assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search" class="form-control input--large search-input" placeholder="Search ">
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">포스트가 없습니다.</div>
            <div class="results">
                
                <div class="media">
                    <!--  -->
                    <div class="media-body">
                        <a class="link-unstyled" href="https://chelseafandev.github.io/2021/07/08/hello-hexo/" aria-label=": Hexo Tranquilpeak 테마의 Markdown syntax">
                            <h3 class="media-heading">Hexo Tranquilpeak 테마의 Markdown syntax</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2021년 7월 8일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-nanumsquareround"><p>Hexo 테마 중 하나인 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak/blob/master/DOCUMENTATION.md">Tranquilpeak의 공식 문서</a>를 참조하여 Post시에 활용할 수 있는 다양한 Markdown syntax들을 사용해보았습니다.</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    <!-- 
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="https://chelseafandev.github.io/2021/07/10/tr-ruud-gullit/"
                            aria-label=": (BBC 스포츠) 첼시 루드 굴리트 25년이 지난 지금 그의 프리미어그리 진출을 애정어린 시선으로 되돌아 보다"
                        >
                            <img class="media-image" src="https://chelseafandev.github.io/2021/07/10/tr-ruud-gullit/tr_ruud_gullit_picture_1.png" width="90" height="90"/>
                        </a>
                    </div>
                     -->
                    <div class="media-body">
                        <a class="link-unstyled" href="https://chelseafandev.github.io/2021/07/10/tr-ruud-gullit/" aria-label=": (BBC 스포츠) 첼시 루드 굴리트 25년이 지난 지금 그의 프리미어그리 진출을 애정어린 시선으로 되돌아 보다">
                            <h3 class="media-heading">(BBC 스포츠) 첼시 루드 굴리트 25년이 지난 지금 그의 프리미어그리 진출을 애정어린 시선으로 되돌아 보다</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2021년 7월 10일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-nanumsquareround"><p>피파 좀 한다는 사람이라면 모두가 다 알만한 그 분, X사기캐 굴리트😬<br>커리어 막바지에 첼시에서도 잠깐 활약했었네요.<br><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.bbc.com/sport/football/52904670">BBC Sport에 굴리트가 직접 기고한 회고록 느낌의 글</a>을 한번 번역해보았습니다.</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    <!--  -->
                    <div class="media-body">
                        <a class="link-unstyled" href="https://chelseafandev.github.io/2021/07/13/os-io-system/" aria-label=": I/O는 어떻게 처리될까?">
                            <h3 class="media-heading">I/O는 어떻게 처리될까?</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2021년 7월 13일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-nanumsquareround"><p>운영 체제의 바이블 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.wiley.com/en-us/Operating+System+Concepts%2C+10th+Edition-p-9781119320913">Operating System Concepts</a>(흔히 공룡책🦕이라고들 하죠)을 바탕으로 I/O 시스템에 대해 정리해보았습니다.</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    <!--  -->
                    <div class="media-body">
                        <a class="link-unstyled" href="https://chelseafandev.github.io/2021/07/22/tip-how-to-use-tmux-md/" aria-label=": 강력한 터미널 멀티플렉서 tmux를 활용해보자">
                            <h3 class="media-heading">강력한 터미널 멀티플렉서 tmux를 활용해보자</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2021년 7월 22일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-nanumsquareround"><p>이번엔 익숙해지면 정말 강력한 터미널 멀티플렉서인 tmux에 대해 소개해보려고 합니다.</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    <!--  -->
                    <div class="media-body">
                        <a class="link-unstyled" href="https://chelseafandev.github.io/2021/08/02/os-sync-async-block-nonblock/" aria-label=": Blocking, Nonblocking, Sync, Async">
                            <h3 class="media-heading">Blocking, Nonblocking, Sync, Async</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2021년 8월 2일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-nanumsquareround"><p>오늘은 공룡책🦕에 언급된 Blocking과 Nonblocking, Synchronous와 Asynchronous에 대해서 정리해보고자 합니다. Synchronous와 Asynchronous의 개념은 <strong>쓰레드</strong>와 <strong>I/O</strong>에서 등장하게 되는데요, 각각이 어떠한 의미로 사용되는지도 구분해서 살펴보도록 하겠습니다.</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    <!-- 
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="https://chelseafandev.github.io/2021/08/05/tr-lukaku-want-to-chelsea/"
                            aria-label=": (BBC 스포츠) 첼시의 물망에 오른 루카쿠 적절한 오퍼가 온다면 인터 밀란을 떠나기 원해"
                        >
                            <img class="media-image" src="https://chelseafandev.github.io/2021/08/05/tr-lukaku-want-to-chelsea/tr-lukaku-want-to-chelsea.jpg" width="90" height="90"/>
                        </a>
                    </div>
                     -->
                    <div class="media-body">
                        <a class="link-unstyled" href="https://chelseafandev.github.io/2021/08/05/tr-lukaku-want-to-chelsea/" aria-label=": (BBC 스포츠) 첼시의 물망에 오른 루카쿠 적절한 오퍼가 온다면 인터 밀란을 떠나기 원해">
                            <h3 class="media-heading">(BBC 스포츠) 첼시의 물망에 오른 루카쿠 적절한 오퍼가 온다면 인터 밀란을 떠나기 원해</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2021년 8월 5일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-nanumsquareround"><p>오늘은 첼시 이적설이 가까워져가고 있는 루카쿠 관련 기사를 가져왔습니다. 베르너의 결정력이 너무나도 아쉬웠던 지난 시즌 첼시를 생각하면 꼭 필요한 영입이라고 생각되네요😁</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    <!-- 
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="https://chelseafandev.github.io/2021/08/12/tr-son-new-contract/"
                            aria-label=": (BBC 스포츠) 토트넘 공격수 손흥민 4년 재계약 성사"
                        >
                            <img class="media-image" src="https://chelseafandev.github.io/2021/08/12/tr-son-new-contract/tr-son-new-contract-figure1.jpg" width="90" height="90"/>
                        </a>
                    </div>
                     -->
                    <div class="media-body">
                        <a class="link-unstyled" href="https://chelseafandev.github.io/2021/08/12/tr-son-new-contract/" aria-label=": (BBC 스포츠) 토트넘 공격수 손흥민 4년 재계약 성사">
                            <h3 class="media-heading">(BBC 스포츠) 토트넘 공격수 손흥민 4년 재계약 성사</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2021년 8월 12일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-nanumsquareround"><p>오늘은 현재 프리미어리그 토트넘 핫스퍼에서 활약 중인 손흥민 선수의 재계약 관련 기사를 가져왔습니다. 다음 시즌 누누감독이 이끌게 되는 토트넘, 쌉월클👍 손흥민선수와 함께 좋은 성적 거뒀으면 좋겠습니다.</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    <!--  -->
                    <div class="media-body">
                        <a class="link-unstyled" href="https://chelseafandev.github.io/2021/09/24/hyperscan-phase1/" aria-label=": 인텔 Hyperscan 레퍼런스 가이드 번역">
                            <h3 class="media-heading">인텔 Hyperscan 레퍼런스 가이드 번역</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2021년 9월 24일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-nanumsquareround"><p>이번 포스팅에서는 인텔 Hyperscan의 <a target="_blank" rel="external nofollow noopener noreferrer" href="http://intel.github.io/hyperscan/dev-reference/index.html">공식 문서</a>를 통해 컴파일(compile)이나 스캔(scan)과 같은 Hyperscan의 기본적인 개념들에 대해 알아보도록 하겠습니다. 추후에는 Hyperscan API를 직접 사용하여 정규 표현식 패턴 매칭을 수행하는 샘플 코드도 업로드할 예정입니다.</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    <!--  -->
                    <div class="media-body">
                        <a class="link-unstyled" href="https://chelseafandev.github.io/2021/10/12/hyperscan-phase2/" aria-label=": 인텔 Hyperscan API 테스트 코드 작성">
                            <h3 class="media-heading">인텔 Hyperscan API 테스트 코드 작성</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2021년 10월 12일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-nanumsquareround"><p>이번 포스팅에서는 <a href="https://chelseafandev.github.io/2021/09/24/hyperscan-phase1/">인텔 Hyperscan 레퍼런스 가이드 번역</a>에 이어서 Hyperscan API를 직접 사용하여 정규 표현식 패턴 매칭을 수행하는 샘플 코드를 작성하고 테스트 해보는 시간을 갖겠습니다.</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    <!--  -->
                    <div class="media-body">
                        <a class="link-unstyled" href="https://chelseafandev.github.io/2021/11/09/gdb-chapter4-program-crash/" aria-label=": Seg Fault는 왜 발생하는가?">
                            <h3 class="media-heading">Seg Fault는 왜 발생하는가?</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2021년 11월 9일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-nanumsquareround"><p>이번 포스팅에서는 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://nostarch.com/debugging.htm">The Art of Debugging with GDB, DDD and Eclipse</a>의 <strong>Chatper 4 WHEN A PROGRAM CRASHES</strong> 내용을 번역해보았습니다. 해당 챕터의 앞부분에서는 가상 주소 공간에서의 페이지(page)에 대한 개념을 소개하고 seg fault가 발생하는 원인을 페이지(page)와 연관지어 잘 설명해주고 있습니다.</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium" data-message-zero="포스트가 없습니다." data-message-one="1 개의 포스트가 있습니다." data-message-other="{n} 개의 포스트가 있습니다.">
                28 개의 포스트가 있습니다.
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/chelsea_cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/jquery.js"></script>


<script src="/assets/js/jquery.fancybox.js"></script>


<script src="/assets/js/thumbs.js"></script>


<script src="/assets/js/tranquilpeak.js"></script>

<!--SCRIPTS END-->


    



    
<script src="/assets/js/moment-with-locales.js"></script>

    
<script src="/assets/js/algoliasearch.js"></script>

    <script>
      var algoliaClient = algoliasearch('FDTOJ7KLS8', '935491408ac4c43d728c68858e4ea147');
      var algoliaIndex = algoliaClient.initIndex('chelseafandev');
    </script>


    </body>
</html>
